<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024年终总结</title>
      <link href="/2024/12/29/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/29/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>爱是恒久忍耐，又有恩慈，爱是不嫉妒，爱是不自夸，不张狂，不做害羞的事，不求自己的益处，不轻易发怒，不计算人的恶，不喜欢不义，只喜欢真理；凡事包容，凡事相信，凡事盼望，凡事忍耐。——哥林多前书13:4-7</p></blockquote><h2 id="肉体苦弱：病痛"><a href="#肉体苦弱：病痛" class="headerlink" title="肉体苦弱：病痛"></a>肉体苦弱：病痛</h2><p>今年我的身体并不是很好，上半年在食堂吃饭，食物中毒；下半年快入冬，又很奇怪地得了支气管炎。</p><p>食物中毒是最难受的，吃什么吐什么，什么都吃不下去，甚至喝一点水肚子就要抗议。身体发冷，头脑发烧，肚子里恶心得睡不着觉。生病的那几天，全靠康师傅的冰糖雪梨吊命——因为这个貌似是超市里碳水化合物含量最高的饮料了。不过在黄连素和乳酸菌素片的效果下，恢复极快，三四天就痊愈了。不过在这之后，肚子的耐受力差了很多，大概是之前所摄入的毒物对肠道菌群的影响吧。</p><p>支气管炎也蛮难受的。白天咳嗽绿色的痰液，半夜总是嗓子突然痒起来，咳嗽不止，胸口疼痛犹如锤砸。十月份中期确诊支气管炎，现在大概恢复得差不多了。有意思的是，我第一次去医院开药，开了抗生素，只恢复了一半——不再咳嗽绿色的痰液了，然而半夜依旧会咳醒，第二次去医院开了针对支原体的药，这回大概又恢复了一点，然而还有一些症状，于是第三次去医院，医生说静养即可。直到现在，大概恢复的差不多了。</p><p>然而这两天，吃点东西就会恶心嗳气，也不知道为什么，昨天夜里脑袋突然痛得要死，稍微移动就会剧烈疼痛。今天早晨醒来，头不痛了，然而肚腹依然不舒服。</p><h2 id="傲慢之罪：哲学"><a href="#傲慢之罪：哲学" class="headerlink" title="傲慢之罪：哲学"></a>傲慢之罪：哲学</h2><p>我之前是哲学的狂热爱好者。究其原因，我大学之前的学习生活非常的不开心，非常压抑。这导致我想从哲学中寻找到一个普适的、通用的、用来解释世界和社会的理论，因为我知道，只要我能够学会这个理论，那么我就有机会解决我自己身上的问题。然而，结果是——哲学一点用也没有。经过大约八年的求索与学习，我什么也没有学会，脑海里只有彼此冲突的理论和人类智慧的碎片。</p><p>哲学思想通常是这样的，一个人提出一个思想，后人通过批判这个思想中的不足之处，建构属于自己的理论。通过学习哲学，我得出了这样的两个结论：每个哲学思想都是有纰漏的、每个哲学思想都是有适用范围的。这两点不断推动着哲学的发展——这对于哲学学术发展当然是好事，但对于求索者来说，却是最坏的坏事。因为随着建构-解构的循环，哲学理论逐渐变成了抽象、难以理解、不说人话的一门学科，理论越来越脱离于实际，没法作用于实际。</p><p>哲学家们尝试搭建一个房屋，然而，他们最开始还搭建——尽管搭建得也很歪——最后去彼此拆毁对方建好的部分。这导致最后就是一片废墟，人们在对骂。而在废墟旁等着住房子的人们，却淋着生活的雨，在瑟瑟发抖。</p><p>最终，我只能得出这样一个结论：<strong>“人的智慧没法解决人的问题”</strong>。</p><h2 id="无尽深渊：神秘学"><a href="#无尽深渊：神秘学" class="headerlink" title="无尽深渊：神秘学"></a>无尽深渊：神秘学</h2><p>抛弃哲学，我转而去研究了神秘学，更确切地说，是占卜学和神秘主义的世界观。</p><p>占卜确实很灵，不论是东方的六爻、六壬，还是西方的塔罗牌、灵摆，它们在很多时候都是很准的。不过，它们除了预知未来，就没有任何用了。这就好像被恶人绑在铁轨上，让你目送轧死你的火车从远处开来一般。改变未来是很难的。总之，它也没法解决我的问题。</p><p>神秘主义世界观在于主观感知世界，通过感知来形成对世界的一种认知。这一点不便详述。</p><h2 id="爱与勇气的信条：基督教"><a href="#爱与勇气的信条：基督教" class="headerlink" title="爱与勇气的信条：基督教"></a>爱与勇气的信条：基督教</h2><blockquote><p>当邪情欲念已寄居于灵魂良久,且其透过习惯,恍若已成灵魂之天性,此时的邪情欲念便名为恶习,而处于此阶段的灵魂已养成恣意追求恶习之性情。——圣天梯成德者约翰</p></blockquote><p>真正让我快乐起来的事情是——帮助别人、怜恤别人。在研究神秘学的末期，我开始研究宗教学的一些东西。我尝试读了古兰经、圣经和一些佛经。我发现，只有圣经里的内容能真正让我产生共鸣——并不是新教徒视为圭臬的“传教”部分（他们错误理解了这一部分），而是爱。</p><p>以前的我不快乐的原因，就是实在是太纠结于自己的利益了，一点亏也不能吃。此外，我也不敢面对自己，面对未来，时不时就会抑郁。因为我并没有所信之物，我之前所信的东西已经被哲学解构一空了。当人没有所信之物，就会贪恋于一时的快乐，当短期的快乐消退，阈值随之提高，最终人们越来越极端，越来越庸俗。</p><p>直到我真正尝试按照经上所记载的那样去怜恤别人、帮助别人，我才收获到了真正的快乐。此外，当我处于病痛时，我第一次体会到了祷告带来的作用。当我有了这样的经验，我便对经上所记之事深信不疑。因为我通过实践，完全验证了它们的正确性。既然如此，我又何必畏惧当下的一切呢？我没什么可忧郁的，也没什么可害怕的。</p><p>今年貌似看得最感动的电影便是《耶稣受难记》，若人人都能有十分之一耶稣的爱，又哪会惧怕邪恶与痛苦呢？在我看来，如果人们彼此相爱，那么所有问题都会荡然无存。然而人们是傲慢的，是将欲望与庸俗之物视作偶像的。</p><p>快乐要向内求，要向外显，其根本是谦和与爱。如今，我的信条是这样的：<strong>我是为万人所恨之人，但我仍要尽我所能去爱别人。</strong></p><p>关于这个话题，我没什么可说的。因为我知道，这是一个只有自己才能悟出来的道理，一条充斥着谬误与诱惑的长路。</p><h2 id="科学是对功能的创造：工作"><a href="#科学是对功能的创造：工作" class="headerlink" title="科学是对功能的创造：工作"></a>科学是对功能的创造：工作</h2><p>今年最值得称道的工作便是，在师兄的带领下，自己向ACL顶会投了一篇论文，虽然目前还在审核。</p><p>这次工作自己并没有参与太多idea的讨论，主要还是积攒了一些实验上的经验。如何编写自然语言处理的代码，如何最小化计算成本……自己还是学到了很多东西。</p><p>在进组之前——其实现在也是——自己对于未来依旧没什么想法。只要是计算机编码有关的，那我便可以做。现在大概明白未来的几年要做些什么了。</p><p>此外，通过这次工作，自己在沟通、文书写作上的弱势还是被展示了出来。算法、技术并不是一切，还有很多技术之外的事情。</p><p>这可比上课有意思多了。</p><h2 id="我之所学：知识"><a href="#我之所学：知识" class="headerlink" title="我之所学：知识"></a>我之所学：知识</h2><p>今年主要学习的，还是音乐方面的一些东西——和声学、曲式学以及一些基础的编曲教程，大概明白该如何进行歌曲的写作——只是不好听而已。在这之后打算学一学配器法和对位法。</p><p>语言方面，自己学了点简单的日语、俄语和希伯来语。日语是为了去日本旅行方便，希伯来语则是为了读原版的旧约圣经，因为中文的旧约翻译是有谬误的。在这之后可能会学一学简单的希腊语。俄语则是为了给教会斯拉夫语做先导。</p><p>此外，自己也啃了一些神学的书籍，尤其是东正教的神学，相比于剩下两个大教派，它们更加注重实践，更加理性，也没有为了世俗而刻意修改什么。不过，最有用的知识，还是大概学到了如何去怜恤他人。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望新的一年里，能够身体健康，万事行得不偏不斜。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【乐理/编写中】爵士乐和声学小记</title>
      <link href="/2024/12/15/%E3%80%90%E4%B9%90%E7%90%86-%E7%BC%96%E5%86%99%E4%B8%AD%E3%80%91%E7%88%B5%E5%A3%AB%E4%B9%90%E5%92%8C%E5%A3%B0%E5%AD%A6%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/12/15/%E3%80%90%E4%B9%90%E7%90%86-%E7%BC%96%E5%86%99%E4%B8%AD%E3%80%91%E7%88%B5%E5%A3%AB%E4%B9%90%E5%92%8C%E5%A3%B0%E5%AD%A6%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>参见<a href="https://www.bilibili.com/video/BV1JJ411c7wo/">流行爵士和声学（廖季文）1-4</a>。作笔记回看用。</p><h1 id="音阶"><a href="#音阶" class="headerlink" title="音阶"></a>音阶</h1><h2 id="大调音阶"><a href="#大调音阶" class="headerlink" title="大调音阶"></a>大调音阶</h2><blockquote><p>重点：五度圈与大调音阶升降哪些音的关系</p></blockquote><p>音乐的根本是音阶，我们首先来研究一下不同调的大调音阶。</p><p>我们常用的C调音阶是CDEFGABC，12345671。这是一个全全半全全全半的关系，可以看作两个“四声音阶”通过一个全音联系起来。向上发展，那么我们发现，每次发展，排列的第七个音都会升高半音，比如将GABC看作1234，那么向上发展，为了满足全全半全全全半的规律，则必须接续DEF#G。每次发展，升高的音是导音，其音名满足：FCGDAEB的规律。此外，我么发现，每次发展，主音都会变为五度音，那么我们就得到了不同调的主音与升音规律，比如G调，其导音为F，根据FCGDAEB的规律，我们只需要升高其F音即可，那么G调音阶就是GABCDE#FG；比如E调，其导音是D，那么我们就需要升高FCGD这几个音，那么E调音阶就是E#F#GAB#C#DE。其实，升高的音也满足五度圈的关系，因为每次发展，主音变为了原调的五度音。</p><p>同理，降调也有：BEADGCF的规律。比如降C大调，就要降低七个音；降G大调，就要降低BEADGC六个音。只有一个降记号，是F调。</p><h2 id="小调音阶"><a href="#小调音阶" class="headerlink" title="小调音阶"></a>小调音阶</h2><blockquote><p>重点：升降音的唱名</p></blockquote><p>每个大调，有与其相关的关系小调和平行小调。关系小调是指使用的音一致，平行小调则是指开始的音一致。升音唱名，是将所升之音的唱名的元音改为i，而降音则是e，不过，降2要唱成Ra。</p><h1 id="音程"><a href="#音程" class="headerlink" title="音程"></a>音程</h1><h2 id="音程的转位"><a href="#音程的转位" class="headerlink" title="音程的转位"></a>音程的转位</h2><blockquote><p>重点：转位后音程的性质与度数</p></blockquote><p>对于两个音来说，它们之间的音程可以有两种，比如C和G，C-G是纯五度——这是当C为低音时考虑的；G-C则是纯四度——这是当G为低音时考虑的。</p><p>音程的性质转位有这样的关系：</p><table><thead><tr><th>音程性质</th><th>转位后音程性质</th></tr></thead><tbody><tr><td>倍增</td><td>倍减</td></tr><tr><td>增</td><td>减</td></tr><tr><td>大</td><td>小</td></tr><tr><td>小</td><td>大</td></tr><tr><td>纯</td><td>纯</td></tr><tr><td>减</td><td>增</td></tr><tr><td>倍减</td><td>倍增</td></tr></tbody></table><p>音程的度数，在转位后，会变为9-原来度数的形式，比如增四度的转位就是减五度，大三度的转位便是小六度。</p><h2 id="复合音程"><a href="#复合音程" class="headerlink" title="复合音程"></a>复合音程</h2><p>复合音程是指超过八度的音程。复合音程和其减去7的音程，听感是极其类似的，比如纯十五度音程和纯八度听感差不多。</p><p>这个根本原因是，八度是足够协和的。附加一个八度、移除一个八度，听感差别并不大。</p><h1 id="大调和弦"><a href="#大调和弦" class="headerlink" title="大调和弦"></a>大调和弦</h1><h2 id="七和弦"><a href="#七和弦" class="headerlink" title="七和弦"></a>七和弦</h2><blockquote><p>重点：常用七和弦的种类</p></blockquote><p>我们在《基础的乐理教程》一文中讲过，七和弦有常用的八种排列。然而，这八种排列中，更加常用的四种和弦则是<strong>大七和弦、小七和弦、属七和弦（大小七和弦）和半减七和弦</strong>。</p><p>在大七和弦中，也可以采用六音替代七音的做法，这种便叫做大六和弦。在属七和弦中，常常使用挂留四和弦，即将三音换为纯四度音。在这里，视频教程疑似有误。</p><h2 id="和弦、和音排序、和声三者的区别"><a href="#和弦、和音排序、和声三者的区别" class="headerlink" title="和弦、和音排序、和声三者的区别"></a>和弦、和音排序、和声三者的区别</h2><blockquote><p>重点：和弦、和音排序、和声三者的区别</p></blockquote><p>用英文来讲，和弦是Chord，和音排序是Voicing，和声则是Harmony。</p><p>通常，和弦只强调组成音。和弦内的组成音的排序变化则是Voicing的变化——比如转位。和声则更看重和弦进行的角度。</p><p>这里和和声学的讲法有一定差别。</p><h2 id="吉他演奏技法：Drop-Voicing"><a href="#吉他演奏技法：Drop-Voicing" class="headerlink" title="吉他演奏技法：Drop Voicing"></a>吉他演奏技法：Drop Voicing</h2><blockquote><p>重点：Drop Voicing的排列与几种代换技巧</p></blockquote><p>由于吉他的排列问题，我们会发现，有时二度的音没有办法很好地弹出来；此外，我们有时也需要将一个和弦进行变换，以达到进行换把和丰富音乐听感的方法。这种时候，Drop Voicing往往是一个非常好的工具。</p><p>比较常见的几个方法是：</p><ol><li><strong>Drop 2</strong>：将从高至低的第二个音下降八度。</li><li><strong>Drop 3</strong>：将从高至低的第三个音下降八度。</li><li><strong>Drop 2&amp;4</strong>：将从高至低的第二个音和第四个音都下降八度。</li></ol><p>此外，当我们将一些七和弦进行第三转位时，我们发现——以Cmaj7举例子——其由1357的排列变为了7351。而低音的7和高音的1是一个小九度关系，小九度则是一个非常不和谐、非常难听的音程（您可以试试小二度的音程听感），这个时候我们要以大九度代替小九度。这个和弦就叫做$\frac{9}{1}$和弦，用9音代替了转位上去的1音。此外，也可以用6代替7，作为$\frac{6}{7}$和弦，用6音代替了转位下来的7音。其根本规律都是——<strong>规避不和谐的音程</strong>。</p><h2 id="和声学的写作技法：开放与密集排列的合用"><a href="#和声学的写作技法：开放与密集排列的合用" class="headerlink" title="和声学的写作技法：开放与密集排列的合用"></a>和声学的写作技法：开放与密集排列的合用</h2><blockquote><p>重点：实际音乐的写作技法</p></blockquote><p>如小节标题所言，要学会结合开放排列、密集排列的和弦，让整个编排变得开-密-开-密，带来听感上的和谐。开放排列的和弦能够给和声带来一种松散感，密集排列则反之。</p><p>要从和声学的做题角度跳脱开来，灵活写作。</p><h2 id="调性七和弦"><a href="#调性七和弦" class="headerlink" title="调性七和弦"></a>调性七和弦</h2><blockquote><p>重点：大调音阶上不同根音所构造七和弦的性质</p></blockquote><p>调性七和弦就是指，在现有音阶上构造的七和弦。</p><p>以C大调音阶为例子，从C~B构造：</p><ol><li>C-大七</li><li>D-小七</li><li>E-小七</li><li>F-大七</li><li>G-属七</li><li>A-小七</li><li>B-半减七</li></ol><p>但是对于B的半减七和弦，内部含有一个减五度音程，这会导致其听感的不愉快性。实际上，在三和弦中，七级调性三和弦也是很少使用的。减五度只有在属七和弦中才会带来相对愉快的听感。</p><p>在和弦中，七音体现延伸音的价值，三音体现和弦的性质。没有七音就没有办法愉快地使用延伸音。在七和弦中，最没有特色的音是五音</p><h2 id="三全音代理"><a href="#三全音代理" class="headerlink" title="三全音代理"></a>三全音代理</h2><p>属七和弦中，想要解决的音程是哪个减五度音程B-F，那么只要由这个音程，其他的音如何摆放并不重要，都可以满足属七和弦的待解决性质。</p><p>那么，我们就可以在C大调中，用降D七和弦代替属七和弦。其实，三全音代理和弦满足这样一个规律——<strong>三全音代理和弦的根音，一定是目标音的高半音</strong>。属七和弦要解决到主和弦，高半音就是降D。</p><h2 id="大调和弦的功能类别"><a href="#大调和弦的功能类别" class="headerlink" title="大调和弦的功能类别"></a>大调和弦的功能类别</h2><blockquote><p>重点：不同和弦的功能</p></blockquote><ol><li><strong>主功能组</strong>：一级七、三级七、六级七</li><li><strong>下属功能组</strong>：二级七、四级七</li><li><strong>属功能组</strong>：属七（五级七）</li></ol><p>具备下属音则算是下属功能，若同时具备下属音和导音，就存在解决的可能，就是属功能组。</p><h2 id="次级属七"><a href="#次级属七" class="headerlink" title="次级属七"></a>次级属七</h2><blockquote><p>重点：次级属七和弦组成方式和记法</p></blockquote><p>除去主和弦的属七是本调的五级七和弦外，剩下常用的六个和弦也拥有属于自己的属七和弦，比如C大调中，二级的小七和弦，就有属于自己的属七和弦——A7和弦。这种和弦便称作<strong>次级属七和弦</strong>。它们的特点是，<strong>拥有一个调性的根音</strong>，且拥有一个或一个以上的调外音。次级属七和弦和与之对应的调内和弦，必须是<strong>纯五度</strong>下降关系。</p><p>七级和弦没有自己的次级属七，因为其次级属七的根音非调内音，此外，这个解决也是不够好听的，因为七级和弦本身的和声就是不稳定的。</p><p>那么，如何标记这些和弦呢？比如C大调内，B7和弦就是三级的属七，就记作$V_7&#x2F;$Ⅲ。</p><p>此外，小七和弦的次级属七和弦，称作小次属；那么，在大七和弦上的，就叫做大次属。</p><h2 id="全终止：4-x2F-2-5-1"><a href="#全终止：4-x2F-2-5-1" class="headerlink" title="全终止：4&#x2F;2-5-1"></a>全终止：4&#x2F;2-5-1</h2><blockquote><p>重点：2代替4的原理</p></blockquote><p>完全的调性声明。传统通常利用4-5-1的进行，而现代和声学则使用2-5-1的进行，因为<strong>完全五度的下行更加强而有力</strong>。</p><p>不过，这里我倾向于这样理解：二级和弦是五级和弦的属，五级和弦又是一级和弦的属，这样构成了一个属和弦的运转链，相当于两次解决。而在传统的4-5-1进行中，四级和弦并不是五级和弦的属，相对来说，这个进行并不是足够的好听。属和弦的属和弦又叫做<strong>重属和弦</strong>。</p><p>此外，在C大调中，七级调性和弦-三级次属-六级调性和弦的进行是允许的。</p><h2 id="补录"><a href="#补录" class="headerlink" title="补录"></a>补录</h2><p>大调音阶中，特征音是四级音，包含特征音则是下属。</p><h1 id="小调和弦"><a href="#小调和弦" class="headerlink" title="小调和弦"></a>小调和弦</h1><h2 id="自然小调调性七和弦"><a href="#自然小调调性七和弦" class="headerlink" title="自然小调调性七和弦"></a>自然小调调性七和弦</h2><blockquote><p>重点：小调音阶上不同根音构造的七和弦性质</p></blockquote><p>自然小调音阶是这样来的。比如我们最开始有C大调音阶，从A音开始排列，得到了一个全半关系的排列。那么满足这个条件的音阶就是自然小调音阶，因为其脱胎于自然大调音阶。</p><p>以C自然小调音阶为例，注意降记号的标注位置：</p><ol><li>C-小七</li><li>D-半减七</li><li>降E-大七(E♭maj7,♭Ⅲmaj7)</li><li>F-小七</li><li>G-小七</li><li>降A-大七</li><li>降B-属七</li></ol><h2 id="终止式"><a href="#终止式" class="headerlink" title="终止式"></a>终止式</h2><p>使用终止式时，要将五级的小七和弦变为属七和弦，这个时候要将降B还原为B音，还原之后，我们得到了新的音阶。</p><h2 id="和声小调调性七和弦"><a href="#和声小调调性七和弦" class="headerlink" title="和声小调调性七和弦"></a>和声小调调性七和弦</h2><p>我们当把降B音还原为B音之后，有三个和弦发生了改变——一级、三级和七级，他们的变化为：</p><ol><li>C-小大七</li><li>降E-大七升五</li><li>B-减七和弦</li></ol><p>这个音阶便叫做和声小调音阶(Harmonic Minor)，因为这个音阶是为了解决自然小调音阶和声上的不足——缺乏属七和弦的张力——而变化的。</p><h2 id="小九度的使用"><a href="#小九度的使用" class="headerlink" title="小九度的使用"></a>小九度的使用</h2><blockquote><p>重点：小九度的两个使用例</p></blockquote><p>小九度可以出现在<strong>属七和弦</strong>的<strong>根音-降九度音</strong>以及<strong>五度-降十三度音</strong>中。因为，属七和弦中理应出现张力(tension)。</p><p>但是<strong>三音和十一音</strong>之间的小九度是不允许出现的。</p><h2 id="属七和弦的混搭"><a href="#属七和弦的混搭" class="headerlink" title="属七和弦的混搭"></a>属七和弦的混搭</h2><p>我们可以在大调中使用<strong>二级小七和五级属七降九</strong>构成的的终止式。在大调音阶中，是没有降九度音的，我们可以从平行小调中借用五级属七降九和弦进行使用。</p><p>同样，在小调中，也可以使用<strong>二级半减七和五级属七</strong>构成的终止式，这个是从大调中借过来的音。</p><h2 id="和声小调音阶的不足"><a href="#和声小调音阶的不足" class="headerlink" title="和声小调音阶的不足"></a>和声小调音阶的不足</h2><blockquote><p>重点：和声小调音阶的不足</p></blockquote><p>和声小调音阶固然解决了自然小调音阶在和声上的缺陷，然而其又造成了另外一个缺陷，那就是降A到B的一个跳音——这两个音之间的音程太大了。</p><p>解决办法也很简单，那就是将降A音提高到A音，我们就得到了<strong>旋律小调音阶</strong>(Melodic Minor)——这是为了解决旋律上缺陷而设计出来的音阶。</p><h2 id="旋律小调音阶的不足"><a href="#旋律小调音阶的不足" class="headerlink" title="旋律小调音阶的不足"></a>旋律小调音阶的不足</h2><blockquote><p>重点：旋律小调音阶的上下行</p></blockquote><p>从听感上来说，旋律小调音阶上行时，能明显听出来这是小调音阶，然而，当下行时，却给人一种听感上的大调感。于是，在下行时，恢复自然小调音阶。</p><h2 id="和弦功能归纳"><a href="#和弦功能归纳" class="headerlink" title="和弦功能归纳"></a>和弦功能归纳</h2><blockquote><p>此节的和弦归纳我并不认可。</p></blockquote><p>小调音阶中，特征音为六级音，特指自然小调的六级音。</p><ol><li><strong>主功能组</strong>：一、三级</li><li><strong>下属功能组</strong>：二、四、六级</li><li><strong>属功能组</strong>：<strong>五级属七</strong></li></ol><p>这和大调的功能类别不同，因为特征音不同，包含特征音即是下属和弦。</p><p>对于自然小调自带的<strong>五级小七</strong>和弦，我们不可以使用降9和降13音，因为只有在属七和弦中才可以出现小九度。不过，我们可以利用五级小七和弦加上一个十一音。</p><h2 id="自然小调的七级和弦"><a href="#自然小调的七级和弦" class="headerlink" title="自然小调的七级和弦"></a>自然小调的七级和弦</h2><p>自然小调的七级和弦具有属七的结构，而不具备属七的功能。只有在关系大调中，自然小调的七级和弦才会变成五级属七。</p><p>所以，如果没有转调、离调的需求，我们更常让自然小调的七级和弦回归到一级小七和弦上。</p><h2 id="次级属七-1"><a href="#次级属七-1" class="headerlink" title="次级属七"></a>次级属七</h2><p>在小调中，次级属七也要满足<strong>调内根音、纯五度下降</strong>这些条件。</p><h1 id="双重功能与大小调和弦的相互支援"><a href="#双重功能与大小调和弦的相互支援" class="headerlink" title="双重功能与大小调和弦的相互支援"></a>双重功能与大小调和弦的相互支援</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LaTeX】问题汇总</title>
      <link href="/2024/12/14/%E3%80%90LaTeX%E3%80%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2024/12/14/%E3%80%90LaTeX%E3%80%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这篇文章是记录性的，主要记录的内容有：</p><ol><li>如何在VSCode上配置LaTeX的编写环境。</li><li>如何解决我遇到的与LaTeX有关的问题，这些问题通常和LaTeX、VSCode编辑器都有关系。</li></ol><h1 id="如何配置？"><a href="#如何配置？" class="headerlink" title="如何配置？"></a>如何配置？</h1><p>我们需要：</p><ol><li>安装<code>MiKTeX</code>，至于它具体是什么，参见<a href="https://zh.wikipedia.org/zh-cn/MiKTeX">维基百科：<code>MiKTeX</code></a>。</li><li>在VSCode上安装名为<code>LaTeX Workshop</code>的扩展。</li></ol><p>然后，为了编写包含中文的论文，我们需要对其进行一点<strong>小小的配置</strong>。首先，在首选项页面找到<code>LaTeX Workshop</code>的配置文件：</p><ol><li>按住<code>Ctrl+,</code>键。</li><li>搜索<code>latex tool</code>。</li><li>然后打开相对应的<code>settings.json</code>文件。</li></ol><p>然后，添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">禁止自动编译</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;:</span> <span class="string">&quot;never&quot;</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span> <span class="string">编译后自动清理无用文件</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;:</span> <span class="string">&quot;onBuilt&quot;</span><span class="string">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.subfolder.enabled&quot;:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span> <span class="string">自动使用上一次的编译器</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipe.default&quot;:</span> <span class="string">&quot;lastUsed&quot;</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span> <span class="string">根据使用的包自动补全</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;:</span> <span class="literal">true</span><span class="string">,</span></span><br></pre></td></tr></table></figure><p>在<code>latex-workshop.latex.tools</code>中，添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;:</span> <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;env&quot;:</span> &#123;&#125;</span><br><span class="line">&#125;<span class="string">,</span></span><br></pre></td></tr></table></figure><p>在<code>latex-workshop.latex.recipes</code>中，添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tools&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;<span class="string">,</span> </span><br></pre></td></tr></table></figure><p>中文相关的论文，通常需要四次编译——<code>xelatex</code>一次、<code>bibtex</code>一次、<code>xelatex</code>两次——其实我也没仔细研究过是否这样，我实在没有这个时间。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="引用命令未找到"><a href="#引用命令未找到" class="headerlink" title="引用命令未找到"></a>引用命令未找到</h2><p>您可能遇见这样的报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I found no \citation commands---while reading file myFile.aux</span><br><span class="line">I found no \bibdata command---while reading file myFile.aux</span><br><span class="line">I found no \bibstyle command---while reading file myFile.aux</span><br></pre></td></tr></table></figure><p>解决办法是，在主<code>.tex</code>文件中引入：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[backend=bibtex]&#123;biblatex&#125;</span><br></pre></td></tr></table></figure><p>原因是，<code>MiKTeX</code>貌似会采用<code>biber</code>来处理引用，会导致一些问题，将依赖改为<code>bibtex</code>即可。</p><h2 id="引用出错"><a href="#引用出错" class="headerlink" title="引用出错"></a>引用出错</h2><p>这个可能伴随着上一个问题的解决而出现，报错大概是这样子的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">! Package biblatex Error: &#x27;\bibliographystyle&#x27; invalid.</span><br><span class="line">l.260 \bibliographystyle&#123;unsrt&#125; Use the package option &#x27;style&#x27; instead. I&#x27;m ignoring this command. ! LaTeX Error: Can be used only in preamble.</span><br></pre></td></tr></table></figure><p>解决办法是，在序言部分（即<code>\begin document</code>之前），进行引用的处理，比如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\addbibresource</span>&#123;document.bib&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>原因是，<code>biber</code>和<code>bibtex</code>所采用的函数不同。</p><h2 id="注意下划线的转义"><a href="#注意下划线的转义" class="headerlink" title="注意下划线的转义"></a>注意下划线的转义</h2><p>有时，这个报错会变得非常难以理解：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Missing $ inserted</span><br></pre></td></tr></table></figure><p>类似这样的报错。</p><p>解决办法是，仔细查找文章中的<strong>非公式部分</strong>，是否出现了<strong>未转义的下划线</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\par</span>&#123;</span><br><span class="line">This is a test<span class="built_in">_</span>sentence. <span class="comment">% 这是错的</span></span><br><span class="line">This is a test<span class="keyword">\_</span>sentence. <span class="comment">% 这是对的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【乐理】和声学的一点说明</title>
      <link href="/2024/12/10/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%A3%B0%E5%AD%A6%E7%9A%84%E4%B8%80%E7%82%B9%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/12/10/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%A3%B0%E5%AD%A6%E7%9A%84%E4%B8%80%E7%82%B9%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>建议您阅读：桑桐著《和声学教程》以及斯波索宾的《和声学教程》，本文只做一点解释和补充用。</p><p>和声学需要大量的练习。</p><h1 id="和声学的基本规则：四部和声"><a href="#和声学的基本规则：四部和声" class="headerlink" title="和声学的基本规则：四部和声"></a>和声学的基本规则：四部和声</h1><p>三和弦在歌曲中，通常不用三个声部来呈现，而是用四个，这是一个传统。四个声部分别是：</p><ol><li>高音部</li><li>中音部</li><li>次中音部</li><li>低音部</li></ol><p>在合唱中，这四个声部也被称作女高音、女低音、男高音、男低音。在声乐中，女生天生比男生要高唱一个八度，故此得名。这种用四个声部来陈述的和声，就叫做<strong>四部和声</strong>。</p><p>既然用四个声部来陈述和声——或者说演奏和弦——那么就必然有一个音要重复。我们<strong>通常</strong>重复根音，其次是三音。因为根音声明着这个和弦的属性，是和弦的基础。</p><h1 id="和弦进行的规则"><a href="#和弦进行的规则" class="headerlink" title="和弦进行的规则"></a>和弦进行的规则</h1><blockquote><p>如果您不懂某些规则，建议用乐器演奏出来。所有规则都是通常情况下的规则，是从实践中总结得到的规则。然而，不同的音乐风格往往有不同的规则，这些规则有时是可以打破的。</p></blockquote><h2 id="平稳进行规则"><a href="#平稳进行规则" class="headerlink" title="平稳进行规则"></a>平稳进行规则</h2><p>如果相邻的两个和弦之间有共同音，那么<strong>最好</strong>这些共同音保持不变，由<strong>相同的声部</strong>来演奏，比如从C和弦的1135转到A和弦的6613，我们完全可以将E和弦排列为6136，只移动低音部和高音部。这种尽可能少得移动声部的规则，就称作<strong>平稳进行规则</strong>。</p><p>引自斯波索宾《和声学教程》：</p><blockquote><p>单独一个声部的进行可以是<strong>平稳</strong>的，也可以是<strong>跳进</strong>的。声部做<strong>一度</strong>、<strong>二度</strong>（级进）或三度进行叫做<strong>平稳进行</strong>。……是在初学和声时必须遵守的规则。……在最初阶段的学习中，在各个声部中作跳进是不允许的，但低音部是例外。</p></blockquote><h2 id="原位三和弦之间的连接"><a href="#原位三和弦之间的连接" class="headerlink" title="原位三和弦之间的连接"></a>原位三和弦之间的连接</h2><p>原位和弦之间的连接法有两种：<strong>和声连接法</strong>和<strong>旋律连接法</strong>。其中，前者是指共同音保持在同一声部中的连接，后者是没有一个声部保持不变的连接。如果用旋律连接法，那么也要保证：让各声部移动的距离尽可能小。</p><h2 id="应避免：四部同向"><a href="#应避免：四部同向" class="headerlink" title="应避免：四部同向"></a>应避免：四部同向</h2><p>如果和弦连接过程中，四个声部向同一个方向移动——都上行或都下行——就叫做<strong>四部同向</strong>。因为，这时所有的声部都失去了独立性，缺少听感上的悦耳性。</p><h2 id="应避免：平行五八度"><a href="#应避免：平行五八度" class="headerlink" title="应避免：平行五八度"></a>应避免：平行五八度</h2><p>我们在上一篇博文中讲到，纯五度和纯八度是非常协和的。在和声中，如果前一个和弦中，两个声部为纯五度或者纯八度，如果再下一个和弦中，这两个声部依然是纯五度或者纯八度，这种情况就叫做<strong>平行五八度</strong>。注意，五度到八度、八度到五度是不属于这种状况的。</p><p>这种运动，会导致音响的空洞——因为过度协和，导致人耳很难分辨出两个声部的变化，这样就失去的声部的独立性。不过，有时作曲家就要追求这种模棱两可的状态，会故意使用平行五八度。</p><p>值得一提的一种打破这种规则的例子便是金属乐，金属乐中大量使用强力和弦&#x2F;五和弦，这种和弦是一个根音和其上纯五度音组成的。这种和弦的目的就是为了让和弦听起来没有明显的色彩。比如Metallica著名的金属乐<a href="https://www.youtube.com/watch?v=E0ozmU9cJDg">Master of Puppets</a>就用到了大量平行五度的进行，您可以听听看。</p><h2 id="应避免：上方三声部超八度"><a href="#应避免：上方三声部超八度" class="headerlink" title="应避免：上方三声部超八度"></a>应避免：上方三声部超八度</h2><p>这是指，相邻两个声部之间的距离超过了八度，这是极其不好的排列方法。</p><h2 id="应避免：声部超越"><a href="#应避免：声部超越" class="headerlink" title="应避免：声部超越"></a>应避免：声部超越</h2><p>若有两个连续的、包含至少两个独立声部的和音，当后和音中较低的声部的音比前和音中较高的声部的音要高时，或者当后和音中较高的声部的音比前和音中较低的声部的音要低时，称之为声部超越。</p><p>个人感觉，这种会造成听感的突兀性。</p><h2 id="应避免：声部交叉"><a href="#应避免：声部交叉" class="headerlink" title="应避免：声部交叉"></a>应避免：声部交叉</h2><p>在常见的四部和声写作中，往往G谱表和F谱表内会各放置两个声部，此时，如果F谱表内的最高音，超过了G谱表内的某一音，则代表声部交叉。</p><p>这是一种不满足四部和声假设的写法。</p><h2 id="应避免：功能切分"><a href="#应避免：功能切分" class="headerlink" title="应避免：功能切分"></a>应避免：功能切分</h2><ol><li>弱拍功能时值不可比强拍长。</li><li>弱拍弱位不可延续到强拍强位。</li></ol><h2 id="应做到：上密下疏"><a href="#应做到：上密下疏" class="headerlink" title="应做到：上密下疏"></a>应做到：上密下疏</h2><p>人的耳朵有这样一个特点：对于高音更敏感，对于低音则相对难以分辨一些。所以在做和声的时候，要尽量让<strong>高音声部丰富，低音声部单调</strong>。这个规则可以总结为：上密下疏。</p><h1 id="旋律的写作"><a href="#旋律的写作" class="headerlink" title="旋律的写作"></a>旋律的写作</h1><p>大概几个要点：</p><ol><li>旋律音尽量不要与低音一致。</li><li>引入合适的和弦外音。</li><li>丰富的节奏。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【乐理】基础的乐理教程</title>
      <link href="/2024/12/07/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B9%90%E7%90%86%E6%95%99%E7%A8%8B/"/>
      <url>/2024/12/07/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B9%90%E7%90%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>对一直以来学到的乐理知识进行一个总结，写在这里。这些知识对于一个乐器初学者来说，应该足够用了。这篇文章的前面更偏向于从数理角度理解音乐。您需要有基本的音程知识，也需要明白音符的唱名、音名等知识。</p><p>实际上，乐理是一个颇为自由的东西，只要听起来足够悦耳，有时并不需要遵循规则。</p><h1 id="何为声音？"><a href="#何为声音？" class="headerlink" title="何为声音？"></a>何为声音？</h1><p>声音是<strong>振动</strong>产生的声波，通过介质（气体、固体、液体）传播并能被人或动物听觉器官所感知的波动现象。在地球上，空气中有很多气体、液体、固体粒子，当发声体振动时，这种振动通过这些粒子传播，传到人的耳朵里。人的耳朵里有个结构叫做耳蜗，它能将振动带来的物理机械信号，转化为电信号。这就完成了一次对于声音的感知。</p><p>从理论上来研究声音，其实和研究振动是一样的。根据中学物理知识，我们知道，振动会产生波，而波具有这样几个性质：振幅、频率、相位。其中，相位暂时并不重要。振幅和频率更重要一些，它们分别影响声音的大小和音高。</p><h1 id="和谐：整数比"><a href="#和谐：整数比" class="headerlink" title="和谐：整数比"></a>和谐：整数比</h1><p>和谐就是听起来悦耳的感觉。和谐与不和谐很大程度上是文化建构的产物——参见<a href="https://www.nature.com/articles/nature18635">Indifference to dissonance in native Amazonians reveals cultural variation in music perception</a>。为什么会产生和谐与不和谐的状况？我们以正弦波举例。</p><p>根据听感，如果<strong>频率之比成整数倍</strong>，我们认为是最和谐的。比如1：2、1：3这样的倍率。在这种情况下，长周期波的每一个周期内，短周期波都完成了一次振动，二者的变化是完全一致的。我们将1：2比例关系的音之间的关系，称作<strong>八度关系</strong>，写作一样的音名。因为这两个音听起来非常的相似——波的重叠性足够高。</p><h1 id="五声音阶、大调音阶与十二平均律的创造"><a href="#五声音阶、大调音阶与十二平均律的创造" class="headerlink" title="五声音阶、大调音阶与十二平均律的创造"></a>五声音阶、大调音阶与十二平均律的创造</h1><p>我们弹奏音乐，必然是不同频率音的排列组合，只有一个音，太枯燥了。我们怎么获得别的音呢？比如说我们设定一个标准音——220Hz的A音来举例子，其上的440Hz与880Hz的音都是A音，因为它们之间的比值是1：2的关系。那么我们可不可以把两个A音之间的频率选择几个和谐的，来制造音乐呢？</p><p>220Hz的音和660Hz的音是协和的，那么我们可以把660Hz的音除以二，这样就得到了一个330Hz的音。同样，我们也可以将220Hz除以三得到的音乘以2，获得另一个146.7Hz左右的音。这样我们就有了三个音——146.7Hz、220Hz、330Hz。</p><p>我们创建音的规则，就很显而易见了——乘或除以三倍，然后向中间收缩2的整数倍！那么我们可以对146.7和330Hz两个音进行类似的处理——因为再对220Hz处理，得到的音音名是一样的——146.7Hz、195.6Hz（146.7Hz除以3乘以4）、220Hz、247.5Hz（330Hz乘以3除以4）、330Hz。这几个音的音名是D3、G3、A3、B3、E4，排列紧凑一点（因为D3完全可以高一个八度）就是——GABDE——我们得到了<strong>五声音阶</strong>。这个生成过程实际上是<strong>五度相生律</strong>——我们将频率关系为2：3的两个音之间的音程称作<strong>纯五度音程</strong>。A升高五度（乘3除2）得到E，E得到B。下降五度，A得到D，D得到G，我们就有了这样五个音。实际上，最开始发明五度相生律的中国人们并不知道音名，于是将这五个音命名为<strong>宫商角徵羽</strong>。</p><p>我们向两边再进行计算——G下降五度就得到C，B上升五度得到#F音。排列紧凑一点就是GABCDE#F——我们就得到了<strong>G大调音阶</strong>。如果我们改变设定的标准音，使紧密排列后的最左边的音为C，我们的音阶就变成了CDEFGAB——<strong>C大调音阶</strong>。</p><p>后来人们觉得七个音也不够用，于是发明出了一种方式，将一个八度内的音，分成十二份——相邻两个音的频率之比为$\sqrt[12]{2}$。这个方法我们叫做<strong>十二平均律</strong>，这个方法不仅能包含现有的五声音阶、大调音阶体系，也可以创建新的音。人们发现，在这十二个音中，现存的音之间，要么有且只有一个音，要么之间没有音。这样，我们就引入了<strong>升降号</strong>，比如C和D之间的音，就叫做升C或者降D。我们将相邻两个音之间的关系称作<strong>半音关系</strong>，两个半音就是<strong>全音关系</strong>，两个音之间的距离称作<strong>音程</strong>。这样，我们之前的大调音阶之间的关系就显而易见了——<strong>全全半全全全半</strong>。</p><h1 id="音程的一点内容"><a href="#音程的一点内容" class="headerlink" title="音程的一点内容"></a>音程的一点内容</h1><p>不同音之间的关系，参见：<a href="https://zh.wikipedia.org/zh-cn/%E9%9F%B3%E7%A8%8B">维基百科：音程</a>。</p><h2 id="度数关系"><a href="#度数关系" class="headerlink" title="度数关系"></a>度数关系</h2><p>对于三度、六度、七度关系而言：我们有减三度-小三度-大三度-增三度。相邻的两个音程关系相差半音。</p><p>对于四度、五度来说：我们有减五度-纯五度-增五度。相邻的两个音程关系相差半音。</p><p>而一度只有：纯一度-增一度。相邻的两个音程关系相差半音。</p><h2 id="和谐关系"><a href="#和谐关系" class="headerlink" title="和谐关系"></a>和谐关系</h2><p>音程的和谐关系，被总结如下：</p><ol><li>完全协和：纯一度、纯八度、纯四度、纯五度。</li><li>不完全协和：大三度、小三度、大六度、小六度。</li><li>不协和：大二度、小二度、大七度、小七度，增四度或减五度。</li></ol><p>这个没有公认的系统解释。我倾向于这样理解：如果两个音频率之比的最简形式，两个数字的最小公倍数越小，越和谐。比如纯五度，就是1：2，最小公倍数是2，这表明它们的波形范式重合起来更有规律。而大二度则是10：9，最小公倍数是90，波形重合起来更加杂乱一些。</p><h2 id="大调音阶的度数关系"><a href="#大调音阶的度数关系" class="headerlink" title="大调音阶的度数关系"></a>大调音阶的度数关系</h2><p>CDEFGAB中，以C为基准：</p><ol><li>C-D：大二度</li><li>C-E：大三度</li><li>C-F：纯四度</li><li>C-G：纯五度</li><li>C-A：大六度</li><li>C-B：大七度</li></ol><h1 id="调式"><a href="#调式" class="headerlink" title="调式"></a>调式</h1><p>我们假设有七个音：CDEFGAB，我们不一定从C开始，我们有DEFGABC、EFGABCD等共七种排列方法，不同的排列方法，我们叫做不同的调式。即：</p><ol><li>CDEFGAB-伊奥尼亚调式(Ionian)</li><li>DEFGABC-多利亚调式(Dorian)</li><li>EFGABCD-弗里几亚调式(Phrygian)</li><li>FGABCDE-利底亚调式(Lydian)</li><li>GABCDEF-混合利底亚调式(Mixo-lydian)</li><li>ABCDEFG-艾奥里亚调式(Aeolian)</li><li>BCDEFGA-洛克里亚调式(Locrian)</li></ol><p>每个调式，相邻音的全&#x2F;半关系是一定的，只要给定标准音和调式，就可以推导出对应的七个音来。这些调式来源于中古时期的天主教会&#x2F;东正教会的圣咏。除了上述提到的调式，也有一些其他调式，比如拜占庭调式等等。其中，艾奥里亚调式和伊奥尼亚调式更加常用，现在可以近似等同于自然小调和大调。</p><p>C大调和A小调的音阶构成音是一样的，所以这两个调之间的关系叫做<strong>关系大小调</strong>，因为它们之间的关系最为密切。此外C大调和C小调的起始音（主音）是一样的，所以这两个调之间的关系叫做<strong>平行大小调</strong>，也叫做<strong>同名大小调</strong>。</p><h1 id="五度圈"><a href="#五度圈" class="headerlink" title="五度圈"></a>五度圈</h1><p>五度很神奇，也很有用。这样，我们先总结出一个结构，方便后续的使用。我们从C音开始，按照五度的关系向前推导，可以得到这样一个链——C-G-D-A-E-B-升F&#x2F;降G-降D-降A-降E-降B-F，随后我们发现F的高五度又回到了C——我们得到了一个圈，圈中每相邻两个音互为五度关系，这个圈就叫做<strong>五度圈</strong>。</p><p>我们可以通过五度圈判断每个调式的音阶，参见<a href="https://zhuanlan.zhihu.com/p/146231353">《练出来的乐理》：五度圈和12个大调音阶</a>。这个是一个记忆性的东西。</p><p>此外，每个大调都有自己的关系小调，所以五度圈的详细形式是：<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%94%E5%BA%A6%E5%9C%88">维基百科：五度圈</a>。</p><h1 id="速度、节拍与乐谱"><a href="#速度、节拍与乐谱" class="headerlink" title="速度、节拍与乐谱"></a>速度、节拍与乐谱</h1><p>我们现在有了什么？我们有了十二个音！我们可以用这十二个音写曲子了！不过，如果胡乱写，前面快，后面慢，可是够难听的。我们需要一种平和的、节奏均匀而平缓的方式来写歌。</p><p>我们会很自然地想到——将一分钟平均分成若干份，每份的秒数是一样的，我们可以在每份的开始弹奏一个音，这样就能确保我们不会忽快忽慢！我们可以用打击乐器，在每份开始的时刻打击一下，提醒乐手去演奏。不过，将一分钟进行分割，有无数种分割方式——可以一秒一份，也可以三十秒一份，我们需要一种量度来量化这种分割方式。这就是<strong>BPM</strong>——Beats Per Minute——每分钟的拍子数的来源。每分钟如果拍60次，那么也就是说BPM&#x3D;60，就相当于将一分钟平均分成60份，每份一秒。BPM越大，表明歌曲也就越快。</p><p>如果在每份的开始演奏，也很单调乏味——没有节奏的变化，就如同僧人念经一样，令人昏昏欲睡。于是有人说，我们可以将每份时间再分成若干份嘛，小份的开始可以演奏也可以不演奏，这样就有了节奏的变化！比如当BPM为60时，我们可以把每一小份都平均分成四份，前面，四小份的前两份开始可以演奏，后两份不演奏，后面反过来，我们就有了节奏的变化。这样我们就发明了<strong>四分音符</strong>——将一个大份分为四个小份，同理，我们也有八分音符和十六分音符，以此类推。为了方便，我们按照$2^n$的形式来分割每个大份。</p><p>我们这样记录，在纸上大份之间用竖线分隔开，两个竖线之间就是大份所代表的时间，我们把每个大份分成若干个小份，每个小份用音名来指示要演奏的音。这样，不仅有节奏的变化，也可以创作、保存我们的歌曲了。这便是<strong>乐谱</strong>的发明。竖线之间，我们叫做<strong>小节</strong>。</p><p>我们可以用如下的方式来定义我们的节奏，比如4&#x2F;4、3&#x2F;4等等，分母是2的幂次，代表我们如何分割我们的小份，分子则表示一个大份里有多少个小份。不同BPM下，四分音符、八分音符的演奏时长是不同的，而在同一BPM下，则是相同的，这给了我们定义节奏型的判据。同样的BPM，全音符占据四个beat，二分音符占据两个beat，四分音符占据一个beat，以此类推。</p><p>在简谱上，一个音符如果写作一个数字的形式，那么就是四分音符，如果下面加一条线，便是八分音符。如果一个音符后面跟着三个连音线（横杠），便是全音符。此外，如果音符后面跟着一个点，我们叫做<strong>附点</strong>，那么这个音符就要延长到原来的1.5倍。至于如何更加精确的认识乐谱（简谱、五线谱），网上的教程已经够多了，请您自行查找。</p><h1 id="音色"><a href="#音色" class="headerlink" title="音色"></a>音色</h1><p>有了音有了节奏，我们该演奏音乐了！我们该怎么去演奏呢？我们需要一些乐器。我们知道，不同乐器发出的声音，听起来是不一样的，为什么？因为它们的<strong>波形形状不同</strong>。不同乐器所发出的波，是<strong>不同频率的波</strong>的总和。</p><p><strong>通常</strong>，我们将频率最低的波所代表的音称作基音，其他音称作泛音。基音决定听到的音高，泛音决定听到的音色。而他们不同的波形、不同的振幅导致它们复合起来形成的波形不同。</p><h1 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h1><blockquote><p>强烈建议您听一听各种和弦的色彩，体会协和音程&#x2F;不协和音程数量对和弦色彩的影响。</p></blockquote><p>我们现在可以演奏简单的歌曲了——我们有了音有了节奏！不过，每次只演奏一个音，又很单调。我们可不可以同时演奏多个声音呢？这就引出了和弦的概念。</p><p>按照规律，组合在一起的两个以上不同音高的音，就是<strong>和弦</strong>。组合在一起的两个以上不同音高的音，叫做<strong>和声</strong>。</p><p>和弦有这样常见的几种：</p><h2 id="三和弦"><a href="#三和弦" class="headerlink" title="三和弦"></a>三和弦</h2><p>一个音和其上三度、上五度的音（也叫做三度音和五度音）组成的和弦，就叫做三和弦。常见的三和弦：</p><ol><li>大三+纯五&#x3D;大三和弦（major，记法：CM、DM）</li><li>小三+纯五&#x3D;小三和弦（minor，记法：Cm、Dm）</li><li>大三+增五&#x3D;增三和弦（augmented，记法：Caug、Daug）</li><li>小三+减五&#x3D;减三和弦（diminished，记法：Cdim、Ddim）</li></ol><p>如果我们用C大调的CDEFGAB七个音组成三和弦，那么我们会得到：CM、Dm、Em、FM、GM、Am、Bdim七个和弦。</p><p>此外，您可能会问，小三+增五度是什么和弦？大三+减五度是什么和弦？这就涉及和弦的另一个定义：<strong>以三度关系堆叠起来的音的组合</strong>。小三+增五度，并不是三度关系的堆叠。</p><h2 id="七和弦"><a href="#七和弦" class="headerlink" title="七和弦"></a>七和弦</h2><p>按照三度关系继续堆叠，我们可以加一个七度音，这种和弦就叫做七和弦。常见的七和弦：</p><ol><li>大三和弦+小七度&#x3D;属七和弦&#x2F;大小七和弦（大加小，即为大小，记法：C7、CMm7）</li><li>大三和弦+大七度&#x3D;大七和弦（大大七和弦，省略一个大字，记法：CM7）</li><li>小三和弦+小七度&#x3D;小七和弦（小小七和弦，省略一个小字，记法：Cm7）</li><li>小三和弦+大七度&#x3D;小大七和弦（小加大，即为小大，记法：CmM7）</li><li>减三和弦+小七度&#x3D;半减七和弦（减得没有减七那么多，即为半减，记法：Cm7-5）</li><li>减三和弦+减七度&#x3D;减七和弦（记法：Cdim7）</li><li>增三和弦+小七度&#x3D;增七和弦（记法：Caug7）</li><li>增三和弦+大七度&#x3D;增大七和弦（记法：CaugM7）</li></ol><h2 id="九和弦、十一和弦、……"><a href="#九和弦、十一和弦、……" class="headerlink" title="九和弦、十一和弦、……"></a>九和弦、十一和弦、……</h2><p>继续按照三度关系累加音，就得到了其它的和弦……</p><h2 id="和弦进行"><a href="#和弦进行" class="headerlink" title="和弦进行"></a>和弦进行</h2><p>当然，我们的歌曲是不同和弦的排列组合——这样才能让听感多样化。和弦随着时间进行的改变，叫做<strong>和弦进行</strong>，是歌曲的骨架。每个和弦有不同的色彩。</p><h2 id="和弦级数"><a href="#和弦级数" class="headerlink" title="和弦级数"></a>和弦级数</h2><p>在C大调里，以C为根音（和弦最低音）开始的和弦就叫做一级和弦，以D为根音就是二级和弦，以此类推。注意，最低音的判断，要在三个音成三度堆叠情况下进行，比如EGC就不是三级和弦，因为EGC不满足三度堆叠，要排列成CEG再判断，这是一个一级和弦。</p><p>实际上，EGC这种排列，叫做<strong>C和弦的第一转位</strong>。什么是转位？转位就是<strong>保持构成音不变，变动音的排列顺序</strong>。对于三和弦来说，如果三音为最低音，那么就是第一转位，如果五音是最低音，就称作第二转位。转位可以保证听感的多样性。</p><h1 id="和弦功能：主、属、下属"><a href="#和弦功能：主、属、下属" class="headerlink" title="和弦功能：主、属、下属"></a>和弦功能：主、属、下属</h1><blockquote><p>推荐观看：<a href="https://www.bilibili.com/video/BV1Ef4y1U7Jg/">学个毛和声【1】基本功能</a>。</p></blockquote><h2 id="基础解释"><a href="#基础解释" class="headerlink" title="基础解释"></a>基础解释</h2><p>不论是大调音阶还是小调音阶，一级、四级和五级和弦都是最重要的。有了这三个和弦，便可以写一些基础的歌曲。其实，现在很多流行乐都是只有一级和五级和弦的。</p><p>每个和弦都有着自己的功能，在不同调内的功能也不尽相同。比如G和弦，在C大调里会制造张力，而在G大调里，就会带来张力的解决。研究和弦功能是很有必要的。其中，最为重要的三个和弦，便是一级四级五级和弦。</p><p>一级、四级和五级和弦，又叫做主和弦(德语：Tonika，简写为T&#x2F;t)、下属和弦(德语：Subdominante，简写为S&#x2F;s)和属和弦(德语：Dominante，简写为D)。</p><p>主和弦往往带来稳定、舒适、没有张力(tension)的感觉，因为和其名称一样，主和弦主导歌曲的调性，是原点。主和弦是一级的三和弦，在大调里是大三和弦，在小调里则是小三和弦。您可以通过音阶和三和弦的构建方式推导出来。如果主和弦是小三和弦，就记作t；是大三和弦，记作T。通常一个歌曲的开始结尾和弦，都为主和弦。</p><p>属和弦往往带来张力、紧绷的感觉，因为属和弦具有强烈的转向主和弦的倾向。如果主和弦跟在属和弦后面，我们就把这种组合叫做<strong>解决</strong>——张力的消失。属和弦是五级的大三和弦，不论在大小调里，其都为大三和弦。为什么叫做属和弦？因为属和弦只可以通过主和弦来解决，是从属于该调性的，如果独立出去，则没法解决张力。</p><p>为什么属和弦能创造张力？为什么大小调中的属和弦都是大三和弦？这里我们要提一点——小调中的五级小和弦不如大调中的属和弦能够创造足够的张力。如果您查看大调音阶中的属和弦，您会发现，<strong>属和弦内部的三度音向上提高半音就是主音</strong>，这种强烈的、前往主音的欲望，造成了这种张力。在小调中，如果用五级的小三和弦，三度音向上，则需要提高一个音才可以到达主音，这种前往主音的欲望不够强烈。为了制造足够的张力，我们仍需要用大三和弦。</p><p>有了张力和稳定，我们就已经可以写出最基本的歌曲了，只需要按照T-D-T-D-…的结构写下去即可。</p><p>属和弦是五度——主音的上五度音为根音构造的和弦，下属和弦是主音的下五度音为根音构造的和弦。下属的紧张性位于主和弦和属和弦之间，也有一定的回到主和弦的倾向。此外，下属的稍弱的紧张性，如果后面接着属和弦，则会造成一种张力的递进。但是如果属和弦后面跟着下属和弦，则会造成解决的迟滞性，听感不够舒适。</p><h2 id="功能和弦组"><a href="#功能和弦组" class="headerlink" title="功能和弦组"></a>功能和弦组</h2><p>这样，我们知道了一级、四级和五级的功能，那么二三六七级和弦，有着怎么样的功能呢？实际上，这四个三和弦叫做<strong>副三和弦</strong>。二六级和弦也具有下属和弦的性质，三七级和弦也有着属和弦的性质，除此之外，三六级和弦也具有一定主功能的性质。这样，我们将七级和弦分成了<strong>主功能和弦组</strong>、<strong>属功能和弦组</strong>和<strong>下属功能和弦组</strong>。为什么？实际上，这和<strong>和弦中的共同音</strong>有关，在C大调中，属和弦是572，而三级和弦是357，二者又两个音是一样的，所以听起来非常的相似，同理，三级和弦是357，一级和弦是135，又有两个音相似。相似的音越多，听感越相近，这是显而易见的。</p><h2 id="对属七和弦的解释"><a href="#对属七和弦的解释" class="headerlink" title="对属七和弦的解释"></a>对属七和弦的解释</h2><p>现在您可能知道——属和弦是用来创造张力的，那么大小七和弦为什么叫做属七和弦呢？</p><p>如果大小七和弦要被叫做属七和弦，必须满足两个条件，即<strong>该大小七和弦是建立在属音上的大小七和弦</strong>，且<strong>该和弦必须解决到主和弦</strong>。如果您仔细查看属七和弦，您会发现，这个和弦的三度音和七度音之间是一个减音程，这令该和弦具有比属三和弦更强的张力。</p><h1 id="音级名称"><a href="#音级名称" class="headerlink" title="音级名称"></a>音级名称</h1><p>在C大调内，一到七级的音分别叫做：</p><ol><li>主音-主导调式的音。</li><li>上主音-主音之上的音。</li><li>中音-主音属音之间的音。</li><li>下属音-主音的低五度音。</li><li>属音-主音的上五度音。</li><li>下中音-主音下属音之间的音。</li><li>导音-导向主音的音。</li></ol><h1 id="更多的小调音阶"><a href="#更多的小调音阶" class="headerlink" title="更多的小调音阶"></a>更多的小调音阶</h1><p>我们知道，ABCDEFG是一个小调音阶，其实这个音阶叫做<strong>自然小调音阶</strong>，您可以理解为，这七个音是自然而然产生的——正如我们之前所运算的那样。不过我们也知道，自然小调音阶中的五级三和弦没法产生足够的张力，我们需要将ABCDEFG改编为ABCDEF升G，才可以让五级和弦有足够的张力。这样修改，我们就得到了<strong>和声小调音阶</strong>。不过，ABCDEF#G中，F到#G的距离过大，是一个全音+半音的音程，在演奏过程中，这个音程有时会导致旋律的尖锐改变。如果我们将F变为#F，就得到了ABCDE#F#G，这个音阶叫做<strong>旋律小调音阶</strong>。</p><p>在小调歌曲编写时，这三种可以同时使用，比如主体用自然小调编写，当需要张力时，就采用和声小调音阶，有时可以使用旋律小调做特殊的色彩处理。</p><h1 id="两个常用终止式"><a href="#两个常用终止式" class="headerlink" title="两个常用终止式"></a>两个常用终止式</h1><p>歌曲的写作很大程度上是张力的创造与解决。通过属和弦创造张力，通过主和弦解决张力，基本上是一个常用的规律。我们也知道，张力的解决会带来一种完成了、结束了的感觉。这种感觉可以作为乐句、乐段、歌曲的结束。有这样几种结束的定式——我们称作<strong>终止式</strong>。以大调为例：</p><ol><li>正格完全终止：常用于歌曲的结尾，常指S-D-T或D-T。</li><li>半终止：常用于乐句的结尾，而非歌曲的结尾，常指末尾为D的终止。</li><li>变格终止：常指S-T。</li></ol><h1 id="转调与离调"><a href="#转调与离调" class="headerlink" title="转调与离调"></a>转调与离调</h1><p>通常情况下，转调、离调所追求的根本是：<strong>平稳</strong>。</p><h2 id="曲内转调"><a href="#曲内转调" class="headerlink" title="曲内转调"></a>曲内转调</h2><p>您现在已经知道了，不论是大调还是小调，其中的属和弦都是大和弦。那么这就可以成为一种<strong>曲内转调</strong>的手法，将歌曲从大调转到<strong>同名小调上</strong>，比如大调进行-属和弦-小调主和弦-小调进行，或者小调进行-属和弦-大调主和弦-大调进行。因为属和弦后面接着主和弦就相当于一个<strong>终止</strong>，是当前张力的解决。</p><p>不过，转调的时候要记住这样一个特点：<strong>五度圈内越相近的调性，彼此转起来更容易</strong>。这是因为，调式不变，五度圈内的调性，相邻则代表共同的音更多一些，这符合我们的平稳原则。比如从C转到G——都是大调——我们完全可以让C大调进行到属和弦，然后将属和弦看作G大调的主和弦，随后进行G大调的进行。</p><p>此外，也有一种转调的手法，比如连续的降四度进行：CM-FM-降BM-…，这样也可以较为流畅的转移到别的调上。您也可以尝试连续升五度、升四度、……只要听感足够愉快，转调就是足够成功的。不过常见的进行，仍然是连续升五度或连续降四度，因为这满足五度圈的听感关系——足够自然。</p><h2 id="曲内离调"><a href="#曲内离调" class="headerlink" title="曲内离调"></a>曲内离调</h2><p>离调和转调不同，离调是指在音乐进行中，插入一段不属于当前调性的和弦进行。比如I-II-V-I进行，我们完全可以将II和弦看作某个调的一级和弦，然后再前面添加这个调的五级和弦——I-VI-II-V-I。</p><h2 id="和弦替代-Chord-Substitution"><a href="#和弦替代-Chord-Substitution" class="headerlink" title="和弦替代(Chord Substitution)"></a>和弦替代(Chord Substitution)</h2><p>我们知道，可以用属和弦桥接同名大小调之间的转换，其实也有另一种更为激进的方法——我们可以将大调的任意一个和弦，替换为同名小调的对应级数的和弦。这相当于从同名小调中借过来一些和弦使用——这便是<strong>和弦替代</strong>。实际上，利用属和弦做桥接，也是一种和弦替代，只不过在同名大小调中，这个和弦是一样的。如果不用属和弦做和弦替代，听感上会更加的不协调。</p><p>此外，也可以从不同的调式上进行和弦替代，比如在伊奥尼亚调式的进行中引入多利亚调式，等等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Linux终端播放Bad Apple</title>
      <link href="/2024/01/24/%E7%94%A8Linux%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BEBad-Apple/"/>
      <url>/2024/01/24/%E7%94%A8Linux%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BEBad-Apple/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Bad Apple常常指一部影绘PV：<a href="https://www.bilibili.com/video/BV1xx411c79H">【東方】Bad Apple!! ＰＶ【影絵】</a>。在各大网站，您可以看到很多在不同设备上播放这个PV的视频，包括但不限于单片机液晶屏、国际象棋棋盘等。</p><p>本文主要讲述如何借助<code>libpng</code>、<code>ncurses</code>和<code>ffmpeg</code>，编写C语言程序，在<code>uxterm</code>上播放该视频。</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>基本思想是：我们需要将视频流转换为一张张图片，然后通过计算图片每个像素的灰度，输出白色&#x2F;黑色的色块，达到播放的效果。</p><p>首先，视频流转换为图片，可以使用<code>ffmpeg</code>工具，只需要在命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i VIDEO_NAME %04d.png</span><br></pre></td></tr></table></figure><p>这个意思是，将VIDEO_NAME这个视频流转化为一张张图片，图片是png格式，名称是一个补零四位数整数，比如<code>0001.png</code>、<code>0887.png</code>或<code>1145.png</code>。</p><p>为了查看图片的颜色属性，比如RGB、RGBA，可以使用<code>file</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 0001.png</span><br></pre></td></tr></table></figure><p>我这里输出的是RGB。</p><h1 id="图片的加载"><a href="#图片的加载" class="headerlink" title="图片的加载"></a>图片的加载</h1><h2 id="单个图片的加载"><a href="#单个图片的加载" class="headerlink" title="单个图片的加载"></a>单个图片的加载</h2><p>png图片的加载需要用到<code>libpng</code>这个库，读取的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">png_bytepp <span class="title function_">ReadPNG</span><span class="params">(<span class="type">char</span>* file_name, <span class="type">int</span>* height, <span class="type">int</span>* width)</span> &#123;</span><br><span class="line">  <span class="comment">// Read file</span></span><br><span class="line">  FILE* fp = fopen(file_name, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unable to read!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Initialize</span></span><br><span class="line">  png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  png_infop info_ptr = png_create_info_struct(png_ptr);</span><br><span class="line">  png_init_io(png_ptr, fp);</span><br><span class="line">  <span class="comment">// Read Info of a picture</span></span><br><span class="line">  png_read_png(png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, <span class="literal">NULL</span>);</span><br><span class="line">  png_bytepp row_pointers = png_get_rows(png_ptr, info_ptr);</span><br><span class="line">  <span class="comment">// Get height and width of a png picture</span></span><br><span class="line">  *height = png_get_image_height(png_ptr, info_ptr);</span><br><span class="line">  *width = png_get_image_width(png_ptr, info_ptr);</span><br><span class="line">  png_destroy_read_struct(&amp;png_ptr, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// Deinitalize</span></span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> row_pointers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的思路是这样的，首先读取png文件，接着创建读取png的相关结构体，接着读取图片，将像素输入到一个指定结构体里，获取图片的长和宽。</p><h2 id="多个图片的加载"><a href="#多个图片的加载" class="headerlink" title="多个图片的加载"></a>多个图片的加载</h2><p>首先，我们要获取图片的总数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetPNGNums</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span> &#123;</span><br><span class="line">    DIR* directory = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((directory = opendir(path)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(directory)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;d_type != DT_DIR) &#123;</span><br><span class="line">  ++total_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(directory);</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了<code>dirent</code>库，遍历文件夹，获取所有非文件夹的文件总数即可。</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>首先，要初始化窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitWindow</span><span class="params">()</span> &#123;</span><br><span class="line">  window = initscr();</span><br><span class="line">  refresh();</span><br><span class="line">  getmaxyx(window, *&amp;window_height, *&amp;window_width);</span><br><span class="line">  start_color();</span><br><span class="line">  <span class="comment">// Hide cursor</span></span><br><span class="line">  curs_set(<span class="number">0</span>);</span><br><span class="line">  refresh();</span><br><span class="line">  init_pair(<span class="number">1</span>, COLOR_WHITE, COLOR_BLACK);</span><br><span class="line">  init_pair(<span class="number">2</span>, COLOR_WHITE, COLOR_WHITE);</span><br><span class="line">  init_pair(<span class="number">3</span>, COLOR_BLACK, COLOR_BLACK);</span><br><span class="line">  wbkgd(window, COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">  attron(A_BOLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先初始化窗口，然后获取窗口的长和宽，这一步的目的是便于之后的图片缩放，接着初始化颜色色对，按照<em>编号，前景色，背景色</em>的顺序初始化即可，接着使用<code>wbkgd</code>设置窗口背景颜色。</p><p>接着，将每张图片的像素输出到窗口上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span>; h &lt; height; h+=HEIGHT_RATIO) &#123;</span><br><span class="line">     curr_col = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; width; w+=WIDTH_RATIO) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r = row_pointers[h][w*<span class="number">3</span>+<span class="number">0</span>],</span><br><span class="line">  g = row_pointers[h][w*<span class="number">3</span>+<span class="number">1</span>],</span><br><span class="line">  b = row_pointers[h][w*<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> gray = RGB2Gray(r, g, b);</span><br><span class="line"><span class="keyword">if</span>(gray &gt;= THRESHOLD) &#123;</span><br><span class="line">  attron(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">  mvaddch(curr_row, curr_col, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  attroff(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  attron(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">  mvaddch(curr_row, curr_col, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  attroff(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">curr_col++;</span><br><span class="line">     &#125;</span><br><span class="line">     curr_row++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里，<code>HEIGHT_RATIO</code>和<code>WIDTH_RATIO</code>分别代表图片长宽的缩放比例，比如<code>HEIGHT_RATIO</code>为2，就代表在图片长的遍历上，要跳过一个像素，这样图片的长就变为了原来的1&#x2F;2。</p><p>对于灰度的计算，我采用了一个近似的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">RGB2Gray</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> R, <span class="type">unsigned</span> <span class="type">int</span> G, <span class="type">unsigned</span> <span class="type">int</span> B)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (R+G+B)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着设置一个灰度阈值<code>THRESHOLD</code>，根据灰度与阈值的关系决定输出黑块&#x2F;白块即可。</p><p>在每次输出之后，需要应用<code>usleep()</code>睡眠一段时间，这个时间可以根据采样率等计算。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【密码学】各类密码小记</title>
      <link href="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要罗列一些比较冷门的、不常用的密码。</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>参考了<a href="http://www.imslr.com/thread-24995-1-1.html">指引社：20090704讲义《神秘学文字》</a>的内容。该文章内也提到了很多其它文字，但是用的人并不多，这里略去一部分。</p><h1 id="替换加密"><a href="#替换加密" class="headerlink" title="替换加密"></a>替换加密</h1><p>所谓替换加密，拿英语举例子，就是把A-Z字母替换成其它的符号。这种方法可以通过字母频率法来破解。</p><h2 id="女巫字母表"><a href="#女巫字母表" class="headerlink" title="女巫字母表"></a>女巫字母表</h2><p>女巫字母表(Witches’ alphabet)，也称作Theban字母表(Theban Alphabet)，由阿格里帕·冯·内特斯海姆(Agrippa von Nettesheim, 1486-1535)设计。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/theban.png"></p><h2 id="Malachim字母表"><a href="#Malachim字母表" class="headerlink" title="Malachim字母表"></a>Malachim字母表</h2><p>同样由阿格里帕设计。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/malachim.png"></p><h2 id="天使文字"><a href="#天使文字" class="headerlink" title="天使文字"></a>天使文字</h2><p>由阿格里帕设计。其声称该文字是上帝给予的，用来和天使交流。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/celestial.jpg"></p><h2 id="Transitus-Fluvii字母表"><a href="#Transitus-Fluvii字母表" class="headerlink" title="Transitus Fluvii字母表"></a>Transitus Fluvii字母表</h2><p>也称作渡河字母表，由阿格里帕设计，脱胎于希伯来文。和天使文字、Malachim文字类似。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/fluvii.png"></p><h2 id="爱诺克文字"><a href="#爱诺克文字" class="headerlink" title="爱诺克文字"></a>爱诺克文字</h2><p>据信，该文字由Edward Kelly从“天使那里学来”。广泛用于现由金色黎明组织传承的以诺魔法体系中：</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/ainuoke.png"></p><h2 id="苏州码"><a href="#苏州码" class="headerlink" title="苏州码"></a>苏州码</h2><p>苏州码用于对数字的加密，脱胎于算筹：</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/soochow.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】计算机网络相关知识</title>
      <link href="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>三要素：语法(数据格式)、语义(控制信息)、时序(事件顺序)</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>频分多路复用(FDM): 各用户占据不同频率的带宽发送数据。</p><p>时分多路复用(TDM): 将时间分片，周期性为不同用户发送数据。</p><p>波分多路复用(WDM): 光的FDM。</p><p>码分多路复用(CDM): 特点如下：应用于<strong>无线网络</strong>，各用户使用相同频率带宽，利用各自码片序列编码数据。各用户编码相互正交。</p><p>CDM的步骤为：</p><ol><li>每个设备先被分配一个码片序列。</li><li>实际传输的数据中，0用-1表示，1用+1表示，将之与码片序列相乘，得到该用户的编码值。多个用户的编码值相加，传输数据。</li><li>解码时，码片序列与实际接收到的数据做内积，即可获得码片序列对应用户的信息。</li></ol><h2 id="数据交换方式与计算"><a href="#数据交换方式与计算" class="headerlink" title="数据交换方式与计算"></a>数据交换方式与计算</h2><p>电路交换：独占资源，按照“呼叫建立-通信-拆除呼叫”步骤运作。</p><p>报文交换：一次发送信息整体。采用“存储转发”方式。</p><p>分组交换：将信息拆分，分组多次发送。采用“存储转发”方式。</p><p>假设AB主机之间有唯一一条通讯链路，带宽为$R$bps，报文为$M$bits，分组大小为$L$bits，链路上有$n$个路由器(需要走$n+1$段小链路，即$n+1$跳)，则：</p><ul><li><p>报文交换耗时为$T&#x3D;\frac{(n+1)M}{R}$。</p></li><li><p>分组交换耗时为$T&#x3D;\frac{M}{R}+n\frac{L}{R}$。</p></li></ul><h2 id="几个重要参数"><a href="#几个重要参数" class="headerlink" title="几个重要参数"></a>几个重要参数</h2><ul><li>速率(数据率、数据传输速率、比特率)：常指额定速率、标称速率。</li><li>带宽：链路的最高速率。</li><li>节点处理延迟：路由器存储-转发数据包所消耗的时间。</li><li>排队延迟：由于数据包过多，路由器没法一次性将所有数据包传输出去。等待传输链路可用的时间称作排队延迟。</li><li>传输延迟与传播延迟：传输延迟为数据包长度除以链路带宽；传播延迟为链路长度除以信号传播速度。</li><li>流量强度：设链路带宽为$R$，分组长度为$L$，平均分组到达速率为$a$，则流量强度为$\frac{La}{R}$。</li><li>时延带宽积：传播延迟和带宽之积。</li><li>丢包率：丢失的数据包个数占已发送的数据包个数的比例。</li><li>吞吐量：整条链路能够达到的最大带宽，对于一条多段链路来说，其吞吐量为其各段链路带宽的最小值，这段链路也被称为瓶颈链路。</li></ul><h2 id="OSI与TCP参考模型"><a href="#OSI与TCP参考模型" class="headerlink" title="OSI与TCP参考模型"></a>OSI与TCP参考模型</h2><p>OSI参考模型有七层：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><p>前四层为端到端层，即他们不考虑底层的逻辑，建立主机-目标机之间的传输抽象。</p><p>TCP参考模型中，删去了表示层和会话层。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层通过<strong>socket</strong>发送&#x2F;接收消息，每个进程通过“IP+端口号”方式标识。</p><h2 id="HTTP协议的计算"><a href="#HTTP协议的计算" class="headerlink" title="HTTP协议的计算"></a>HTTP协议的计算</h2><p>HTTP1.0使用非持久性连接，每个TCP连接最多允许传输一个对象。</p><p>HTTP1.1使用持久性连接，每个TCP连接允许传输多个对象。</p><p>非持久性连接：传输N个对象，则该协议需要$2+2N$个RTT，TCP连接的建立和HTTP的请求需要2个RTT，每个对象各自需要一个请求文件RTT和发送文件RTT。</p><p>非流水线的持久性连接：传输N个对象，则该协议需要$2+N$个RTT，TCP连接的建立和HTTP的请求需要2个RTT，每个对象只需要一个发送文件RTT。</p><p>流水线的持久性连接：传输N个对象，则该协议需要$3$个RTT，TCP连接的建立和HTTP的请求需要2个RTT，每个对象并行发送，只需要一个RTT。</p><h2 id="HTTP协议的消息格式"><a href="#HTTP协议的消息格式" class="headerlink" title="HTTP协议的消息格式"></a>HTTP协议的消息格式</h2><p>请求消息包括四部分：请求行、请求头部、空行和请求数据。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP.png"></p><p>响应消息包括四部分：状态行、消息报头、空行和响应正文。</p><h2 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h2><p>HTTP是无状态的，有时为了保存一些状态(登录状态等)，需要用到Cookie，其包括四个部分：</p><ul><li>HTTP响应消息的Cookie头部行。</li><li>HTTP请求消息的Cookie头部行。</li><li>保存在客户端的Cookie文件。</li><li>Web服务器端的后端数据库。</li></ul><h2 id="E-mail应用"><a href="#E-mail应用" class="headerlink" title="E-mail应用"></a>E-mail应用</h2><p>邮件服务器之间传递消息使用<strong>SMTP协议</strong>，按照“握手-传输-关闭”的方式工作，其消息包含：头部、空行、消息体三部分。通过MIME(多媒体扩展)，可以令E-mail消息支持不同的文件格式。</p><p>从服务器获取邮件可以用如下三个协议：<strong>POP协议</strong>、<strong>HTTP协议</strong>、<strong>IMAP协议</strong>。</p><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>DNS服务采用<strong>分布式层次服务器</strong>架构，使用<font color="red">UDP</font>协议。解析服务器分为：</p><ul><li>顶级域名服务器：负责解析<code>.com</code>、<code>.org</code>等顶级域名和国家顶级域名。</li><li>权威域名服务器：负责组织内部服务器的解析。</li><li>本地域名服务器：每个ISP都有一个本地域名服务器，当主机发起解析请求时，首先在本地域名服务器中查询。</li></ul><p>DNS记录常为资源记录(RR)，其为一个四元组（name, value, type, ttl），对于type：</p><ul><li>若为A，则表示value是name的主机域名。</li><li>为NS，则value表示name域权威域名服务器的主机域名。</li><li>为CNAME，则表示value为name的真实域名。</li><li>为MX，则表示value是name的对应邮件服务器。</li></ul><h2 id="文件分发速度的计算"><a href="#文件分发速度的计算" class="headerlink" title="文件分发速度的计算"></a>文件分发速度的计算</h2><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP2.png"></p><p>C&#x2F;S架构：$max(\frac{NF}{u_s},\frac{F}{min(d_i)})$</p><p>P2P架构：$max(\frac{F}{u_s},\frac{F}{min(d_i)}，\frac{NF}{u_s+\sum u_i})$</p><p>对于C&#x2F;S架构来说，这里进行了一个非常粗糙的建模，相当于一个大水管和很多小水管相连。</p><p>对于P2P架构来说，建模同样粗糙，认为上传下载是同时发生的。此时服务器必须上传一份文件副本就好，之后交给P2P网络传来传去，客户机下载需要下载N份，而默认上传速率就是$u_s+\sum u_i$。</p><h2 id="P2P索引"><a href="#P2P索引" class="headerlink" title="P2P索引"></a>P2P索引</h2><p>P2P需要和其他主机建立连接，就必须有一个服务器(tracker)记录其他服务器的信息。</p><p>如果服务器是中心化的，就是<strong>集中式索引</strong>，每个主机和该中心化的服务器建立连接。</p><p>如果服务器是完全分布式的，每个主机都存储一些信息，就是<strong>洪泛式索引</strong>。</p><p>也可以设立一些局部中心化的节点，这些局部中心化的节点之间洪泛式查询，而主机和这些节点采用中心化的查询方式，这就是<strong>层次式覆盖网络</strong>。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层负责两个主机进程间的通讯。</p><h2 id="复用和解复用"><a href="#复用和解复用" class="headerlink" title="复用和解复用"></a>复用和解复用</h2><p>复用：从多个socket获取数据，封装给网络层。</p><p>分用：收到数据包时，拆分数据包，发送给对应的socket。对于UDP协议，以二元组标识（目的IP，目的端口号）；对于TCP协议，以四元组标识（源IP，源端口号，目的IP，目的端口号）</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>“能到就到，到不了拉倒”。值得一提的是其校验和机制，将段的内容视作16位整数，相加，进位置于和的后面，按位求反即得校验值。</p><h2 id="可靠性传输原理-RDT"><a href="#可靠性传输原理-RDT" class="headerlink" title="可靠性传输原理(RDT)"></a>可靠性传输原理(RDT)</h2><p>RDT模型是抽象的建模。</p><p>RDT1.0：可靠信道上的可靠传输。压根不会发生错误。</p><p>RDT2.0：产生位翻转的传输。应用确认机制，接收方接收到消息时，先验证，然后显式发送ACK告知成功接收，否则发送NAK。</p><p>RDT2.1：重复分组的处理。添加分组序号。</p><p>RDT2.2：ACK&#x2F;NAK消息失真。舍弃NAK机制，成功就发送NAK，否则不发送消息。</p><p>RDT3.0：引入定时器机制和停等机制。</p><h2 id="GBN协议-后退N帧协议"><a href="#GBN协议-后退N帧协议" class="headerlink" title="GBN协议(后退N帧协议)"></a>GBN协议(后退N帧协议)</h2><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP3.png"></p><p>发送方和接收方各设定一个滑窗。当接收方受到消息后，会向发送方发送一个ACK(n)信号，表示n和n之前的所有数据包被正确成功接收，乱序到达的分组被丢弃，当数据包超时，则发送序列号大于等于n的所有数据包。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP4.png"></p><h2 id="SR协议-选择性重复协议"><a href="#SR协议-选择性重复协议" class="headerlink" title="SR协议(选择性重复协议)"></a>SR协议(选择性重复协议)</h2><p>GBN重传的数据包太多，SR协议优化了一些。</p><p>SR协议只重传那些没有受到ACK的分组。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP5.png"></p><p>但是，要满足$N_s+N_r\leq 2^k$，其中$N_s,N_r$为发送方、接收方窗口大小，$2^k$为序列号的最大值。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>其为一个点对点的、全双工的、面向连接的可靠传输协议。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/TCP.png"></p><p>其中，ACK(n)表示到n-1包都完全接收了，序列号为segment中第一个字节的编号。</p><h2 id="TCP超时时间的确定"><a href="#TCP超时时间的确定" class="headerlink" title="TCP超时时间的确定"></a>TCP超时时间的确定</h2><p>$$<br>TimeoutInterval &#x3D; EstimatedRTT + 4DevRTT<br>$$</p><p>$$<br>EstimatedRTT&#x3D;(1-\alpha)EstimatedRTT+\alpha\times SampleRTT<br>$$</p><p>$$<br>DevRTT&#x3D;(1-\beta)DevRTT+\beta\times |SampleRTT-EstimatedRTT|<br>$$</p><h2 id="TCP快速重传机制"><a href="#TCP快速重传机制" class="headerlink" title="TCP快速重传机制"></a>TCP快速重传机制</h2><p>如果发送方3次收到了同一数据的ACK，就断定这之后的数据全丢失了，于是重传后面的包。</p><h2 id="TCP流量控制机制"><a href="#TCP流量控制机制" class="headerlink" title="TCP流量控制机制"></a>TCP流量控制机制</h2><p>接收方在发送给发送方的数据头部，声明可用空间，从而使发送方调整发送速度。</p><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p>三次握手：</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/TCP2.png"></p><p>四次挥手：</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/TCP3.png"></p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>AIMD(加性增-乘性减)：逐渐增加传输速率，拥塞窗口每个RTT增大一个MSS(Maximum Segment Size)探测可用带宽，直到loss，发生loss时，拥塞窗口减半。</p><p>慢启动：TCP连接建立时，拥塞窗口大小为1，随后指数型增长，直到loss或者达到threshold。</p><p>拥塞避免：达到loss时，其拥塞窗口的半值会被设定为threshold，未达到threshold，按慢启动运行；当达到threshold时，线性增长。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层的核心功能为：<strong>转发</strong>和<strong>路由</strong>。</p><h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>其提供网络层的<strong>有连接服务</strong>，这种网络可以抽象成：两台主机之间搭建起了一条通讯电路。其按照“呼叫建立-通讯-呼叫拆除”的方式运行。</p><p>路径上的每一段小链路都有一个VCID(虚电路ID)，路径上的数据分组，不携带目标地址，只标识VCID。</p><h2 id="数据包网络"><a href="#数据包网络" class="headerlink" title="数据包网络"></a>数据包网络</h2><p>其提供网络层的<strong>无连接服务</strong>，每个分组携带目的地址，路由器根据分组的目的地址转发分组。</p><p>路由算法采取<strong>最长前缀匹配优先算法</strong>，根据目的地址确定链路接口。</p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>结构如下：</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/IP.png"></p><p>其中：</p><ul><li>版本号：4&#x2F;6，标识IPv4&#x2F;IPv6协议。</li><li>首部长度：标识IP数据包首部的长度，以4字节为单位。比如，如果首部长度为4，就表明头部长16字节。</li><li>总长度：标识IP数据包的总字节数。</li><li>生存时间(TTL)：IP分组在网络中最多可以经过的Hop数，路由器转发一次分组，TTL就减去一。</li><li>协议：6为TCP，17为UDP。</li><li>首部校验和：和UDP的checksum计算方法一致。</li></ul><h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><p>网络链路中存在MTU(最大传输单元)，一段大MTU链路向小MTU链路传递信息时，数据可以被分片，分片到达目的主机后，进行重组操作。</p><p>利用数据报中的<strong>总长度、标识、标志位和位偏移</strong>标识分片和相对顺序：</p><ul><li>每产生一个分组，标识位就加一。</li><li>标志位有三位，分别为Reserved、DF(Don’t fragment)和MF(More Fragment)，DF为1表示未分片，为0表示分片了，MF为1表示该数据片不是最后一片，为0则表示该片为最后一片。</li><li>位偏移标识该分片对于原数据IP的偏移量。</li></ul><p>分片时，每个分片都要复制原IP的报头。</p><p>设原IP数据报长度为$L$，待转发链路的MTU为$M$，则一个最大分片所能承载的数据量为：<br>$$<br>d&#x3D;\lfloor{\frac{M-20}{8}}\rfloor\times8<br>$$<br>20为IP数据报头长度。</p><p>需要的总片数为：<br>$$<br>n&#x3D;\lceil\frac{L-20}{d} \rceil<br>$$<br>片偏移为：<br>$$<br>F_i&#x3D;\frac{d}{8}\times (i-1), 1\leq i\leq n<br>$$</p><h2 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h2><p>网络号-主机号</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】Boyer-Moore投票算法</title>
      <link href="/2023/10/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Boyer-Moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Boyer-Moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>该算法用于<strong>寻找数组中出现最多次元素</strong>的问题。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><ol><li>初始化两个变量<strong>出现最多次元素的值val</strong>和<strong>这个元素出现的次数time</strong>。</li><li>遍历数组：<ol><li>若time为0，则将遍历到的当前元素赋值给val。</li><li>若数组中当前元素与val相同，则让time自增，否则让time自减。</li></ol></li><li>(可选)检查。</li></ol><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BM</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>, time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>) &#123;</span><br><span class="line">            val = i;</span><br><span class="line">            time = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == val) &#123;</span><br><span class="line">            ++time;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的直观理解是这样的，一些人在为一个政治问题投票，如果投票最多的选项是A，那么投其他选项的人都是反对A的人。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p><a href="https://leetcode.com/problems/majority-element/">Leetcode169. Majority Element</a>题解为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> elem = <span class="number">0</span>, times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(times == <span class="number">0</span>) &#123;</span><br><span class="line">                elem = i;</span><br><span class="line">                ++times;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == elem) &#123;</span><br><span class="line">                ++times;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --times;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/majority-element-ii/">Leetcode229. Majority Element II</a>题解为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate1 = <span class="number">0</span>, candidate2 = <span class="number">0</span>, count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Search</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate1 == num) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidate2 == num) count2++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate1 = num;</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate2 = num; </span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Verification</span></span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate2) count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) ans.<span class="built_in">push_back</span>(candidate1);</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) ans.<span class="built_in">push_back</span>(candidate2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文总结】知识图谱增强大模型的几种方法</title>
      <link href="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/"/>
      <url>/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>大模型，比如ChatGPT，在各大领域嘎嘎乱杀，目前感觉各个专业的各个研究方向都有许多项目和大模型有关。大模型大多采用Transformer架构，大概分为三种，BERT类(主要结构为Transformer的encoder)、GLM类(主要结构包括encoder和decoder)和GPT类(主要结构为decoder)。大模型具有普适性，即能输出各个领域的知识。但是，其也存在很多问题，比如胡乱推理(hallucination，幻觉现象)、黑盒性(这导致人类很难具体解释大模型内部是怎么运作的)。</p><p>知识图谱内部存储具体的、实际的信息，其一般以三元组方式存储知识，结构为：(实体A，实体A与实体B的关系，实体B)。在无噪声的知识图谱内搜索，不会出现“胡乱推理”的行为，但是，知识图谱也存在一系列问题：难以构造、没法获取新知识等。</p><p>可以通过知识图谱增强大模型的推理能力。本文总结幻读过的一些论文，做个关于二者结合的小小总结。</p><p>参考《Unifying Large Language Models and Knowledge Graphs: A Roadmap》这篇论文，通过知识图谱增强大模型的方法大概有两种：</p><ol><li><p>Dynamic Knowledge Fusion(动态的知识融合)。该方法的架构为如下的双塔型：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/model1.png"></p><p>将整个KG、问题分别编码，接着送入联合推理层进行推理。</p></li><li><p>Retrieval-Augmented Knowledge Fusion(检索增强的知识融合)。该方法的架构为，先从KG选取和问题有关的子图，接着进行处理。</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/model2.png"></p></li></ol><h1 id="动态知识融合的实例"><a href="#动态知识融合的实例" class="headerlink" title="动态知识融合的实例"></a>动态知识融合的实例</h1><h2 id="QA-GNN"><a href="#QA-GNN" class="headerlink" title="QA-GNN"></a>QA-GNN</h2><p>该方法主要处理选择题。</p><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN.png"></p><p>该方法步骤如下：</p><ol><li><p>将问题编码，搜寻涉及到的问题节点和答案节点，接着设定一个辅助节点Z，将它与知识图谱中的问题节点、答案节点连接起来，构成一个工作图(working graph)。</p></li><li><p>应用如下公式计算每个节点的相关性评分:</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN1.png"></p></li><li><p>应用以GAT为基础的图神经网络(GNN)在工作图上进行推理，参数更新如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN2.png"></p><p>这里的$f_n$是两层MLP。</p></li><li><p>对于每一个节点，我们要考虑节点类型和其能提供的信息，节点类型的计算：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN3.png"></p><p>这里的$f_u$是一个线性变换，$f_r$是一个2层感知机，就是两层MLP。其中源、目标节点、关系类型用one-hot方法表示，记作$u_s,u_t$，二者关系用$e_{st}$表示。提供的信息用如下公式进行计算：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN4.png"></p><p>一个线性变换。</p></li><li><p>接着计算最终的注意力权重：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN5.png"></p><p>首先将节点的相关性分数升维，然后计算查询向量和key向量带来的权重，接着计算注意力机制即可。</p></li></ol><h2 id="JointLK"><a href="#JointLK" class="headerlink" title="JointLK"></a>JointLK</h2><p>处理选择题。其创新之处在于双向注意力机制的应用。</p><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK.png"></p><p>该结构包括两个主要部分：交叉推理模块和动态修剪模块。</p><p>LM Encoder层先采用预训练的语言模型编码问题和备选项，接着应用下图公式，先输入进一个线性变换层，接着应用一个激活函数输出即可：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK2.png"></p><p>GNN Layer层则要复杂一些，首先使用平均池化的BERT获得KG中每个实体的表示，接着应用以RGAT为基础的GNN层处理得到的实体表示：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK3.png"></p><p>交叉推理模块的目的是减少知识图谱特征和查询向量之间的差异，其输入是之前提到的两个层的输出。首先根据如下公式构造一个“亲和力矩阵”(Affinity Matrix):</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK4.png"></p><p>其中$q_i^{l-1}$是第l层交叉推理模块输入的第i个查询向量。</p><p>接着用Softmax函数处理，得到KG-to-LM attention，若用Softmax函数处理亲和力矩阵的转置矩阵，则得到LM-to-KG attention。</p><p>原有的查询向量和KG-to-LM attention矩阵相乘，得到暂时的查询向量表示；原有的KG表示和LM-to-KG attention矩阵相乘，得到暂时的KG表示。暂时的查询向量表示和暂时的KG表示相连，再送入线性层，即可得到新的查询向量表示，新的KG表示也可以通过类似的方法得到。详情见总结构图。</p><p>对于动态修建模块来说，我们的目标是在KG中切除没用的节点，断开没用的关系边，计算公式如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK5.png"></p><p>$K$是一个超参数，决定修剪的激进程度，而$|V|$则表示实体的数量。公式14的意思就是，从Z这个KG中，留下$upperbound(K|V|)$个节点。</p><p>在这之后，将切除的节点和与它们相连的边删除即可。</p><p>在N层迭代之后，将KG表示做注意力池化，将查询向量表示做平均池化，将二者concat，输入MLP层，即可得到输出。</p><h2 id="GreaseLM"><a href="#GreaseLM" class="headerlink" title="GreaseLM"></a>GreaseLM</h2><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/GreaseLM.png"></p><p>其结构很简单，通过LM编码query，通过GNN编码KG，接着将query中的一个元素和GNN中的一个元素接入一个MLP，这就完成了信息的传递，接着将剩下的元素分别传入LM和GNN，在这两个结构内，信息逐步传播到邻近的节点。</p><h1 id="检索增强的知识融合实例"><a href="#检索增强的知识融合实例" class="headerlink" title="检索增强的知识融合实例"></a>检索增强的知识融合实例</h1><h2 id="Think-on-graph"><a href="#Think-on-graph" class="headerlink" title="Think-on-graph"></a>Think-on-graph</h2><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/Think-On-Graph.png"></p><p>步骤如下：</p><ol><li>实体获取：根据输入的问题，应用LLM获取有关联节点。</li><li>基于束搜索(Beam Search)的探索：<ol><li>关系搜索与修剪：从现有的节点开始，探索所有相连的关系边，迭代操作，最终应用LLM修剪贡献不大的边。</li><li>实体搜索与修剪：在关系搜索的过程中，每次迭代都会获取一个实体的集合，应用LLM修剪贡献不大的实体节点。</li></ol></li><li>推理：最终我们获取了P条推理链，应用LLM判断这些推理链是否足够推理出最终结果。能，就输出最终结果，否则重复探索操作。</li></ol><h2 id="StructGPT"><a href="#StructGPT" class="headerlink" title="StructGPT"></a>StructGPT</h2><p>本篇论文提出的方法可以被简单地概括为<strong>迭代阅读-推理方法</strong>。</p><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/StructGPT.png"></p><p>该篇论文没有局限在只使用KG来增强LLM，作者使用了各种结构化的知识库，如KG、数据库和数据表。</p><p>步骤如下：</p><ol><li>阅读：应用预选设计的一系列API，从结构化的知识库中提取出相关知识。</li><li>推理：首先将阅读得到的信息线性化，亦即转化为规定好的格式，然后交付给LLM输出。LLM的输出有两种情况，一种是简单地输出最终答案，一种是输出根据现有信息推导出的新信息，根据新信息，继续迭代阅读。</li></ol><p>该方法没有完全解决Hallucination的问题。</p><h2 id="EMAT"><a href="#EMAT" class="headerlink" title="EMAT"></a>EMAT</h2><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/EMAT.png"></p><p>步骤如下：</p><ol><li>将结构化的知识存储为键值对。作者采用的结构化知识库的key是问题，value是答案。<ol><li>对key编码时，首先在key前增加一个长度为P的前缀，卷积最后一层隐藏层的输出，接着取前P个结果作为编码。</li><li>对value编码时，增加长度为P的前缀，取最后一层隐藏层输出的前P个元素作为编码。</li></ol></li><li>对于输入的问题，应用上面对key编码的方式，接着应用MIPS(Maximun Inner Product Search)搜索top-K个最相关的键值对，按照相关顺序排序。</li><li>将key增加位置编码，然后concat成一个矩阵，在每一层隐藏层的状态前都concat这个矩阵。对于value，做同样的操作，但是要加在每一层隐藏层的前面。如此操作，最终输出答案即可。</li></ol><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><h2 id="CRITIC"><a href="#CRITIC" class="headerlink" title="CRITIC"></a>CRITIC</h2><p>应用外部应用(搜索引擎、编程语言、知识图谱等)验证、修改LLM输出。</p><h2 id="Graph-Toolformer"><a href="#Graph-Toolformer" class="headerlink" title="Graph-Toolformer"></a>Graph-Toolformer</h2><p>微调出一个能够生成在KG中查询的LLM。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】堆和优先队列</title>
      <link href="/2023/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2023/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一棵树，若父节点的值不小于子节点的值，就是大根堆，若父节点的值不大于子节点的值，就是小根堆。常用的堆为二叉大根堆。</p><p>二叉堆是一个完全二叉树。所谓完全二叉树就是，每一层的节点都”左对齐”，具体参考<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a>。</p><p>堆有几种操作：</p><ol><li><p>插入。向二叉堆中插入节点，只需在最后一层插入，之后根据堆的性质和父节点的值比较大小，调整位置即可，该操作最多比较的次数和层数几乎一致，故复杂度为$O(log_2n)$。</p></li><li><p>修改。同样复杂度为$O(log_2n)$。</p></li><li><p>删除根节点。该操作通常直接将层序从左向右遍历的最后一个节点赋给根节点的值，删除最后一个节点，接着根节点和子节点值比较，进行调整，复杂度同样为$O(log_2n)$。</p></li></ol><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>优先队列是排好序的队列。其本质就是一个堆。为什么？将堆拉直，第二层节点置于第一层右侧，第三层节点置于第二层右侧，就实现了一个线性的数据结构，由于删除常常删除根节点，而插入常常在末尾添加，这就是一个队列。</p><p>在C++里，优先队列是一个大根堆，由<code>vector</code>实现，严格来说，优先队列是<code>vector</code>的一个适配器。如果对性能有要求，可以自己写一个堆。</p><p>由于是使用<code>vector</code>实现的，那么讨论几种操作的复杂度：</p><ol><li>插入。只需要从左到右将待插入的元素和队列里元素逐个比较即可，复杂度为$O(n)$，注意，这里并非将整个队列排序，而是对单个元素进行排序，所以复杂度不是$O(nlogn)$。</li><li>删除。复杂度为$O(n)$。</li></ol><h1 id="适用于什么问题"><a href="#适用于什么问题" class="headerlink" title="适用于什么问题"></a>适用于什么问题</h1><p>由于优先队列和堆的有序性，其常常用于“前k个…”问题。</p><p>比如<a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">Leetcode703. Kth Largest Element in a Stream</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt; ,greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和<a href="https://leetcode.com/problems/k-closest-points-to-origin/">Leetcode973. K Closest Points to Origin</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> (a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>]) &lt; (b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, compare&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; p : points) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(p);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法</h1><p>该算法适用于求解上述问题，其本质是分治算法(divide and conquer)。</p><p>该算法的思想是：逐步缩小选择范围。</p><p>具体的解释在<a href="https://zhuanlan.zhihu.com/p/64627590">Top K 问题的最优解 - 快速选择算法（Quickselect）</a>这里解释的已经很清楚了，这里只是用C++实现一下相关代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pivot = arr[r], i = l;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j] &lt;= pivot) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">swap</span>(arr[i], arr[r]);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KthSmallest</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> part_index = <span class="built_in">Partition</span>(arr, l, r);</span><br><span class="line">  <span class="keyword">if</span>(k - <span class="number">1</span> == part_index - l) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[part_index];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k - <span class="number">1</span> &lt; part_index - l) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">KthSmallest</span>(arr, l, part_index - <span class="number">1</span>, k);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">KthSmallest</span>(arr, part_index+<span class="number">1</span>, r, k - part_index - <span class="number">1</span> + l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">KthSmallest</span>(arr, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用这个方法做<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode215. Kth Largest Element in an Array</a>会导致TLE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot_index = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l, i = l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivot_index], nums[r]);</span><br><span class="line">        <span class="type">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">partition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(index != nums.<span class="built_in">size</span>() - k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt; nums.<span class="built_in">size</span>() - k) &#123;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, <span class="number">0</span>, index - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, index + <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>远不如调用<code>std::priority_queue</code>来得舒适。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】位运算</title>
      <link href="/2023/08/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2023/08/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1. 位运算符"></a>1. 位运算符</h1><p>在C++里，位运算一共有六种：</p><ol><li><code>&amp;</code>，按位与。</li><li><code>|</code>，按位或。</li><li><code>^</code>，异或符。</li><li><code>~</code>，按位取反符。</li><li><code>&gt;&gt;</code>，算术右移运算符，即左侧用符号为补位，比如同样右移四位：0000 1111-&gt;0000 0000，而1111 0000-&gt;1111 1111。</li><li><code>&lt;&lt;</code>，左移运算符。</li></ol><p>Java语言在上述基础上，多了一个逻辑右移运算符<code>&gt;&gt;&gt;</code>，即右移时高位只补0。</p><h1 id="2-位运算符的各种用法"><a href="#2-位运算符的各种用法" class="headerlink" title="2. 位运算符的各种用法"></a>2. 位运算符的各种用法</h1><h2 id="1-判断奇偶"><a href="#1-判断奇偶" class="headerlink" title="1. 判断奇偶"></a>1. 判断奇偶</h2><p>设一个十进制数$N$的补码二进制表示为$a_na_{n-1}\cdots a_1$，则对于正数有：<br>$$<br>N &#x3D; a_n \times 2^{n-1} + a_{n-1}\times 2^{n-2}+\cdots+a_1 \times 1<br>$$<br>对于负数有：<br>$$<br>N &#x3D; -a_n \times 2^{n-1} + a_{n-1}\times 2^{n-2}+\cdots+a_1 \times 1<br>$$</p><p>公式参见《深入理解计算机系统》。</p><p>对于一个二进制数来说，除去其最低位，各位的权重都为2的整数次幂，修改它们，等价于加上&#x2F;减去一个偶数，不影响二进制数的奇偶性。</p><p>二进制数字的奇偶性由其最低位决定，最低位为1，则该数为奇，否则为偶。</p><p>根据上述理论，可写出判断奇偶数的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsOdd</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如<a href="https://leetcode.com/problems/number-of-1-bits/">Leetcode191. Number of 1 Bits</a>，就是该用法的变体，解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) result++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-swap-函数的位运算实现"><a href="#2-swap-函数的位运算实现" class="headerlink" title="2. swap()函数的位运算实现"></a>2. swap()函数的位运算实现</h2><p>出自《深入理解计算机系统》。一般来说，没人会这么写的，说实话。</p><p>至于为什么，看看下面提到的异或的性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-异或的性质-amp-只出现一次的数字"><a href="#3-异或的性质-amp-只出现一次的数字" class="headerlink" title="3. 异或的性质&amp;只出现一次的数字"></a>3. 异或的性质&amp;只出现一次的数字</h2><p>只出现一次的数字问题为<a href="https://leetcode.com/problems/single-number/">Leetcode136. Single Number</a>，解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            result ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解这道题，不得不知道异或的性质：</p><ol><li>交换律：$a \oplus b &#x3D; b \oplus a$。</li><li>结合律：$a\oplus (b\oplus c) &#x3D; (a\oplus b)\oplus c$。</li><li>无序性：任意多个元素进行异或运算，结果与运算次序无关。</li><li>$x\oplus x &#x3D; 0$，$x\oplus 0 &#x3D; x$。事实上，这是一个幺半群，0是该幺半群的单位元&#x2F;幺元。</li></ol><p>所以，对于上面那道题，由于大多元素出现两次，只有一个元素出现一次，就可以使用第四条性质求解。</p><p>此外，对于<a href="https://leetcode.com/problems/missing-number/">Leetcode268. Missing Number</a>则有使用异或的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            target ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            target ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-乘除法的简化"><a href="#4-乘除法的简化" class="headerlink" title="4. 乘除法的简化"></a>4. 乘除法的简化</h2><p>理论上来讲，若二进制数字有无限位，则左移1位等价于乘2，右移一位等价于除2。</p><p>所以乘&#x2F;除2的整数次幂可以用移位位运算简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Times2</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Divide2</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    a &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-判断一个正数是否为2的整数幂"><a href="#5-判断一个正数是否为2的整数幂" class="headerlink" title="5. 判断一个正数是否为2的整数幂"></a>5. 判断一个正数是否为2的整数幂</h2><p>这种数的补码表示只有一个1，这种数减一会让1后面的所有0置1,本身置0,即：00100 - 00001 &#x3D; 00011。其他数字没有这个特点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPowOf2</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(a &amp; (a - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如<a href="https://leetcode.com/problems/counting-bits/">Leetcode338. Counting Bits</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lower_bound = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(!(i == <span class="number">0</span>));</span><br><span class="line">                lower_bound = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(result[i - lower_bound] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-不用加法运算符实现加法"><a href="#6-不用加法运算符实现加法" class="headerlink" title="6. 不用加法运算符实现加法"></a>6. 不用加法运算符实现加法</h2><p>本题为<a href="https://leetcode.com/problems/sum-of-two-integers/">Leetcode371. Sum of Two Integers</a>。按照半加器的思路来就行。</p><p>每次只考虑最后一位，进位由$a\And b$决定，而本位则由$a \oplus b$决定。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> carry = a &amp; b;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = carry &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">0</span> &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-位反转"><a href="#7-位反转" class="headerlink" title="7. 位反转"></a>7. 位反转</h2><p>移位运算也可以做一些有用的操作，将二进制数字看作一个数组即可。本题为<a href="https://leetcode.com/problems/reverse-bits/">Leetcode190. Reverse Bits</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            result &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            result += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】一维动态规划</title>
      <link href="/2023/08/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/08/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>动态规划永远是一道迈不过去的坎～</p><p>道理我都懂，但是相关的题目就是做不出来～</p><p>这种问题太灵活啦！</p><h1 id="何为动态规划？"><a href="#何为动态规划？" class="headerlink" title="何为动态规划？"></a>何为动态规划？</h1><p>我曾经在上过“算法设计与分析”课程后，写过相关的文章：<a href="https://coder109.github.io/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">【算法】动态规划</a>。</p><p>简单说来，动态规划这个名字本身没什么特殊的，可能就是某人为了装B而设计的：<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92#%E5%8E%86%E5%8F%B2">动态规划-历史</a>。</p><p>动态规划本身是这样的一种方法：从小的子问题逐步求解，最终求解大的主问题的过程。直接求取这种“主问题”，往往会重复计算子问题，造成不必要的开销，若从子问题求解，并<strong>记住</strong>子问题的结果，就能在求取主问题时，节省大量的开销。</p><p>其步骤大概为：简化原问题-建立递归方程-求解子问题-求解原问题。其中，建立递归方程(建立递推公式)是最重要的一步。</p><p>简单应用可以参考我之前的博文，本文主要记录力扣上几类一维DP问题的思路、求解方法。</p><h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><h2 id="递推公式：主问题和子问题有明显联系"><a href="#递推公式：主问题和子问题有明显联系" class="headerlink" title="递推公式：主问题和子问题有明显联系"></a>递推公式：主问题和子问题有明显联系</h2><p>主问题和子问题通过递推公式连接在一起，可以通过分析题目寻找这种关系。</p><p>对于<a href="https://leetcode.com/problems/climbing-stairs/">Leetcode70. Climbing Stairs</a>：</p><p>主问题不好直接求解，先从小问题考虑：上到第一层有一种走法，第二层有两种走法，那么可以在这个基础上推得：</p><p>单独拿每一层来分析，到达$i$层共有两种方法，从$i-1$层跨一级台阶走上来，或者从$i-2$层跨两级走上来，于是，令$dp[i]$为到达第$i$层的总共方法数，递推公式为：<br>$$<br>dp[i] &#x3D; dp[i-1]+dp[i-2]<br>$$<br>对于<a href="https://leetcode.com/problems/pascals-triangle/">Leetcode118. Pascal’s Triangle</a>，联系已经非常明显了，令$dp[i][j]$为第$i$行第$j$列的元素，递推公式为:<br>$$<br>dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]<br>$$</p><h2 id="递推公式：主问题和部分子问题有明显联系"><a href="#递推公式：主问题和部分子问题有明显联系" class="headerlink" title="递推公式：主问题和部分子问题有明显联系"></a>递推公式：主问题和部分子问题有明显联系</h2><p>主问题有时无法直接使用DP，需要拆分成部分子问题，对于这些子问题应用DP，最后合并。</p><p>对于<a href="https://leetcode.com/problems/house-robber-ii/">Leetcode213. House Robber II</a>来说，由于最后一个房子和第一个房子是邻接房子，不能直接使用<a href="https://leetcode.com/problems/house-robber/">Leetcode198. House Robber</a>的直接递推DP，需要对于两个子问题进行DP：最终的最大值为不抢最后一个房子的值和不抢第一个房子的值的最大值。用类似Python表示方法来表示递推公式：<br>$$<br>dp[all]&#x3D;max(dp[1:],dp[:-1])<br>$$<br>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], self.helper(nums[<span class="number">1</span>:]), self.helper(nums[:-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        rob1, rob2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            newRob = <span class="built_in">max</span>(rob1 + n, rob2)</span><br><span class="line">            rob1 = rob2</span><br><span class="line">            rob2 = newRob</span><br><span class="line">        <span class="keyword">return</span> rob2</span><br></pre></td></tr></table></figure><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><p>有的时候递推公式并不是很好写出来，但是可以根据相关子问题的模式，获得主问题和子问题的关系，之后用代码实现这种关系即可。大多数问题都属于这样的问题。</p><p>对于<a href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode5. Longest Palindromic Substring</a>最长回文子串问题，可以通过一维DP求解。</p><p>考虑回文串本身是如何构建的：</p><ol><li>奇数长度的回文串，可以看作由中心字母向两边拓展而来，即：”c”-&gt;”aca”-&gt;”bacab”-&gt;”cbacabc”。</li><li>偶数长度的回文串，可以看作由空白字符向两边扩展而来，即：””-&gt;”cc”-&gt;”bccb”-&gt;”dbccbd”。</li></ol><p>用上下文无关文法来表示:<br>$$<br>S\to aSa|bSb|\cdots|zSz|a|b|\cdots|z|\varepsilon<br>$$<br>那么可以使用$dp[i]$记录以$i$结尾的<strong>最长回文子串</strong>的起始索引，这样就相当于表示了现有的一串回文子串，在这个基础上拓展或修改，就可以得到全局的最长回文串：</p><p>一般的，当遍历到$dp[i+1]$时，如果$i+1$处的字符和$dp[i]-1$处相等，则表明可以扩展，让$dp[i+1]$为$dp[i]-1$即可:</p><p><img src="/2023/08/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.jpg"></p><p>若二者不相等，则遍历以$dp[i],dp[i]+1,dp[i]+2,\cdots$起始的所有子串，直到找到回文串。</p><p>可行的C++解法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string a)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = a.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r; l++, r--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[l] != a[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        result += s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; s[dp[i<span class="number">-1</span>] - <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(dp[i<span class="number">-1</span>] - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l, r = i;</span><br><span class="line">                <span class="keyword">for</span>(l = dp[i<span class="number">-1</span>]; l &lt; r; ++l) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(l, r - l + <span class="number">1</span>))) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(l);</span><br><span class="line">            &#125;</span><br><span class="line">            result = (i - dp[i] + <span class="number">1</span>) &gt; result.<span class="built_in">size</span>() ? s.<span class="built_in">substr</span>(dp[i], i-dp[i]+<span class="number">1</span>) : result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim折腾小记</title>
      <link href="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Emacs很好，写一些中小型项目体验还不错，但是写一些Python的小项目时，体验很差。我怎么也配置不好Python的LSP，每次进行代码补全，Emacs都会非常卡顿。</p><p>于是我稍稍尝试了一下Neovim，发现Python的LSP在这上面的表现出色得多。</p><p>我并没有从0开始写Neovim的配置文件，而是在<a href="https://github.com/jdhao/nvim-config">jdhao&#x2F;nvim-config</a>的基础上进行修改，这个配置已经很出色了，很好看，lsp、git之类的功能实现得也很完善。但是和我想要的体验还有一点点差距。</p><h1 id="1-美化"><a href="#1-美化" class="headerlink" title="1. 美化"></a>1. 美化</h1><p>用惯了Emacs下的<code>dashboard</code>，我还是喜欢在编辑器启动的时候显示一些有用的信息：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/1.png"></p><p>于是通过<code>startup-nvim</code>配置主界面，大概效果如下：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/2.png"></p><p>此外，原配置每次启动都会随机使用一套主题，有的主题很丑，修改<code>core/colorschemes.lua</code>中的随机生成主题函数，发现其从一个数组中选取主题，让该数组中只有一个主题即可。(lua？一点都不会！只能用这种愚蠢的办法了～)</p><h1 id="2-更人性化的括号处理"><a href="#2-更人性化的括号处理" class="headerlink" title="2. 更人性化的括号处理"></a>2. 更人性化的括号处理</h1><p>在Emacs上，当打出一个左大括号，按下回车，会自动补全另一个大括号，并且会自动换行，最终这个样子：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/3.png"></p><p>然而在Neovim上，编辑器只会补全大括号，而不换行：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/4.png"></p><p>这样太难受了，通过修改配置文件<code>core/options.vim</code>让表现和Emacs下一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;Esc&gt;ko&lt;Tab&gt;</span><br><span class="line">imap &#125;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;Esc&gt;ko</span><br></pre></td></tr></table></figure><h1 id="3-更多的语言支持"><a href="#3-更多的语言支持" class="headerlink" title="3. 更多的语言支持"></a>3. 更多的语言支持</h1><p>除去Python，我偶尔还会用OCaml、rust等语言写一些小项目。</p><p>照猫画虎在<code>lua/config/lsp.lua</code>中将其它的Language Server安装上即可。不得不说，在Neovim上配置lsp实在是简单，也不会碰见什么奇奇怪怪的问题。</p><p>接着在<code>lua/plugins.lua</code>中安装<code>codeium</code>AI补全工具，基本上就万事大吉了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>配置Emacs、Linux、Neovim，的确很有趣，但是也很费时间，有些东西我实在实在懒得配置了。</p><p>写JS，HTML之类的东西还得用VSCode，写Java还得用IDEA，最终感觉，这一切都是工具而已，结果要比工具重要得多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Neovim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】链表相关</title>
      <link href="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环形链表的判别"><a href="#1-环形链表的判别" class="headerlink" title="1. 环形链表的判别"></a>1. 环形链表的判别</h1><p>常用于判断链表是否有环的问题，拿可解<a href="https://leetcode.com/problems/linked-list-cycle/">Leetcode141. Linked List Cycle</a>举例子，对于如下的链表：</p><p><img src="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/1.png"></p><p>判断是否有环有两种方法：</p><ol><li>哈希表。从头开始遍历，若碰见遍历过的节点，就返回“有环”；若碰见未遍历过的节点，就将之加入哈希表；若碰见空指针，就返回“无环”。</li><li>从头开始遍历，设立两个指针，一个慢指针指向头节点，一次遍历一个节点，一个快指针指向头节点的下一个节点，一次遍历两个节点，二者若指向同一节点，就返回有环，若二者其中之一碰到空指针，就返回无环。</li></ol><p>Java的哈希表更好用一些，第一种方法的Java解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashMap&lt;ListNode, Integer&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.getOrDefault(head, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                myMap.put(head, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于快慢指针法，为什么两个指针一定能相遇呢？普遍的环形链表结构如下：</p><p><img src="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/2.png"></p><p>此时，设慢指针走了$x+k$步，那么快指针便走了$2x+2k+1$步(记得算上二者初始差的一步)假设二者无法相遇，则表明：<br>$$<br>x+k+n(y+1)&#x3D;2x+2k+1,n\in Z^+<br>$$<br>中的$k$无解，显然：<br>$$<br>k&#x3D;n(y+1)-x-1,n\in Z^+<br>$$<br>是一个解，那么假设不成立，二者可以相遇。</p><p>对于无环链表，显然快慢指针无法相遇。</p><p>快慢指针C++解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1-5-环形入口的搜索"><a href="#1-5-环形入口的搜索" class="headerlink" title="1.5 环形入口的搜索"></a>1.5 环形入口的搜索</h1><p>将上面的$k$解带入$y$快指针走过的距离：<br>$$<br>s_{total} &#x3D; 2x+2k+1 &#x3D; 2n(y+1)-1<br>$$<br>可以求出快指针在环内走过的距离：<br>$$<br>s_{cycle} &#x3D; 2n(y+1)-1-x<br>$$<br>快指针距离环形入口的距离为$x+1$。</p><p>若想让快慢指针相遇在环形入口处，则需要先让快指针走一个节点，然后将慢指针放回头节点，接着让二者向前遍历，相遇点则为环形入口。</p><p>可解<a href="https://leetcode.com/problems/linked-list-cycle-ii/">Leetcode142. Linked List Cycle II</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-基本的插入-x2F-删除-x2F-反转-x2F-合并问题"><a href="#2-基本的插入-x2F-删除-x2F-反转-x2F-合并问题" class="headerlink" title="2. 基本的插入&#x2F;删除&#x2F;反转&#x2F;合并问题"></a>2. 基本的插入&#x2F;删除&#x2F;反转&#x2F;合并问题</h1><p>在纸上画一画就好，仔细捋清楚节点具体该如何变换、该返回哪个节点、先做什么再做什么。</p><p>比如反转链表：<a href="https://leetcode.com/problems/reverse-linked-list/">Leetcode206. Reverse Linked List</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">            next = (next == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，利用STL本身的性质解题，往往事半功倍，比如<a href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode23. Merge k Sorted Lists</a>，利用<code>map</code>底层的红黑树性质解题，速度很快：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* node : lists) &#123;</span><br><span class="line">            ListNode* temp = node;</span><br><span class="line">            <span class="keyword">while</span>(temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                dict[temp-&gt;val]++;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = dict.<span class="built_in">begin</span>(); iter != dict.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            <span class="type">int</span> key = iter-&gt;first;</span><br><span class="line">            <span class="type">int</span> val = iter-&gt;second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; val; ++i) &#123;</span><br><span class="line">                ListNode* neo = <span class="keyword">new</span> <span class="built_in">ListNode</span>(key);</span><br><span class="line">                curr-&gt;next = neo;</span><br><span class="line">                curr = neo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-5-隐藏的成环可能"><a href="#2-5-隐藏的成环可能" class="headerlink" title="2.5 隐藏的成环可能"></a>2.5 隐藏的成环可能</h1><p>对于<a href="https://leetcode.com/problems/reorder-list/">Leetcode143. Reorder List</a>，完全可以用一个<code>vector</code>记录遍历过的结点，然后根据索引规律排列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt; memo;</span><br><span class="line">        ListNode* ptr = head;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            memo.<span class="built_in">push_back</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = memo.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        ListNode* curr = ptr;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">                curr-&gt;next = memo[l++];</span><br><span class="line">                <span class="comment">//curr = curr-&gt;next;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr-&gt;next = memo[l++];</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = memo[r--];</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//curr-&gt;next = nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解注释所有注释的语句，可以通过检验。</p><p>注释掉的语句的作用是：让遍历到的最后一个节点的下一个节点为空，若不空，则链表会成环，会报类似错误：</p><blockquote><p>&#x3D;&#x3D;22&#x3D;&#x3D;ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000000b8 at pc 0x00000038b12d bp 0x7ffda25fd140 sp 0x7ffda25fd138</p></blockquote><p>猜测，可能的原因为，析构<code>ListNode</code>时，是逐个遍历析构的，若成环，则会析构已经析构的节点，报错。</p><h1 id="3-深拷贝问题"><a href="#3-深拷贝问题" class="headerlink" title="3. 深拷贝问题"></a>3. 深拷贝问题</h1><p>所谓深拷贝(deep copy)，就是:</p><blockquote><p>A <strong>deep copy</strong> of an object is a copy whose properties do  not share the same references (point to the same underlying values) as  those of the source object from which the copy was made. </p><p>一个对象的深拷贝是一种拷贝，其属性值与原对象相等，但是不与原对象共享引用。</p><p>——<a href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy">MDN Web Docs</a></p></blockquote><p>简单来说，就是两个一模一样的对象，分布在不同的内存空间中。本问题对应<a href="https://leetcode.com/problems/copy-list-with-random-pointer/">Leetcode138. Copy List with Random Pointer</a>。</p><p>如果本题链表节点类没有<code>random</code>成员，那么逐个遍历就行。有<code>random</code>，就需要用某种数据结构记忆新旧节点之间的对应关系——哈希表：先复制<code>next</code>关系，将全部节点放置入表；接着复制<code>random</code>关系即可。</p><p>一种可行的C++解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        map&lt;Node*, Node*&gt; dict;</span><br><span class="line">        Node* result = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        Node* neo_head = result;</span><br><span class="line">        Node* memo = head;</span><br><span class="line">        dict[head] = neo_head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node* curr = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            neo_head-&gt;next = curr;</span><br><span class="line">            neo_head = neo_head-&gt;next;</span><br><span class="line">            dict[head] = neo_head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = memo;</span><br><span class="line">        neo_head = result;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            neo_head-&gt;random = dict[head-&gt;random];</span><br><span class="line">            neo_head = neo_head-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">count</span>(head))</span><br><span class="line">      <span class="keyword">return</span> map[head];</span><br><span class="line"></span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">    map[head] = newNode;</span><br><span class="line">    newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">    newNode-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】旋转数列</title>
      <link href="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E5%88%97/"/>
      <url>/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h1><blockquote><p>这东西和动态规划一样令人作呕。</p></blockquote><p>旋转数列一般为旋转排序数列(Rotated Sorted Array)，和它有关的问题有很多，比如<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Leetcode153. Find Minimum in Rotated Sorted Array</a>、<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Leetcode33. Search in Rotated Sorted Array</a>。</p><p>旋转数列的定义为，对于给定数列$a_1,a_2,\cdots,a_n$，其以$k,k\in[1,n]$为中心旋转得到的数列为$a_k,a_{k+1},\cdots,a_{k-1}$。</p><p>这种数列，记作$num$，有这样几条性质：</p><ol><li><p>最左端元素大于最右端元素，即$num[left] \geq num[right]$。</p></li><li><p>$num$可沿着分界点$a_n$分为两个排序的数列，$a_k,a_{k+1},\cdots,a_n$和$a_1,a_2,\cdots,a_{k-1}。$</p></li></ol><p>几乎所有问题都围绕这两条性质展开，我将讨论比较有代表性的几个问题。</p><h1 id="无重复值：分界点的确定"><a href="#无重复值：分界点的确定" class="headerlink" title="无重复值：分界点的确定"></a>无重复值：分界点的确定</h1><p>该问题等价于寻找$a_n$，也等价于在旋转数列中寻找最大值&#x2F;最小值的问题。</p><p>根据上面的第二条性质，可以发现，分界点处的值为左半数列最大值，其右侧的值为右半数列最小值。那么，这个问题可以很简单地通过二分搜索求解，判断中间值是否小于右指针处的值即可，分类讨论二者关系：</p><ol><li>若大于，则表明中间值目前处于左半数列，需要让左端指针右移。</li><li>若小于，则表明其处于右半数列中，需要右端指针左移，但不能移动到<code>mid-1</code>，否则会导致搜索范围完全落在左半数列，无法求出正确的解。</li><li>若二者相等，则表明左右端指针都必然指向同一位置，实际上表明搜索其实已经结束了，此时可以选择让左指针右移跳出循环，也可以选择直接返回。</li></ol><p>根据循环条件，退出循环时，左指针必然大于右指针，指向的是右侧数列的第二个元素或<code>nums.size()</code>，而右侧指针指向右侧数列的第一个元素，也就是旋转数列的最小值。</p><p>于是，我们可以解出<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Leetcode153. Find Minimum in Rotated Sorted Array</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么不和左指针的值比较呢？因为当数列不旋转时，左半数列并不存在；而不论如何右半数列必然存在。和左侧指针的值作比较，很有可能出bug，解法也不如上面的方法优雅简单。</p><h1 id="有重复值：分界点的确定"><a href="#有重复值：分界点的确定" class="headerlink" title="有重复值：分界点的确定"></a>有重复值：分界点的确定</h1><p>这种状况对应<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">Leetcode154. Find Minimum in Rotated Sorted Array II</a>。</p><p>我自己的解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本思想为，碰到重复的，就逐步缩小搜索区域。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】回溯法</title>
      <link href="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>回溯(Backtrack)是一种搜索方法，常用于排列问题、搜索问题的求解。其基本思想为DFS(Depth-First Search)：分步求解，步步为营，一旦探索完该状态的所有可能性，就回退到前一个状态。</p><p>回溯算法的模板大概如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(vector&lt;T&gt;&amp; record, vector&lt;T&gt;&amp; temp, vector&lt;T&gt; choices...)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">IsTerminate</span><span class="params">(temp)</span> </span>&#123;</span><br><span class="line">            record.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(T choice : choices) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">IsLegal</span>(choice)) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(choice);</span><br><span class="line">                <span class="built_in">Backtrack</span>(record, temp, choices);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>(choice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;T&gt; <span class="title">Solve</span><span class="params">(vector&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">        vector&lt;T&gt; record;ge shu</span><br><span class="line">        vector&lt;T&gt; temp;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">Backtrack</span>(record, temp, choices, ...);</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回溯函数里，首先判断是否为终止状态，若是，则将临时状态加入最终结果，若否，则遍历所有的可行选择，加入临时状态，接着继续回溯，等待回溯完成，将选择从临时状态中删除。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>回溯可以应用于排列问题，比如说<a href="https://leetcode.com/problems/permutations/">Leetcode 46. Permutations</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; curr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; answ, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            answ.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(curr.<span class="built_in">begin</span>(), curr.<span class="built_in">end</span>(), num) == curr.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="built_in">backtrack</span>(curr, answ, nums);</span><br><span class="line">                curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">backtrack</span>(curr, result, nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回溯函数中，先判断是否为一个可行的全排列，若是，则将其加入结果列表，否则就挑选合适的数字加入临时状态，挑选的判据为该数字是否已经出现过。</p><p>也可以应用于搜索问题上，比如<a href="https://leetcode.com/problems/all-paths-from-source-to-target/">Leetcode 797. All Paths From Source to Target</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> curr_node, vector&lt;<span class="type">int</span>&gt;&amp; curr_vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr_node == graph.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(curr_vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> node : graph[curr_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(curr_vec.<span class="built_in">begin</span>(), curr_vec.<span class="built_in">end</span>(), node) == curr_vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                curr_vec.<span class="built_in">push_back</span>(node);</span><br><span class="line">                <span class="built_in">backtrack</span>(result, graph, node, curr_vec);</span><br><span class="line">                curr_vec.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp_vec;</span><br><span class="line">        temp_vec.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(result, graph, <span class="number">0</span>, temp_vec);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回溯也可以变得很复杂，比如有<a href="https://leetcode.com/problems/generate-parentheses/">Leetcode 22. Generate Parentheses</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ( - +1 ) - -1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(vector&lt;string&gt;&amp; result, <span class="type">int</span> n, string&amp; curr, <span class="type">int</span> l_num, <span class="type">int</span> r_num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l_num == r_num) &#123;</span><br><span class="line">            curr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">Backtrack</span>(result, n, curr, l_num+<span class="number">1</span>, r_num);</span><br><span class="line">            curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l_num == n) &#123;</span><br><span class="line">            curr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">Backtrack</span>(result, n, curr, l_num, r_num+<span class="number">1</span>);</span><br><span class="line">            curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l_num &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l_num == r_num) &#123;</span><br><span class="line">                curr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="built_in">Backtrack</span>(result, n, curr, l_num+<span class="number">1</span>, r_num);</span><br><span class="line">                curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="built_in">Backtrack</span>(result, n, curr, l_num+<span class="number">1</span>, r_num);</span><br><span class="line">                curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                curr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="built_in">Backtrack</span>(result, n, curr, l_num, r_num+<span class="number">1</span>);</span><br><span class="line">                curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string now = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">Backtrack</span>(result, n, now, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>生成括号时，合法性判据为已经生成的左右括号个数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】单调栈</title>
      <link href="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>单调栈(Monotonic Stack)严格来说是一种数据结构，常用于求解这样的问题：在一个数组中，对每一个元素，寻找下一个比它大&#x2F;小的元素。显然，它有两种：单调递增栈(Monotonic Increasing Stack)和单调递减栈(Monotonic Decreasing Stack)。</p><p>举一个单调递增栈的例子，一个数组的单调递增栈用如下方法构造：从左向右遍历数组，将新元素压栈时，判断栈顶元素是否比新元素大，如果栈顶元素更大，则弹栈，否则将新元素压栈。</p><p>对于数组：<code>1,3,2,4,7</code>来说，其单调栈构造过程如下：</p><ol><li><code>1</code>。</li><li><code>1,3</code>。</li><li><code>1,2</code>，栈顶元素3比2大，先弹栈再将2入栈。</li><li><code>1,2,4</code>。</li><li><code>1,2,4,7</code>。</li></ol><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>本题为经典的<a href="https://leetcode.com/problems/trapping-rain-water/">Leetcode 42. Trapping Rain Water</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mono_stack;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono_stack.<span class="built_in">empty</span>() &amp;&amp; height[mono_stack.<span class="built_in">top</span>()] &lt; height[i])&#123;</span><br><span class="line">                <span class="type">int</span> top = mono_stack.<span class="built_in">top</span>();</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(mono_stack.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> length = i - mono_stack.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> high = <span class="built_in">min</span>(height[mono_stack.<span class="built_in">top</span>()], height[i]) - height[top];</span><br><span class="line">                result += length * high;</span><br><span class="line">            &#125;</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题写了蛮久，其思想基本上就是，从左向右遍历数组，维护一个单调递减栈，只要遍历到了一个比栈顶元素大的元素，就代表有可能形成一个可以装雨水的凹形容器。这时，凹形容器的右边就是当前遍历到的高度，栈顶元素表示凹形的低点，然后弹栈，接着，栈顶元素表示凹形的左侧。</p><p>举个例子：</p><p><img src="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/1.png"></p><p>当遍历到索引4的时候，栈顶是索引3,是凹点，所以计算的水的体积是橘色部分：</p><p><img src="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/2.png"></p><p>接着弹栈，栈顶是索引2，是凹点，所以计算的水的体积是黑色部分：</p><p><img src="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/3.png"></p><p>这样就计算出了一个不规则凹形中所能容纳雨水的体积。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】KMP算法</title>
      <link href="/2023/08/09/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/09/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>KMP算法，也叫做Knuth-Morris-Pratt算法，是常见的字符串匹配算法，效率很高，能在$O(n)$复杂度内求解字符串匹配问题。</p><p>我自己用C语言大概写过三四回KMP算法，每次都有大大小小的bug。这次我就来好好捋一捋KMP算法的原理。</p><h1 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h1><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TrivialMatch</span><span class="params">(string pattern, string text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pattern_len = pattern.length;</span><br><span class="line">    <span class="type">int</span> text_len = text.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> text_p = <span class="number">0</span>; text_p &lt;= text_len - pattern_len; text_p++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pattern_p = <span class="number">0</span>; pattern_p &lt; pattern_len; pattern_p++) &#123;</span><br><span class="line">            <span class="comment">// Check one by one</span></span><br><span class="line">            <span class="keyword">if</span> (pattern[pattern_p] != text[text_p + pattern_p])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If all matched</span></span><br><span class="line">        <span class="keyword">if</span> (pattern_p == pattern_len) <span class="keyword">return</span> text_p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法时间复杂度为$O(mn)$，其中$m,n$分别为文本和模式子串的长度。</p><p>用动画(来自<a href="https://segmentfault.com/a/1190000022642180">https://segmentfault.com/a/1190000022642180</a>)表示出来就是这样的：</p><p><img src="/2023/08/09/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/1.webp"></p><h1 id="简短的分析"><a href="#简短的分析" class="headerlink" title="简短的分析"></a>简短的分析</h1><p>该方法的缺点是，不论在文本串还是模式子串上，二者的指针都会回退，有没有什么方法不让指针回退呢？</p><p>匹配失败的时候，模式子串的指针必须回退，那么可不可以让文本串的指针不回退，尽可能少地回退模式串的指针呢？KMP算法便是应用这种思想的一种算法。</p><p>具体怎么应用？试想一下，进行如下的匹配时：</p><p><img src="https://pic4.zhimg.com/80/v2-bcb634c9d7b2eeb2d4886bf549f0acdb_720w.webp" alt="img"></p><p><code>B</code>和<code>D</code>不匹配，但是我们知道前面的<code>ABACABA</code>已经匹配上了，而且其具有<strong>最长的、相等的</strong>前缀后缀<code>ABA</code>。如何最小程度回退模式串的指针？我们可以让模式串的指针回退到<code>C</code>，因为只有回退到<code>C</code>，才能保证模式串指针之前的部分和文本串匹配：</p><p><img src="https://pic4.zhimg.com/80/v2-5769d470eda95bc7a8bbf60b31ba3f8b_720w.webp" alt="img"></p><p>应用如上原理：</p><p><img src="https://pic1.zhimg.com/80/v2-5f591a07ff5f071351337006bc842f80_720w.webp" alt="img"></p><p>OK，如何实现？</p><h1 id="KMP算法-next数组的计算"><a href="#KMP算法-next数组的计算" class="headerlink" title="KMP算法: next数组的计算"></a>KMP算法: next数组的计算</h1><p>next数组，就是用来记录模式子串的、每个位置对应的最长前缀后缀的数组。</p><p>C++实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">CalculateNext</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; next &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> prefix_length = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pointer_pattern = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(pointer_pattern &lt; pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern[pointer_pattern] == pattern[prefix_length]) &#123;</span><br><span class="line">      next.<span class="built_in">push_back</span>(++prefix_length);</span><br><span class="line">      pointer_pattern++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(prefix_length == <span class="number">0</span>) &#123;</span><br><span class="line">next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">pointer_pattern++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prefix_length = next[prefix_length - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设立两个变量，一个用来记录当前最长的前缀长，一个用来遍历模式子串。若二者对应的字符相等，则二者都加一，并让此时的next数组值为最长的前缀长；若不相等，当最长前缀长为0，说明第一个字符和此时的字符不等，直接让next数组值为0，否则，让最长前缀长等于前一个字符的最长前缀长，由于长度和索引的不等关系，该方法能合理的移动标尺——Quite hard to understand.</p><p>可以手动推一推。</p><h1 id="KMP算法：-匹配过程"><a href="#KMP算法：-匹配过程" class="headerlink" title="KMP算法： 匹配过程"></a>KMP算法： 匹配过程</h1><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(string text, string pattern)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">CalculateNext</span>(pattern);</span><br><span class="line">  <span class="type">int</span> pointer_pattern = <span class="number">0</span>, pointer_text = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((text.<span class="built_in">size</span>() - pointer_text) &gt;= (pattern.<span class="built_in">size</span>() - pointer_pattern))&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern[pointer_pattern] == text[pointer_text]) &#123;</span><br><span class="line">      pointer_pattern++;</span><br><span class="line">      pointer_text++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pointer_pattern == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pointer_text &lt; text.<span class="built_in">size</span>() &amp;&amp; pattern[pointer_pattern] != text[pointer_text]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pointer_pattern != <span class="number">0</span>) &#123;</span><br><span class="line">pointer_pattern = next[pointer_pattern - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pointer_text++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这算是一种比较繁琐，但是比较清晰的实现方法。先计算模式串的next数组，然后匹配，<code>while</code>里的条件是判断文本串剩下的长度是否不少于模式串剩下的长度，防止可能出现的溢出。接着，就按照上面提到的方法实现即可。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>本题为<a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375:【模板】KMP 字符串匹配</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">CalculateNext</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix_length = <span class="number">0</span>, pattern_p = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(pattern_p &lt; pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pattern[pattern_p] == pattern[prefix_length]) &#123;</span><br><span class="line">            next.<span class="built_in">push_back</span>(++prefix_length);</span><br><span class="line">            pattern_p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix_length == <span class="number">0</span>) &#123;</span><br><span class="line">                next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                pattern_p++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix_length = next[prefix_length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    string text, pattern;</span><br><span class="line">    cin &gt;&gt; text &gt;&gt; pattern;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">CalculateNext</span>(pattern);</span><br><span class="line">    <span class="type">int</span> text_p = <span class="number">0</span>, pattern_p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(text_p &lt; text.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(text[text_p] == pattern[pattern_p]) &#123;</span><br><span class="line">            text_p++;</span><br><span class="line">            pattern_p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern_p == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; text_p - pattern_p + <span class="number">1</span>&lt;&lt; endl;</span><br><span class="line">            pattern_p = next[pattern_p - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(text_p &lt; text.<span class="built_in">size</span>() &amp;&amp; text[text_p] != pattern[pattern_p]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pattern_p == <span class="number">0</span>) &#123;</span><br><span class="line">                text_p++;    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pattern_p = next[pattern_p - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> border : next) &#123;</span><br><span class="line">        cout &lt;&lt; border &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】C++的map如何按值排序</title>
      <link href="/2023/08/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91map%E5%A6%82%E4%BD%95%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/08/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91map%E5%A6%82%E4%BD%95%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><code>map</code>自定义是按照键排序的，有些时候需要按照值排序，比如说这道题：<a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a>。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>使用<code>vector</code>和自定义排序函数结合的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; anti_record;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = record.<span class="built_in">begin</span>(); iter != record.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    anti_record.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(iter-&gt;first, iter-&gt;second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(anti_record.<span class="built_in">begin</span>(), anti_record.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br></pre></td></tr></table></figure><p>更清楚一些：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; anti_record;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = record.<span class="built_in">begin</span>(); iter != record.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    anti_record.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(iter-&gt;first, iter-&gt;second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(anti_record.<span class="built_in">begin</span>(), anti_record.<span class="built_in">end</span>(), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>引子中的题解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            record[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; anti_record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = record.<span class="built_in">begin</span>(); iter != record.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            anti_record.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(iter-&gt;first, iter-&gt;second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(anti_record.<span class="built_in">begin</span>(), anti_record.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">        <span class="keyword">auto</span> iter = anti_record.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>((*iter++).first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二分查找的相关细节</title>
      <link href="/2023/08/07/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82/"/>
      <url>/2023/08/07/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>二分查找是一种高效的搜索算法，常用于有序结构的搜索。</p><p>二分查找也是分治法(Divide and Conquer)的一个经典实例：在一个长度为$n$的数组中进行二分查找，其复杂度是$O(logn)$，这是因为二分查找每一次都筛选掉一半搜索区间长度的元素，其递推公式为:<br>$$<br>T(n)&#x3D;\frac{1}{2}T(\frac{n}{2})+O(1)<br>$$<br>可根据主定理(Master Theorem)求解。</p><h1 id="1-经典的二分查找"><a href="#1-经典的二分查找" class="headerlink" title="1. 经典的二分查找"></a>1. 经典的二分查找</h1><p>简单的测试程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; my_vector;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">    my_vector.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = my_vector.<span class="built_in">size</span>() - <span class="number">1</span>, target = <span class="number">19</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(my_vector[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(my_vector[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Find Target At&quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Left: &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot; Right: &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Left: &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot; Right: &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code>循环里的条件一般是<code>left &lt;= right</code>而非<code>left &lt; right</code>。为什么常用前者？让我们看看输出：</p><p>按照程序里的模式，如果将等号省略，输出为：</p><blockquote><p>Left: 10 Right: 19</p><p>Left: 15 Right: 19</p><p>Left: 18 Right: 19</p><p>Left: 19 Right: 19</p><p>Left: 19 Right: 19</p></blockquote><p>不省略等号，输出为：</p><blockquote><p>Left: 10 Right: 19</p><p>Left: 15 Right: 19</p><p>Left: 18 Right: 19</p><p>Left: 19 Right: 19</p><p>Find Target At 19</p><p>Left: 19 Right: 19</p></blockquote><p>搜索21时，省略等号的输出为：</p><blockquote><p>Left: 10 Right: 19<br>Left: 15 Right: 19<br>Left: 18 Right: 19<br>Left: 19 Right: 19<br>Left: 19 Right: 19</p></blockquote><p>不省略等号的输出为：</p><blockquote><p>Left: 10 Right: 19<br>Left: 15 Right: 19<br>Left: 18 Right: 19<br>Left: 19 Right: 19<br>Left: 20 Right: 19<br>Left: 20 Right: 19</p></blockquote><p>当元素存在时：</p><p>省略等号，则当<code>left</code>和<code>right</code>相等时，直接退出循环，<code>break</code>存在与否都无所谓，程序不会陷入死循环。</p><p>不省略等号，则当<code>left</code>和<code>right</code>相等时，输出提示信息，这时如果不加<code>break</code>，程序将死循环。</p><p>这对应着两种需求。前者适用于只要元素下标的情况，比如一维数组的搜索，后者不仅适用于前者的情况，也适用于需要在获取下标的基础上，另外进行一些操作的情况，比如在二维数组中搜索某元素，先搜索列，再搜索行。所以常常使用<code>left &lt;= right</code>的格式。</p><p>当元素不存在时：</p><p>二者的差别仅在于最后<code>left</code>和<code>right</code>的值。省略等号，二者相等，不省略等号，<code>left</code>大于<code>right</code>，且<code>left</code>和<code>right</code>的差为1。</p><p>二分查找的灵活性很强，比如<a href="https://leetcode.com/problems/search-a-2d-matrix/">Leetcode 74. Search a 2D Matrix</a>，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = matrix.<span class="built_in">size</span>() * col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> ele = matrix[mid / col][mid % col];</span><br><span class="line">            <span class="keyword">if</span>(ele &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ele == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-寻找左右边界的二分查找"><a href="#2-寻找左右边界的二分查找" class="headerlink" title="2. 寻找左右边界的二分查找"></a>2. 寻找左右边界的二分查找</h1><p>在递增数组中寻找左边界的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> border1 = left;</span><br></pre></td></tr></table></figure><p>所谓左边界，就是某元素第一次出现的位置，若中间值大于等于目标值，就让右指针左移，略去的值大多都不是元素第一次出现的位置。如果略去了元素第一次出现的位置怎么办呢？可以通过左指针来弥补，因为右指针最远也只能挪移到，元素第一次出现的位置的左侧一格，而最终左指针必然等于右指针指向的值加1，这时左指针必然指向元素第一次出现的位置。</p><p>那么寻找右边界的代码也好写啦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> border2 = right;</span><br></pre></td></tr></table></figure><p>这样我们也就快解出了<a href="https://leetcode.com/problems/find-target-indices-after-sorting-array/">Leetcode 2089. Find Target Indices After Sorting Array</a>。</p><p>该题的C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">targetIndices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> border1 = left;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = border1; i &lt; left; ++i) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似的，也有<a href="https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/">Leetcode 2529. Maximum Count of Positive Integer and Negative Integer</a>，该题只需要将问题转换为求0的左右区间即可，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> borderLeft = left;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(borderLeft, (<span class="type">int</span>)nums.<span class="built_in">size</span>() - left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无聊系列】C实现类似2048的游戏</title>
      <link href="/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/"/>
      <url>/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>无聊是第一生产力。实现一下以前玩过的一版修改版的2048，正好测试一下<code>codeium</code>工具的效果。</p><p>Just for fun:)</p><h1 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h1><p>2048的定义是这样的：</p><blockquote><p>该游戏使用方向键让方块整体上下左右移动。如果两个带有相同数字的方块在移动中碰撞，则它们会合并为一个方块，且所带数字变为两者之和。每次移动时，会有一个值为2或者4的新方块出现，所出現的數字都是2的冪。</p><p>当值为2048的方块出现时，游戏即胜利，该游戏因此得名。</p></blockquote><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>对于移动的实现，我的想法大概是“拆分-合并-补位”，比如让方块向右移动：</p><ol><li>拆分：向右移动的过程中，行与行之间相互独立，只需要实现单个行上的移动操作即可。</li><li>合并：从左往右合并方块。对于2 2 4 8这样的行，原版的2048会合并成0 4 4 8，我的代码将之合并成0 0 0 16，玩起来快一些。</li><li>补位：将方块都紧密地置于一边，即让4 0 8 16变成 0 4 8 16。</li></ol><p>移动的代码大概如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RowMoveRight</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size], <span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; map_size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">map</span>[index][i] == <span class="built_in">map</span>[index][i<span class="number">-1</span>]) &#123;</span><br><span class="line">      <span class="built_in">map</span>[index][i] = <span class="number">2</span> * <span class="built_in">map</span>[index][i];</span><br><span class="line">      <span class="built_in">map</span>[index][i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[index][i] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">map</span>[index][i] = <span class="built_in">map</span>[index][i<span class="number">-1</span>];</span><br><span class="line">      <span class="built_in">map</span>[index][i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; map_size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">map</span>[index][i] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">map</span>[index][i] = <span class="built_in">map</span>[index][i<span class="number">-1</span>];</span><br><span class="line">      <span class="built_in">map</span>[index][i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MoveRight</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size])</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map_size; i++) &#123;</span><br><span class="line">    RowMoveRight(<span class="built_in">map</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  GenerateTwo(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输赢的判断"><a href="#输赢的判断" class="headerlink" title="输赢的判断"></a>输赢的判断</h2><p>如果出现了任意一个2048方块，即为赢。大概的逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GameSuccess</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; map_size; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; map_size; col++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">map</span>[row][col] == <span class="number">2048</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> not_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若每个方块的值，都不等于右侧方块和下侧方块的值，并且，地图被占满，就是输。<code>codeium</code>生成的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GameFailed</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map_size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; map_size - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> not_failed;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="built_in">map</span>[i+<span class="number">1</span>][j] || <span class="built_in">map</span>[i][j] == <span class="built_in">map</span>[i][j+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> not_failed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺对的，哈？No！对于最后一行来说，没法判断方块的值是否等于其右侧方块的值。所以要分开来比较。</p><h2 id="输出相关"><a href="#输出相关" class="headerlink" title="输出相关"></a>输出相关</h2><p>首先要输出的是地图、移动次数和分数，分数的计算规则很简单，2和2拼出4得4分。</p><p>接着，彩色输出方块里数字的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_RED     <span class="string">&quot;\x1b[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_GREEN   <span class="string">&quot;\x1b[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_YELLOW  <span class="string">&quot;\x1b[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_BLUE    <span class="string">&quot;\x1b[34m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_MAGENTA <span class="string">&quot;\x1b[35m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_CYAN    <span class="string">&quot;\x1b[36m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_RESET   <span class="string">&quot;\x1b[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputDigit</span><span class="params">(<span class="type">int</span> digit)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(digit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, digit);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_RED);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_GREEN);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_MAGENTA);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">256</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_YELLOW);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">512</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_CYAN);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_BLUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, digit);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(ANSI_COLOR_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出大概长这样：</p><p><img src="/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/1.png"></p><p>在随便整个主菜单：</p><p><img src="/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/2.png"></p><p>简陋版2048就做好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Boredom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的一些基础知识</title>
      <link href="/2023/07/29/C-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/07/29/C-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引用和指针的区别"><a href="#1-引用和指针的区别" class="headerlink" title="1. 引用和指针的区别"></a>1. 引用和指针的区别</h1><h2 id="定义上的差别"><a href="#定义上的差别" class="headerlink" title="定义上的差别"></a>定义上的差别</h2><p>定义上来说，指针本身代表的不是变量，而是变量的地址；引用是一个变量的别名，所代表的仍是变量本身。也容易推得，指针和引用的数据类型也不同。</p><h2 id="是否可空的差别"><a href="#是否可空的差别" class="headerlink" title="是否可空的差别"></a>是否可空的差别</h2><p>指针可以为空，而引用则不行，创建引用的时候必须将其初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> *b = <span class="literal">nullptr</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;d = c; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> &amp;e; <span class="comment">// Error: Declaration of reference variable &#x27;e&#x27; requires an initializer (lsp)</span></span><br></pre></td></tr></table></figure><p>在考虑传递引用还是指针给函数时，这是很重要的一个考虑点。</p><h2 id="是否可以改变所指对象的差别"><a href="#是否可以改变所指对象的差别" class="headerlink" title="是否可以改变所指对象的差别"></a>是否可以改变所指对象的差别</h2><p>对于指针来说，可以随意改变其所指对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *c = &amp;a;</span><br><span class="line">cout &lt;&lt; *c &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">c = &amp;b;</span><br><span class="line">cout &lt;&lt; *c &lt;&lt; endl; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对于引用来说，修改引用的值，会将引用所指向的值修改掉，而引用仍指向原来的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; &amp;b &lt;&lt; endl; <span class="comment">// 0x7ffde8411808</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; &amp;b &lt;&lt; endl; <span class="comment">// 0x7ffde8411808</span></span><br></pre></td></tr></table></figure><h1 id="2-值类型-Value-categories"><a href="#2-值类型-Value-categories" class="headerlink" title="2. 值类型(Value categories)"></a>2. 值类型(Value categories)</h1><p>参考：</p><ol><li><a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf</a></li><li><a href="https://stackoverflow.com/questions/6107914/how-to-test-whether-expression-is-a-temporary/6114546#6114546">https://stackoverflow.com/questions/6107914/how-to-test-whether-expression-is-a-temporary/6114546#6114546</a></li><li><a href="https://www.zhihu.com/question/46599246/answer/102830868">https://www.zhihu.com/question/46599246/answer/102830868</a></li></ol><h2 id="lvalue-左值"><a href="#lvalue-左值" class="headerlink" title="lvalue-左值"></a>lvalue-左值</h2><p>左值（历史上如此称呼，因为左值可以出现在赋值表达式的左侧）指定一个函数或一个对象。可以理解为，在汇编语句中，具有实际存储地址的值。</p><h2 id="xvalue-将亡值"><a href="#xvalue-将亡值" class="headerlink" title="xvalue-将亡值"></a>xvalue-将亡值</h2><p>将亡值也指对象，通常接近其生命周期结束（例如，以便可以move其资源）。xvalue是涉及右值引用的某些类型表达式的结果。</p><h2 id="glvalue-广义左值"><a href="#glvalue-广义左值" class="headerlink" title="glvalue-广义左值"></a>glvalue-广义左值</h2><p>广义左值就是左值和将亡值。</p><h2 id="rvalue-右值"><a href="#rvalue-右值" class="headerlink" title="rvalue-右值"></a>rvalue-右值</h2><p>右值（历史上所谓的右值，因为右值可能出现在赋值表达式的右侧）是xvalue、临时对象或其子对象，或者不与对象关联的值。可以理解为，在汇编语句中，使用寄存器保存的值和立即数。</p><h2 id="prvalue-纯右值"><a href="#prvalue-纯右值" class="headerlink" title="prvalue-纯右值"></a>prvalue-纯右值</h2><p>不是xvalue的右值。</p><h2 id="测试一下！"><a href="#测试一下！" class="headerlink" title="测试一下！"></a>测试一下！</h2><p>有如下宏定义，可以表示一个变量的类型；又编写了一些函数，定义一些变量，用于测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LVALUE(...) std::is_lvalue_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_XVALUE(...) std::is_rvalue_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_PRVALUE(...) !std::is_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestFunctionRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br></pre></td></tr></table></figure><p>做出如下测试，结果如下：</p><ol><li>变量<code>a</code>是左值，因为其表示一个对象。</li><li><code>TestFunction</code>是左值，因为其是一个函数。</li><li>字符串是左值，因为在编译阶段，其存放在内存的常量空间里，详见:<a href="https://coder109.github.io/2023/05/23/Linux%E4%B8%8BHello-World%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84/#%E8%A7%A3%E9%87%8A-1">Linux下Hello World是如何输出的</a>。</li><li>对变量<code>a</code>取地址是右值，对<code>b</code>取值是左值。</li><li><code>TestFunction()</code>是纯右值，因为函数返回值存储在对应的寄存器中，是一个临时的值。</li><li><code>this</code>是一个纯右值。</li></ol><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>对于<code>std::move()</code>等方法来说，需要明确区分这几个值的类型。</p><p>详见<a href="https://zhuanlan.zhihu.com/p/402251966">https://zhuanlan.zhihu.com/p/402251966</a>。</p><h1 id="3-STL相关"><a href="#3-STL相关" class="headerlink" title="3. STL相关"></a>3. STL相关</h1><blockquote><p>Algorithms + Data Structures &#x3D; Programs </p><p>——Niklaus Wirth</p></blockquote><p>所有源代码都在64位Arch Linux下查看，所使用的g++版本为13.1.1。</p><p>如果感兴趣，可以查看:<a href="https://love-la.in/1e7Ug5">https://love-la.in/1e7Ug5</a>。</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>STL无非就那几个容器。STL的关键部分为分配器(allocator)，算法(algorithm)，适配器(adapter)，容器(containers)，迭代器(iterator)和仿函数(functor)组成。</p><p>容器是一种数据结构。使用的时候需要先通过分配器在内存中为对应的容器分配空间，接着通过能够访问容器中元素的迭代器将算法应用到容器上。</p><p>适配器允许我们将本无法应用到容器上的算法，改变一下，使之能够应用到容器上，而仿函数则是一个类，内部重载了<code>()</code>运算符，其使我们能够拥有更多对容器的操纵方式，比如说:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; my_list;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    my_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> target_index_iter = <span class="built_in">find_if</span>(my_list.<span class="built_in">begin</span>(), my_list.<span class="built_in">end</span>(), <span class="built_in">bind</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">9</span>));</span><br><span class="line">  cout &lt;&lt; *target_index_iter &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了寻找vector中大于9的元素的功能。</p><p><code>find_if</code>的第三个参数需要一个一元谓词，类似于一个接收一个变量的函数指针，单独编写一个判断是否大于9的函数有些麻烦，我们可以通过适配器+仿函数来简单地达成这个目的。代码中的<code>bind()</code>是一个适配器，允许我们简单的通过二元仿函数<code>greater()</code>来对容器进行操作。我们提前将9绑定为<code>greater()</code>函数的第二个参数，这样<code>bind()</code>返回了一元谓词，符合参数规范要求。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>list</code>本身是一个<strong>双向环形链表</strong>，详情参考<code>&lt;bits/stl_list.h&gt;</code>。显然，不支持随机访问。</p><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p><code>forward_list</code>是个<strong>线性单向链表</strong>。显然，不支持随机访问。</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>vector</code>是一个<strong>可变长的数组</strong>，更具体的来讲，是一个扩张因子为2的<strong>动态表</strong>。这个数据结构在《算法导论》中有提及，作为平摊分析的一个例子来讲解。</p><p>什么是扩张因子为2的动态表？具体来说，您不断地向<code>vector</code>当中插入元素，一旦满了，就在内存中申请<strong>新的</strong>两倍于原先大小的空间。这会造成一定的开销。</p><p>然而，<code>sizeof(vector)</code>的大小并非可变值，而是3个指针的长度，因为其底层定义里，<code>vector</code>类的成员只包含三个指针——<code>begin</code>,<code>end</code>和<code>end_of_storage</code>。</p><p>显然，支持随机访问。</p><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p><code>array</code>是一个<strong>定长数组</strong>。支持随机访问。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>全称为double-ended queue。由一个<code>map</code>和多个<code>vector</code>组成。注意这里的<code>map</code>不是STL的<code>map</code>，更像是<code>vector</code>。<code>deque</code>可以理解为双头队列，也可以近似理解为是一个<code>vector&lt;vector&gt;</code>。</p><p>如果查看源代码，会发现，一个<code>deque</code>类包含四个成员，一个<code>map</code>，一个<code>map_size</code>，和两个迭代器<code>start</code>、<code>finish</code>。<code>map</code>里的每一个单元都指向一个<code>vector</code>，头插的时候，就在单元所对应的第一个有数据的<code>vector</code>的头部插入，尾插就在最后一个有数据的<code>vector</code>的尾部插入。</p><p><code>deque</code>里的迭代器是一个类，有四个部分，<code>first</code>，<code>last</code>，<code>cur</code>和<code>node</code>。前两者指向迭代器所对应<code>vector</code>（也称作缓冲区）的头和尾，<code>cur</code>指向当前数据，<code>node</code>则指向该<code>map</code>中，指向该<code>vector</code>的地址。也就是<code>map</code>里对应的地址。</p><p>看不懂的话，在<code>&lt;bits/stl_deque.h&gt;</code>中，有如下的注释说明：</p><blockquote><ul><li><p>For any nonsingular iterator i:</p><ul><li><p>i.node points to a member of the %map array.  (Yes, you read that correctly:  i.node does not actually point to a node.)  The member of the %map array is what actually points to the node.</p></li><li><p>i.first &#x3D;&#x3D; *(i.node)    (This points to the node (first Tp element).)</p></li><li><p>i.last  &#x3D;&#x3D; i.first + node_size</p></li><li><p>i.cur is a pointer in the range [i.first, i.last).  NOTE: the implication of this is that i.cur is always a dereferenceable pointer, even if i is a past-the-end iterator.</p></li><li><p>Start and Finish are always nonsingular iterators.</p></li></ul></li></ul></blockquote><p>缓冲区大小一般是512，如果一个元素的大小大于512，就让一个缓冲区放1个元素。</p><p>这种设计是为了保证<code>deque</code>表面的连续性，某些情况下，<code>cur</code>指针迭代出当前<code>vector</code>范围，就要通过<code>node</code>进行计算，指向下一个<code>vector</code>的区间内。</p><p>另外，<code>deque</code>的扩容方式和扩张因子为2的动态表一致。</p><p>当指定位置插入的时候，<code>deque</code>会计算，此位置是不是<code>start</code>或者<code>finish</code>，若非，是离<code>start</code>近，还是离<code>finish</code>近，从而进行不同的插入表现。</p><p>允许随机访问。</p><h2 id="queue-x2F-stack"><a href="#queue-x2F-stack" class="headerlink" title="queue&#x2F;stack"></a>queue&#x2F;stack</h2><p><code>queue</code>和<code>stack</code>严格来说不是容器，而是适配器。</p><p>它们底层都是<code>deque</code>，将<code>deque</code>阉割一下就能得到这两种数据结构。双端开口改为一端开口，仅保留部分的<code>push</code>和<code>pop</code>操作即可。二者无法被遍历。</p><p>对于<code>stack</code>，查看<code>&lt;bits/stl_stack.h&gt;</code>:</p><blockquote><p>This is not a true container, but an @e adaptor.  It holds another container, and provides a wrapper interface to that container.  The wrapper is what enforces strict first-in-last-out %stack behavior. The second template parameter defines the type of the underlying sequence&#x2F;container. It defaults to std::deque, but it can be any type that supports @c back, @c push_back, and @c pop_back, such as std::list, std::vector, or an appropriate user-defined type.</p></blockquote><p><code>stack</code>底层可以是<code>list</code>，也可以是<code>vector</code>，也可以是自定义的数据结构，默认是<code>deque</code>。</p><p>对于<code>queue</code>，查看<code>&lt;bits/stl_queue.h&gt;</code>:</p><blockquote><p>This is not a true container, but an @e adaptor.  It holds another container, and provides a wrapper interface to that container.  The wrapper is what enforces strict first-in-first-out %queue behavior. The second template parameter defines the type of the underlying sequence&#x2F;container. It defaults to std::deque, but it can be any type that supports @c front, @c back, @c push_back, and @c pop_front, such as std::list or an appropriate user-defined type.</p></blockquote><p>其底层可以是<code>list</code>，可以是自定义的数据结构，默认是<code>deque</code>。</p><p>有个细节，为什么<code>queue</code>不能用<code>vector</code>做底层结构呢？其实很简单，因为后者没有<code>pop_front()</code>。</p><h2 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h2><p>二者的底层都是<code>红黑树</code>。二者想要表示的都是数学上集合的概念，不同点在于，<code>set</code>里的元素不可以重复，而<code>multiset</code>里的元素可以重复。二者里的数据都是排好序的。在<code>&lt;bits/stl_set.h&gt;</code>中，<code>set</code>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">   <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> set</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如您所见，其默认的排序方式是从小到大排序。<code>multiset</code>也是如此。</p><p>插入、删除、查找的复杂度都是$O(logn)$。</p><h2 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h2><p>二者底层都是<code>红黑树</code>，和<code>set/multiset</code>不同的是，二者存储的数据以键值对的方式存在，排序的时候以键的值为排序准则。</p><h2 id="unordered-map-x2F-unordered-set"><a href="#unordered-map-x2F-unordered-set" class="headerlink" title="unordered_map&#x2F;unordered_set"></a>unordered_map&#x2F;unordered_set</h2><p>底层是<code>哈希表</code>，查找的效率为$O(1)$，最坏为$O(n)$。</p><p>默认的哈希算法是开链法。</p><h1 id="4-简单的小知识"><a href="#4-简单的小知识" class="headerlink" title="4. 简单的小知识"></a>4. 简单的小知识</h1><h2 id="new-x2F-delete-VS-malloc-x2F-free"><a href="#new-x2F-delete-VS-malloc-x2F-free" class="headerlink" title="new&#x2F;delete VS malloc()&#x2F;free()"></a>new&#x2F;delete VS malloc()&#x2F;free()</h2><p>new的时候，先调用malloc()分配空间，然后调用类的构造函数。delete的时候，先调用析构函数，然后调用free()回收空间。</p><h2 id="const-VS-define"><a href="#const-VS-define" class="headerlink" title="const VS #define"></a>const VS #define</h2><p>#define所做的，是简单的替换。在预处理阶段进行处理。</p><p>有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = A;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过预处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><p>有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.i</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;defineTest.c&quot;</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;defineTest.c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于const定义的常量来说，其具有数据类型，也在后续阶段被处理，相对来说更加安全。此外，const也可以在函数内被定义，定义一个局部常量，也更加灵活。</p><p>此外，const也有多种功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">4</span>; <span class="comment">// 常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = &amp;x; <span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = &amp;x; <span class="comment">// 指向非常量变量的指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 成员函数内不可修改类成员值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static的用法"><a href="#static的用法" class="headerlink" title="static的用法"></a>static的用法</h2><ol><li>static可以用来声明静态成员，但是一定要在类外初始化，否则在链接时会报错。</li><li>static也可以用来设定类的静态方法，无须初始化就可以调用这个方法。静态方法无法调用非静态成员变量。</li><li>static可以表明一个普通函数只在当前文件中有效。</li><li>static可以修饰一个变量，在函数内修饰，表明不论函数调用多少次，这个变量只初始化一次；若在函数外修饰，则在程序运行之前就创建该变量。</li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在一个类里面，this可以理解为，指向自己的指针，与此同时，this是一个右值。</p><p>有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_PRVALUE(...) !std::is_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">IS_PRVALUE</span>(<span class="keyword">this</span>) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo* test = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">  test-&gt;<span class="built_in">bar</span>(); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在普通的成员函数<code>Foo::bar()</code>里，this的类型是<code>Foo*</code>，也是一个纯右值。在<code>Foo::test()</code>里，this的类型是<code>const Foo*</code>，这也保证在这种函数里面，没法修改成员变量的值。</p><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>其常用于声明类的构造函数，规避对构造函数的隐性调用和复制初始化。</p><h2 id="与-的用法"><a href="#与-的用法" class="headerlink" title="::与:的用法"></a>::与:的用法</h2><p>总结一下，<code>::</code>有如下用法：</p><ol><li><p>声明所调用变量为全局变量，有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var_g = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> var_sg = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> var_g = <span class="number">20</span>;</span><br><span class="line">  <span class="type">int</span> var_sg = <span class="number">21</span>;</span><br><span class="line">  std::cout &lt;&lt; ::var_g &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">  std::cout &lt;&lt; ::var_sg &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">  std::cout &lt;&lt; var_g &lt;&lt; std::endl; <span class="comment">// 20</span></span><br><span class="line">  std::cout &lt;&lt; var_sg &lt;&lt; std::endl; <span class="comment">// 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于访问命名空间和类下的函数&#x2F;方法，如<code>std::cout</code>或<code>Foo::test()</code>。</p></li></ol><p>而<code>:</code>用法如下：</p><ol><li><p>表示类的继承关系，如<code>class Foo : public Father</code>。</p></li><li><p>用于初始化列表，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> a) : <span class="built_in">i</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Some-OOP-stuff-一些面向对象的理论"><a href="#Some-OOP-stuff-一些面向对象的理论" class="headerlink" title="Some OOP stuff-一些面向对象的理论"></a>Some OOP stuff-一些面向对象的理论</h2><ol><li>有时候面试会问“C++的三大特点”，倒不如问“OOP”的三大特点了，是封装、继承和多态。</li><li>C++的多态有两种：早绑定&#x2F;晚绑定(编译时多态&#x2F;运行时多态，静态多态&#x2F;动态多态)，前者依靠方法的重写，后者则依靠虚函数。对于Java来说，有<code>interface</code>和<code>abstract</code>关键字，而在C++里则没有这两个关键字声明接口和抽象类，这两个功能也好实现，只有纯虚函数的类叫做接口，有纯虚函数的类叫做抽象类。</li><li>阐明几个名词：重写是子类重新写父类的方法；重载是同一个名称函数在同一个类中的，能够接收不同参数的实现；覆盖是指子类实现了父类的虚函数，覆盖了父类的实现。</li><li>由于STL没有虚析构函数，尽量不要继承它——自己写一个适配器就行嘛！</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><code>static_cast</code>，常用于T到各个类型的转换、数值之间的转换。</li><li><code>reinterpret_cast</code>，按位转换，常用于各种指针间的转换。</li><li><code>const_cast</code>，用于将常量转换为变量。</li><li><code>dynamic_cast</code>，可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，也可以转换引用，且检查安全性。</li></ol><h1 id="5-智能指针"><a href="#5-智能指针" class="headerlink" title="5. 智能指针"></a>5. 智能指针</h1><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>翻译自<a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">https://en.cppreference.com/w/cpp/memory/unique_ptr</a>：<code>unique_ptr</code> 是一个智能指针，它通过指针拥有和管理另一个对象，并在 <code>unique_ptr</code> 超出作用域时处置该对象。有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Halo!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;No!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;Foo&gt; p1 = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Nah!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: </span></span><br><span class="line"><span class="comment">// Halo!</span></span><br><span class="line"><span class="comment">// No!</span></span><br><span class="line"><span class="comment">// Nah!</span></span><br></pre></td></tr></table></figure><p>调用完<code>foo()</code>，直接调用生成<code>Foo</code>对象的析构，而不是等到最后再去销毁该对象。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>shared_ptr</code>其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。</p><p>参考:<a href="https://zhuanlan.zhihu.com/p/150555165">https://zhuanlan.zhihu.com/p/150555165</a></p><p>但这种指针会出现循环引用的问题，所以引出了<code>weak_ptr</code>。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>其指向对象，但不改变其引用计数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现一个简单Shell</title>
      <link href="/2023/07/24/C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95Shell/"/>
      <url>/2023/07/24/C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95Shell/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Shell运行的基本逻辑"><a href="#1-Shell运行的基本逻辑" class="headerlink" title="1. Shell运行的基本逻辑"></a>1. Shell运行的基本逻辑</h1><p>Shell一般按照如下的步骤运行：等待状态-获取命令行输入-处理-创建子进程-等待子进程运行结束-等待状态。</p><p>分别来说：</p><ol><li>获取命令行输入可以使用<code>readline()</code>,<code>scanf()</code>之类的函数。</li><li>处理输入，首先要做的是将输入按照分隔符分开，得到一个二维数组。接着，我们要对获得的命令进行判断，判断其是否为内置命令，如果为内置命令，需要执行我们自己编写函数，如果不是内置命令，就要通过<code>fork()</code>创建一个子进程，在子进程中执行非内置命令，父进程等待子进程的结束。</li></ol><h1 id="2-获取输入"><a href="#2-获取输入" class="headerlink" title="2. 获取输入"></a>2. 获取输入</h1><p>读取输入的函数大概如下，一个字符一个字符读取，方便我们控制对应的行为，比如读取到EOF就直接返回等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ReadLine</span><span class="params">(<span class="type">char</span>* buffer)</span> &#123;</span><br><span class="line">  <span class="type">int</span> buffer_pivot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(buffer_pivot == BUFFER_SIZE) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The expression is too long to process.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ERR_EXPR_TOO_LONG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> current_char = getchar();</span><br><span class="line">    <span class="keyword">if</span>(current_char == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">      buffer[buffer_pivot++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current_char == EOF)&#123;</span><br><span class="line">      <span class="keyword">return</span> INPUT_EOF;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer[buffer_pivot++] = current_char;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-处理输入"><a href="#3-处理输入" class="headerlink" title="3. 处理输入"></a>3. 处理输入</h1><p>使用<code>strtok()</code>函数，可以将字符串根据设定的分隔符，分割成各部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>** <span class="title function_">ProcessLine</span><span class="params">(<span class="type">char</span>* command)</span> &#123;</span><br><span class="line">  <span class="type">char</span>** command_tokens = (<span class="type">char</span>**)SafeMalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) * BUFFER_SIZE);</span><br><span class="line">  <span class="type">char</span>* token;</span><br><span class="line">  <span class="type">int</span> command_tokens_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  token = strtok(command, TOKEN_DELIMITER);</span><br><span class="line">  <span class="keyword">while</span>(token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    command_tokens[command_tokens_index++] = token;</span><br><span class="line">    token = strtok(<span class="literal">NULL</span>, TOKEN_DELIMITER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  command_tokens[command_tokens_index] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> command_tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-进程处理"><a href="#4-进程处理" class="headerlink" title="4. 进程处理"></a>4. 进程处理</h1><p>大致如此。之前CSAPP的课设里，执行程序使用的是<code>execve()</code>，用<code>execvp()</code>倒也无所谓，它们的功能都差不多。exec函数族属于”进程替换”的函数族，执行它们不创建新进程，而是将当前进程覆盖掉，执行要执行的程序，这也是我们要创建子进程执行命令的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ExecuteCommand</span><span class="params">(<span class="type">char</span> **token_list)</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> command_pid;</span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(token_list[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="built_in">strcmp</span>(token_list[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Command_cd(token_list);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(token_list[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Command_exit(token_list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  command_pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(command_pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(execvp(token_list[<span class="number">0</span>], token_list) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;Execute Error&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> ERR_FAILED_TO_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(command_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    perror(<span class="string">&quot;Fork Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(token_list);</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现代码雨</title>
      <link href="/2023/07/16/C-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%9B%A8/"/>
      <url>/2023/07/16/C-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0-最终效果"><a href="#0-最终效果" class="headerlink" title="0. 最终效果"></a>0. 最终效果</h1><p>只适用于Linux系统。</p><p><img src="/2023/07/16/C-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%9B%A8/1.png"></p><h1 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h1><p>将每一列分开来处理。</p><p>每一列上半部分暗一些，最下面的字符为白色。</p><h1 id="2-遇到的坑"><a href="#2-遇到的坑" class="headerlink" title="2. 遇到的坑"></a>2. 遇到的坑</h1><h3 id="清屏导致终端闪烁"><a href="#清屏导致终端闪烁" class="headerlink" title="清屏导致终端闪烁"></a>清屏导致终端闪烁</h3><p>不论是调用<code>&lt;ncurses.h&gt;</code>里的<code>clear()</code>函数，还是直接用不优雅的<code>system(&quot;clear&quot;)</code>，在清屏时，都会导致显示的内容闪烁。</p><p>我没有查到什么好的解决方案，我通过使用输出空字符代替清屏来解决这个问题。</p><h3 id="终端尺寸变化导致显示效果不全"><a href="#终端尺寸变化导致显示效果不全" class="headerlink" title="终端尺寸变化导致显示效果不全"></a>终端尺寸变化导致显示效果不全</h3><p><del>Windows下可以使用Hook机制——maybe，我没在Windows下写过复杂的东西——而在Linux下，貌似可以使用类似的信号机制，但是信号的Handler只能传递一个int类型的变量，我还没有想到如何在这种情况下，通过它修改一个类里面的值。</del></p><p><del>我的确可以使用一种不甚优雅的方式：在每次处理列的时候，都去获取一次窗口的长和宽。</del></p><p>可以这样做，设立一个全局变量，当每次收到<code>SIGWINCH</code>信号的时候，就去修改这个变量的值，主函数中每次循环都去根据这个变量的值，调整窗口大小。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><details>    <summary>Matrix.hpp</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATRIX_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Matrix</span>(<span class="type">int</span> show_length = <span class="number">9</span>, <span class="type">int</span> color = <span class="number">0</span>);</span><br><span class="line">  ~<span class="built_in">Matrix</span>();</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ShowColumn</span><span class="params">(<span class="type">int</span> column)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  WINDOW* my_window;</span><br><span class="line">  <span class="type">int</span> row_recorder[<span class="number">2000</span>];</span><br><span class="line">  <span class="type">int</span> window_height;</span><br><span class="line">  <span class="type">int</span> window_width;</span><br><span class="line">  <span class="type">int</span> show_length;</span><br><span class="line">  <span class="type">int</span> color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Matrix.cpp</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment"> * Filename: Matrix.cpp</span></span><br><span class="line"><span class="comment"> * Author: Coder109</span></span><br><span class="line"><span class="comment"> * Date: 2023-07-16 07:20:42</span></span><br><span class="line"><span class="comment"> * Description: Deal with the matrix rain</span></span><br><span class="line"><span class="comment"> *****************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Matrix.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> character_list[] = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYXZ&quot;</span>;</span><br><span class="line"></span><br><span class="line">Matrix::<span class="built_in">Matrix</span>(<span class="type">int</span> show_length, <span class="type">int</span> color) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;show_length = show_length;</span><br><span class="line">  <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;my_window = <span class="built_in">initscr</span>();</span><br><span class="line">  <span class="built_in">cbreak</span>();</span><br><span class="line">  <span class="built_in">noecho</span>();</span><br><span class="line">  <span class="built_in">getmaxyx</span>(<span class="keyword">this</span>-&gt;my_window, <span class="keyword">this</span>-&gt;window_height, <span class="keyword">this</span>-&gt;window_width);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">start_color</span>();</span><br><span class="line">  <span class="built_in">init_pair</span>(<span class="number">1</span>, COLOR_BLUE, COLOR_BLACK);</span><br><span class="line">  <span class="built_in">init_pair</span>(<span class="number">2</span>, COLOR_WHITE, COLOR_BLACK);</span><br><span class="line">  <span class="built_in">init_pair</span>(<span class="number">3</span>, COLOR_BLACK, COLOR_BLACK);</span><br><span class="line">  <span class="built_in">attron</span>(A_BOLD);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;window_width; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;row_recorder[i] = -<span class="built_in">rand</span>() % <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix::~<span class="built_in">Matrix</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Matrix::ShowColumn</span><span class="params">(<span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> curr_row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;row_recorder[column] &gt;= <span class="keyword">this</span>-&gt;window_height + <span class="keyword">this</span>-&gt;show_length) &#123;</span><br><span class="line">    curr_row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;row_recorder[column] = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    curr_row = <span class="keyword">this</span>-&gt;row_recorder[column]++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Output empty char in order to solve the problem:</span></span><br><span class="line">  <span class="comment">// When clearing the screen, the terminal will flicker.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_processing_row = <span class="number">0</span>;</span><br><span class="line">      curr_processing_row &lt; curr_row - <span class="keyword">this</span>-&gt;show_length;</span><br><span class="line">      curr_processing_row++) &#123;</span><br><span class="line">    <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">mvaddch</span>(curr_processing_row, column, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Upper half of the column should be darker, and the bottom char should be white</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_processing_row = curr_row - <span class="keyword">this</span>-&gt;show_length;</span><br><span class="line">      curr_processing_row &lt;= curr_row;</span><br><span class="line">      ++curr_processing_row) &#123;</span><br><span class="line">    <span class="type">char</span> show_char = character_list[std::<span class="built_in">rand</span>() % <span class="built_in">strlen</span>(character_list)];</span><br><span class="line">    <span class="keyword">if</span>(curr_processing_row &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr_processing_row &gt;= <span class="keyword">this</span>-&gt;window_height) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr_processing_row == curr_row) &#123;</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">2</span>));</span><br><span class="line">      <span class="built_in">mvaddch</span>(curr_processing_row, column, show_char);</span><br><span class="line">      <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr_processing_row &lt; curr_row - <span class="keyword">this</span>-&gt;show_length / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">      <span class="built_in">attron</span>(A_DIM);</span><br><span class="line">      <span class="built_in">mvaddch</span>(curr_processing_row, column, show_char);</span><br><span class="line">      <span class="built_in">attroff</span>(A_DIM);</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">      <span class="built_in">mvaddch</span>(curr_processing_row, column, show_char);</span><br><span class="line">      <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Output empty char in order to solve the problem:</span></span><br><span class="line">  <span class="comment">// When clearing the screen, the terminal will flicker.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_processing_row = curr_row + <span class="number">1</span>;</span><br><span class="line">      curr_processing_row &lt; <span class="keyword">this</span>-&gt;window_height;</span><br><span class="line">      curr_processing_row++) &#123;</span><br><span class="line">    <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">mvaddch</span>(curr_processing_row, column, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Matrix::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_column = <span class="number">0</span>; curr_column &lt; window_width; curr_column++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;<span class="built_in">ShowColumn</span>(curr_column)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">refresh</span>();</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">70000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>main.cpp</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/Matrix.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  Matrix *my_matrix = <span class="keyword">new</span> <span class="built_in">Matrix</span>();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    my_matrix-&gt;<span class="built_in">Run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> my_matrix;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux下的问题与解决方案汇总</title>
      <link href="/2023/07/10/Arch-Linux%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/"/>
      <url>/2023/07/10/Arch-Linux%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h1><p>所用版本为10.0.2-1。</p><h2 id="qDebug无输出"><a href="#qDebug无输出" class="headerlink" title="qDebug无输出"></a>qDebug无输出</h2><p>首先，确保引入了<code>&lt;QDebug&gt;</code>头文件，并正确调用<code>qDebug()</code>，接着在“项目-&gt;运行-&gt;环境”中添加QT_ASSUME_STDERR_HAS_CONSOLE&#x3D;1这个环境变量即可。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="内核重装"><a href="#内核重装" class="headerlink" title="内核重装"></a>内核重装</h2><p>当Arch Linux系统突然断电后，有时会出现Kernel Panic或运行不正常的状况，对此，我们不需要重新安装整个系统，只需要重新安装内核即可。</p><p>首先需要一个启动盘，然后在BIOS里将引导方式调为U盘启动，然后在命令行中，先挂载主分区，然后挂载启动分区:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/root_partition /mnt</span><br><span class="line">mount --<span class="built_in">mkdir</span> /dev/efi_system_partition /mnt/boot</span><br></pre></td></tr></table></figure><p>最后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -K /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure><p>接着重新启动系统、更新软件包即可。</p><h1 id="MySQL相关环境"><a href="#MySQL相关环境" class="headerlink" title="MySQL相关环境"></a>MySQL相关环境</h1><p>目前，AUR的mysql包会直接引导安装<code>mariadb</code>或者<code>percona server</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S mariadb</span><br></pre></td></tr></table></figure><p>然后安装mariadb即可。</p><p>接着跟随Arch Wiki的指引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure><p>接着创建平时所用的非root用户，<code>some_pass</code>可修改为自定义的密码:</p><p>首先登陆root用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mariadb -u root -p</span><br></pre></td></tr></table></figure><p>接着创建普通用户，并给予全部权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;iwakura&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;some_pass&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;monty&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="MySQL-Workbench的配置"><a href="#MySQL-Workbench的配置" class="headerlink" title="MySQL Workbench的配置"></a>MySQL Workbench的配置</h1><p>安装MySQL Workbench:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S mysql-workbench</span><br></pre></td></tr></table></figure><p>点击MySQL Connections旁边的小加号，输入对应的用户名，连接即可。</p><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><h2 id="手动换源"><a href="#手动换源" class="headerlink" title="手动换源"></a>手动换源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry <span class="comment"># Show original registry</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/ <span class="comment"># Change registry to official registry</span></span><br></pre></td></tr></table></figure><h2 id="相对简单一点的换源"><a href="#相对简单一点的换源" class="headerlink" title="相对简单一点的换源"></a>相对简单一点的换源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i -g nrm <span class="comment"># Install NPM registry manager</span></span><br><span class="line">nrm use npm </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法&amp;AI】搜索策略</title>
      <link href="/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>搜索，就是通过一定算法对状态空间进行分割，选出所需的解。</p><h1 id="1-搜索算法的形象化描述"><a href="#1-搜索算法的形象化描述" class="headerlink" title="1. 搜索算法的形象化描述"></a>1. 搜索算法的形象化描述</h1><h2 id="抽象为图"><a href="#抽象为图" class="headerlink" title="抽象为图"></a>抽象为图</h2><p>形象化搜索问题有助于我们设计相关的算法。举个例子，对于如下的二阶汉诺塔问题：</p><blockquote><p>设有三根钢针，它们的编号分别是1号、2号和3号。在初始情况下，1号钢针上穿有A、B两个金片，A比B小，A位于B的上面。要求把这两个金片全部移到另一根钢针上，而且规定每次只能移动一个金片，任何时刻都不能使大的位于小的上面。</p></blockquote><p>我们可以做出如下的抽象：</p><p>设定一些状态，用二元组表示，对于任意时刻$k$，任意的二元组$S_k&#x3D;(S_{k0}, S_{k1})$，$S_{k0},S_{k1}$分别表示A和B所在的钢针号。</p><p>接着，我们可以抽象出这样一张图：</p><p><img src="/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/1.png"></p><p>从$(1,1)$到$(2,2)$或$(3,3)$的所有路径都是可行解。</p><h2 id="抽象为树"><a href="#抽象为树" class="headerlink" title="抽象为树"></a>抽象为树</h2><p>这种抽象方法很简单，程序也易于编写，思想是：从起点开始，将所有的可能节点列为子节点。</p><p>但是，这种方法会导致抽象出来的结果出现大量重复的结构。</p><h2 id="与或树"><a href="#与或树" class="headerlink" title="与或树"></a>与或树</h2><p>一个问题，可以被分解为不同的部分，解决所有部分也就解决了该问题；可以被分割成不同的等价的子问题，解决任一子问题，也就相当于解决了该问题。当这两种分割方式同时存在时，就可以使用与或树表示。</p><p>与或树里包含着几种节点：</p><ul><li>叶子节点</li><li>与节点：与节点代表的问题被分割成很多部分。</li><li>或节点：或节点代表的问题被分割成很多等价的子问题。</li></ul><p>看个例子吧：</p><p><img src="https://img2018.cnblogs.com/i-beta/1358881/201912/1358881-20191218163659477-326368179.png" alt="img"></p><p>叶节点用弧表示的，是与节点；不带弧的，是或节点。根节点引出的“2”“3”两个节点就是与节点。</p><h1 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2. 深度优先搜索"></a>2. 深度优先搜索</h1><p>若能够将问题抽象为图，便可以应用图论的相关算法，深度优先搜索(DFS)便是其中一个。它可以用来搜索一条从起点到终点的路径。</p><p>若想进行深度优先搜索，则需要用到栈。</p><p>该算法的思想是，逐条探寻可行路径。</p><p>该算法步骤如下：</p><ol><li>从起点开始，沿着任意一条边探索下去。将探索到的点入栈，并将其标记为探索过的点。</li><li>若探索到一个顶点，该顶点还有未被探索过的后继点，则将该后继点入栈，做标记。若该顶点的所有后继点都被探寻过了，则将该点出栈。</li><li>若探索到最后还有没探索到的点，则表明该图非连通图，则选择任意一个未被探索过的点当作起点，回到步骤1。</li></ol><p>拿一个问题来说：</p><p><a href="https://www.luogu.com.cn/problem/P1706">洛谷 - P1706 全排列问题</a></p><p>问题摘录如下：</p><blockquote><p>按照字典序输出自然数 1 到 n 所有不重复的排列，即 n 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。</p></blockquote><p>C语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> totalLayer;</span><br><span class="line"><span class="type">int</span> answer[<span class="number">10</span>], used[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> currentLayer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(currentLayer == totalLayer) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; currentLayer; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, answer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalLayer; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i+<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            answer[currentLayer] = i+<span class="number">1</span>;</span><br><span class="line">            used[i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            dfs(currentLayer+<span class="number">1</span>);</span><br><span class="line">            used[i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fen ge</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;totalLayer);</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题中，将问题抽象为森林，对于三层的情况，两棵树如下：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/7293.png"></p><p><img src="https://cdn.luogu.com.cn/upload/pic/7294.png" alt="img"></p><p>在<code>dfs()</code>函数中，先判断是否为应该输出答案的状态，若非，则一层一层的探寻可行的状态。</p><h1 id="3-广度优先搜索"><a href="#3-广度优先搜索" class="headerlink" title="3. 广度优先搜索"></a>3. 广度优先搜索</h1><p>广度优先搜索(BFS)需要用到队列。</p><p>该算法思想是：从起点开始不断扩散，寻找可行解。</p><p>该算法步骤为：从起点开始，将所有未探索的后继点加入队列，将起点出队。重复此步骤。</p><h1 id="3-5-双向搜索"><a href="#3-5-双向搜索" class="headerlink" title="3.5 双向搜索"></a>3.5 双向搜索</h1><p>您也可以从起点、终点同时开始深搜、广搜，能一定程度上降低复杂度。</p><h1 id="4-代价一致搜索"><a href="#4-代价一致搜索" class="headerlink" title="4. 代价一致搜索"></a>4. 代价一致搜索</h1><p>在广度优先搜索的步骤中，我们假定每次拓展都是等代价的，这样我们可以同时拓展未探索的节点。然而在实际生活中，对于不同的节点，扩展的代价往往不同。那么我们先设定拓展节点的代价，接着每次拓展时，都拓展总代价最小的那一个节点。代价可以通过如下的公式计算：</p><p>我们假设$g(n_1)$代表从初始节点到$n_1$节点的路径代价，$c(n_1,n_2)$是从$n_1$到$n_2$的代价，那么有：<br>$$<br>g(n_2)&#x3D;g(n_1)+c(n_1,n_2)<br>$$<br>举个例子，对于如下的图：</p><p><img src="/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/2.png"></p><p>假设A为起点，E为终点，搜索步骤如下：</p><ol><li>先探索A。</li><li>探索C，因为A到C的代价为1，A到B代价为3。</li><li>探索B，因为若探索D，代价为4，探索B代价为3。</li><li>探索D。</li><li>探索E，探索到了终点，程序终止。</li></ol><p>该方法探索到的路径一定是代价最小的路径。</p><h1 id="5-贪婪最佳优先搜索"><a href="#5-贪婪最佳优先搜索" class="headerlink" title="5. 贪婪最佳优先搜索"></a>5. 贪婪最佳优先搜索</h1><p>上面所提到的搜索方法都是无信息的搜索方式，即没有任何信息，直接开始搜索。</p><p>从该搜索方式开始，都属于有信息的搜索方式。</p><p>和代价一致搜索略有区别，该搜索方法的代价为到目标节点的剩余距离。每次扩展，只扩展代价最小的子节点。</p><p>同样对于上面这张图，探索步骤如下：</p><ol><li>先探索A。</li><li>探索C。</li><li>探索D。</li><li>探索E。</li></ol><p>该方法没法保证最终能够得到路径，假设能得到路径，也没法保证最佳性。</p><h1 id="6-A-算法"><a href="#6-A-算法" class="headerlink" title="6. A*算法"></a>6. A*算法</h1><p>代价一致搜索考虑的是已经走过的距离，贪婪最佳优先搜索算法考虑的是余下的距离，而A*算法则将这两种算法结合起来。</p><p>该算法中，节点$n_1$代价函数为：<br>$$<br>f(n_1) &#x3D; g(n_1)+h(n_1)<br>$$<br>其中$f(n_1)$是节点$n_1$的代价函数，$g(n_1)$是起始节点到节点$n_1$走过的距离，$h(n_1)$是节点$n_1$到目标节点的估计代价。</p><p>如您所见，估计代价函数是很重要的，设定估计代价函数时，一定要保证估计代价要小于等于实际的代价。过高地估计，有可能会让算法错误地放弃真实的最短路径。</p><h1 id="7-博弈搜索"><a href="#7-博弈搜索" class="headerlink" title="7. 博弈搜索"></a>7. 博弈搜索</h1><p>博弈搜索主要讨论在确定的、全局可观察的、竞争对手轮流行动的对抗搜索两人对决游戏。</p><h2 id="极小极大分析法"><a href="#极小极大分析法" class="headerlink" title="极小极大分析法"></a>极小极大分析法</h2><p>对于博弈问题，可以生成一个与或树。与节点、或节点交替层级出现。奇数层为己方先手，偶数层为对方先手。此外，我们还有一个代价函数，假定为对你的有利程度。或节点表示己方可选的下法，与节点则表明我需要考虑对方所有可能的落子方法。</p><p>利用极小极大分析法，我们需要从叶子节点向上推导，对“或”节点, 选其子节点中一个最大的得分作为父节点的得分；对“与”节点, 选其子节点中一个最小的得分作为父节点的得分。奇数层节点（我方节点）总是会选择赢面最大的子节点状态，而偶数层（对方节点）总是会选择我方赢面最小的的子节点状态。</p><h2 id="Alpha-Beta剪枝"><a href="#Alpha-Beta剪枝" class="headerlink" title="Alpha-Beta剪枝"></a>Alpha-Beta剪枝</h2><p>极大极小分析法要分析的节点太多了，如果能有一种算法剪去一些枝，则能一定程度上降低复杂度。</p><p>偷个懒，引用一下别人的文章，您能在参考资料中找到原文：</p><blockquote><p>(1) 对于一个与节点MIN, 若能估计出其倒推值的上确界β,并且这个β值不大于MIN的父节点(一定是或节点)的估计倒推值的下确界α,即α≥β, 则就不必再扩展该MIN节点的其余子节点了(因为这些节点的估值对MIN父节点的倒推值已无任何影响了)。这一过程称为α剪枝。</p><p>(2) 对于一个或节点MAX, 若能估计出其倒推值的下确界α, 并且这个α值不小于MAX的父节点(一定是与节点)的估计倒推值的上确界β, 即α≥β,则就不必再扩展该MAX节点的其余子节点了(因为这些节点的估值对MAX父节点的倒推值已无任何影响了)。 这一过程称为β剪枝。</p></blockquote><p>所谓MIN节点，就是与节点。</p><h2 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h2><p>我们也可以用类似抽样的方法进行搜索。</p><p>该方法由四个步骤组成：</p><ol><li>选择</li><li>拓展</li><li>模拟</li><li>反向传播</li></ol><p>最开始，我们将需要决策的局面设置为根节点。对于蒙特卡洛搜索树中的每一个节点，都包含着三个信息：</p><ol><li>该节点代表的局面。</li><li>该节点被访问的次数。</li><li>累积评分。</li></ol><p>同时，节点可以被分成三类：</p><ol><li>被完全评估过的节点。拿国际象棋举例，也就是对于该节点来说，所有的可能走法都被评估过了。</li><li>未被完全评估的节点。拿国际象棋举例，也就是对于该节点来说，还有一些落子方法没有被评估过。</li><li>结束节点。拿国际象棋举例，也就是对于该节点来说，一方将另一方将死。</li></ol><p>在选择阶段，我们从根节点开始，逐步评估子节点，对于上面的三种节点，分别采取不同的策略：</p><ol><li>若节点被完全评估，则计算所有子节点的评分，则将评分最高的子节点设为待评估节点，进行选择操作。</li><li>若节点未被完全评估，则该节点设为待评估节点，进行拓展操作。</li><li>若节点为结束节点，则该节点设为待评估节点，进行反向传播操作。</li></ol><p>在拓展阶段，我们在待评估节点的基础上，随机选择一个动作A，在搜索树中创建一个子节点，该子节点表示待评估节点经过动作A所转换得到的局面，接着进行模拟操作。</p><p>在模拟阶段，我们在上一步得到的子节点的基础上，随机进行游戏，直到得到一个结束节点，若结束节点代表己方被将死，则视为失败，反之视为成功。接着进行反向传播操作。</p><p>在反向传播阶段，从结束节点开始，回溯更新父节点的评分值。</p><p>当算法结束时，访问次数越高的节点往往是最佳的选择。</p><p>计算评分，常常使用<strong>应用到搜索树上的上限置信区间算法UCT</strong>，公式如下：<br>$$<br>UCT&#x3D;\frac{w_i}{n_i}+C\sqrt{\frac{lnN_i}{n_i}}<br>$$<br>其中$w_i$表示选择$i$节点的胜利次数，$n_i$是$i$节点的模拟次数，$C$是一个平衡系数，$N_i$是全部的模拟次数。该公式的形式，来自正态分布的置信区间的计算公式，您可以在参考资料中查看相关的资料。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://oi-wiki.org/">OI Wiki</a></p><p><a href="https://www.cnblogs.com/wkfvawl/p/12066647.html">博弈树搜索</a></p><p><a href="https://zhuanlan.zhihu.com/p/333348915">【最佳实战】蒙特卡洛树搜索算法</a></p><p><a href="https://www.cnblogs.com/pinard/p/10470571.html">强化学习(十八) 基于模拟的搜索与蒙特卡罗树搜索(MCTS) </a></p><p><a href="https://zhuanlan.zhihu.com/p/140194206">怎样全面理解95%置信区间</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】素数筛</title>
      <link href="/2023/06/01/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2023/06/01/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文探讨寻找从2到n所有质数的几种方法，并在复杂度上进行比较。</p><h1 id="1-常规的寻找质数法"><a href="#1-常规的寻找质数法" class="headerlink" title="1. 常规的寻找质数法"></a>1. 常规的寻找质数法</h1><p>思想：对于每一个数字，从2开始枚举到该数字的算术平方根处，若存在某个枚举到的数能整除当前数字，则该数字非质数。</p><p>C语言代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> isPrime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    isPrime = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j*j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            isPrime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isPrime) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该寻找方法，复杂度为$O(n\sqrt{n})$。</p><h1 id="2-埃拉托斯特尼筛法"><a href="#2-埃拉托斯特尼筛法" class="headerlink" title="2. 埃拉托斯特尼筛法"></a>2. 埃拉托斯特尼筛法</h1><p>思想：</p><ol><li>维护一个表，表项为0代表该表项下标是质数。</li><li>已知2是最小的质数，在表中将所有以2的倍数为下标的表项标注为1，<strong>寻找表项为0的最小下标，该下标为一个质数</strong>。</li><li>标记以该质数倍数为下标的表项，接着寻找表项为0的最小下标，该下标同样也是一个质数。</li><li>回到第二步，做类似操作。</li></ol><p>C语言代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prime[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!prime[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i*i; j &lt;= n; j+=i) &#123; <span class="comment">//初始化j为i*i, 因为其为未被筛过的，且以i为因子的合数</span></span><br><span class="line">            prime[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该寻找方法，复杂度为$O(nloglogn)$。根据素数定理，可以通过积分算出这个复杂度，详情参考<a href="https://www.zhihu.com/question/35112789">这里</a>。</p><p>该方法存在问题，比如在遍历到2、3时，下标为12的表项，都会经历一次赋值操作。</p><h1 id="3-欧拉筛法"><a href="#3-欧拉筛法" class="headerlink" title="3. 欧拉筛法"></a>3. 欧拉筛法</h1><p>思想：</p><ol><li>维护一个记录表，表项为0代表该表项下标是质数。维护一个质数表，装质数本身。</li><li>已知2是最小的质数，放入质数表。</li><li>从2开始，每个数都与质数表里的数相乘，将记录表对应下标表项修改为1。</li><li>若遍历到某个数，能被质数表中某一质数整除，则回到第二步，做类似操作。</li></ol><p>C语言程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> isNotPrime[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> primeList[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isNotPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            primeList[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; count &amp;&amp; i*primeList[j] &lt;= n; j++) &#123;</span><br><span class="line">            isNotPrime[primeList[j]*i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primeList[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该寻找方法，复杂度为$O(n)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言拾遗</title>
      <link href="/2023/05/30/C%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/"/>
      <url>/2023/05/30/C%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我平时常用C写一些自用小工具，凯撒密码破解器啦，辅助包管理器啦……但也发现了许多C语言中，自己一直忽略的小细节。</p><h1 id="1-获取带任意多空格的字符串"><a href="#1-获取带任意多空格的字符串" class="headerlink" title="1. 获取带任意多空格的字符串"></a>1. 获取带任意多空格的字符串</h1><p>如果缓冲区内有换行符，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getchar(); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, buffer);</span><br></pre></td></tr></table></figure><p>若无，则将第一句去掉。第二行代码中间的正则表达式意思是，遇到换行符，则停止读取。</p><p><code>scanf()</code>蛮危险，也可以使用逐个字符读取的方法。</p><h1 id="2-fflush-stdout"><a href="#2-fflush-stdout" class="headerlink" title="2. fflush(stdout)"></a>2. fflush(stdout)</h1><p>当<code>printf()</code>的行为出现异常，比如：</p><ul><li>打印到屏幕上的顺序出现颠倒、错乱。</li><li>输出了本不应该输出的字符。</li></ul><p>试试在代码中的相应部分添加<code>fflush(stdout)</code>。上述两个异常，第一个异常原因未知。第二个的原因是缓冲区太小，内容太多导致溢出。</p><p><code>fflush()</code>说明如下：</p><blockquote><p>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the stream’s buffer to the associated output device.</p><p>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</p><p>If stream is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</p></blockquote><p>这里提到的一点很重要，<code>fflush(stdin)</code>是一个UB(Undefined Behavior，未定义行为)，如果需要清除输入缓冲区里的内容，建议具体问题具体分析，一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FlushStdin</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">while</span>((c = getchar()) != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-EOF和feof"><a href="#3-EOF和feof" class="headerlink" title="3. EOF和feof()"></a>3. EOF和feof()</h1><p>当判断是否是文件结尾的时候，不要使用如下的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_character == EOF</span><br></pre></td></tr></table></figure><p>要使用如下的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feof(current_character) != <span class="number">0</span></span><br></pre></td></tr></table></figure><p>因为EOF代表-1，而有的文件结尾不是-1。注意，<code>feof()</code>若判断为文件结尾，返回非0值。</p><h1 id="4-switch…case…与if…else…效率比较"><a href="#4-switch…case…与if…else…效率比较" class="headerlink" title="4. switch…case…与if…else…效率比较"></a>4. switch…case…与if…else…效率比较</h1><p>前者效率高，因为前者在汇编层面依靠跳转表实现，先判断值，随后直接判断跳转到哪里。后者则通过生成一串判断指令+条件跳转、非条件跳转指令实现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/dongshuaishuai/p/13181899.html">C语言，如何读取带空格的字符串 - 小白一枚</a></p><p><a href="https://en.cppreference.com/w/c/io/fflush">cppreference - fflush()</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Hello World是如何输出的</title>
      <link href="/2023/05/23/Linux%E4%B8%8BHello-World%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84/"/>
      <url>/2023/05/23/Linux%E4%B8%8BHello-World%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近开了一门名为“计算机系统”的课，以卡内基梅隆大学的《深入理解计算机系统》为教材，讲解偏向底层的一些知识：浮点数具体的表示方法、预处理编译汇编链接具体发生什么……这门课的大作业要求我们跟随“预处理-编译-汇编-链接-进程管理”的路线，写一下“Linux下Hello World是如何输出的”。</p><p>然而在写大作业的时候，我还没有复习，上课也没有认真听，东拼西凑写出来了一篇文章。事到如今，差不多把教材里的知识点都掌握了，那就认真写一遍吧。</p><p>上课挺没意思的。说实话。</p><h1 id="0-源程序"><a href="#0-源程序" class="headerlink" title="0. 源程序"></a>0. 源程序</h1><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>预处理阶段，编译器主要对宏定义进行一些处理。比如，引入一些头文件、定义一些宏变量等。</p><p>后缀为.c的源程序文件，通过预处理，可以生成后缀名为.i的预处理文件。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>.i文件部分输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/bits/types/__mbstate_t.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">13</span> <span class="string">&quot;/usr/include/bits/types/__mbstate_t.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> __count;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __wch;</span><br><span class="line">    <span class="type">char</span> __wchb[<span class="number">4</span>];</span><br><span class="line">  &#125; __value;</span><br><span class="line">&#125; <span class="type">__mbstate_t</span>;</span><br><span class="line"># <span class="number">6</span> <span class="string">&quot;/usr/include/bits/types/__fpos_t.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">fwrite</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,</span></span><br><span class="line"><span class="params">        <span class="type">size_t</span> __n, FILE *__restrict __s)</span>;</span><br><span class="line"># <span class="number">702</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">fread_unlocked</span> <span class="params">(<span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,</span></span><br><span class="line"><span class="params">         <span class="type">size_t</span> __n, FILE *__restrict __stream)</span> ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">fwrite_unlocked</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,</span></span><br><span class="line"><span class="params">          <span class="type">size_t</span> __n, FILE *__restrict __stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fseek</span> <span class="params">(FILE *__stream, <span class="type">long</span> <span class="type">int</span> __off, <span class="type">int</span> __whence)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span> <span class="params">(FILE *__stream)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rewind</span> <span class="params">(FILE *__stream)</span>;</span><br><span class="line"># <span class="number">736</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fseeko</span> <span class="params">(FILE *__stream, <span class="type">__off_t</span> __off, <span class="type">int</span> __whence)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">__off_t</span> <span class="title function_">ftello</span> <span class="params">(FILE *__stream)</span> ;</span><br><span class="line"># <span class="number">760</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fgetpos</span> <span class="params">(FILE *__restrict __stream, <span class="type">fpos_t</span> *__restrict __pos)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fsetpos</span> <span class="params">(FILE *__stream, <span class="type">const</span> <span class="type">fpos_t</span> *__pos)</span>;</span><br><span class="line"># <span class="number">786</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clearerr</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">feof</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ferror</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clearerr_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">feof_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ferror_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">perror</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__s)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fileno</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fileno_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"># <span class="number">823</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pclose</span> <span class="params">(FILE *__stream)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="title function_">popen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__command, <span class="type">const</span> <span class="type">char</span> *__modes)</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((__malloc__))</span> __<span class="title function_">attribute__</span> <span class="params">((__malloc__ (pclose, <span class="number">1</span>)))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">ctermid</span> <span class="params">(<span class="type">char</span> *__s)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((__access__ (__write_only__, <span class="number">1</span>)))</span>;</span><br><span class="line"># <span class="number">867</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">flockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ftrylockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">885</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __uflow (FILE *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br><span class="line"># <span class="number">909</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，预处理后的文件引入了许多结构体、许多函数。我们编写的主函数，则位于这个文件的末尾。</p><p>此外，有很多，类似于这样的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">885</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这些语句标记了源文件和代码行来自于哪个头文件、哪一行。您可以参考gcc的<a href="http://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html">官方文档</a>获取更多信息。</p><h1 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>将程序语言转换为汇编语言。</p><p>通过编译，.i文件可以生成.s文件。</p><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -S hello.c</span><br></pre></td></tr></table></figure><p>这两种生成<code>hello.s</code>的方法是等价的，最后的结果没有任何差异。您可以通过<code>diff</code>命令来检查。</p><h2 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h2><p><code>hello.s</code>文件输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;hello.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;Hello world!&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq$16, %rsp</span><br><span class="line">movl%edi, -4(%rbp)</span><br><span class="line">movq%rsi, -16(%rbp)</span><br><span class="line">leaq.LC0(%rip), %rax</span><br><span class="line">movq%rax, %rdi</span><br><span class="line">callputs@PLT</span><br><span class="line">movl$0, %eax</span><br><span class="line">leave</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (GNU) 13.1.1 20230429&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>该文件涉及到的知识点很多。</p><ul><li><code>.file</code>，表明了该.s文件的源程序文件名。</li><li><code>.text</code>，表明代码节的开启，每个节的作用，在2.5节将进行解释。</li><li><code>.section .rodata</code>，代表定义一个只读的数据节。</li><li><code>.LC0</code>，也就是<code>local constant 0</code>，局部常量。</li><li><code>.string</code>，声明了一个字符串。</li><li><code>.globl main</code>，声明了main是一个全局符号。</li><li><code>.type A, B</code>，声明了<code>A</code>为<code>B</code>类型。</li><li><code>.LFB0 .LFE0</code>，全称分别为<code>Local Function Begins</code>，<code>Local Function Ends</code>，代表局部函数的开始和结束。</li><li><code>.size</code>，表明main符号的尺寸。</li><li><code>.ident</code>，表明编译器版本。</li><li><code>.section.note.GNU-stack,&quot;&quot;,@progbits</code>，意思是这个segment会被标记为 “非可执行栈”，引用自<a href="https://www.jianshu.com/p/e385ff61dd7c">简书</a>。</li><li><code>cfi</code>，即<code>Call Frame Information</code>，以之开头的一些指令和栈相关。</li></ul><h1 id="2-5-汇编与内存相关知识"><a href="#2-5-汇编与内存相关知识" class="headerlink" title="2.5 汇编与内存相关知识"></a>2.5 汇编与内存相关知识</h1><p>我们现在所使用的是AT&amp;T汇编指令系统。</p><p>该指令系统的部分特点是：</p><ul><li><p>立即数，也就是汇编指令中的数字，前面需要加上美元符号。比如<code>$1</code>、<code>$5</code>等。</p></li><li><p>寄存器，需要在前面加上百分号。比如<code>%rbp</code>,<code>%rax</code>等。如果寄存器加上括号，比如<code>(%rax)</code>代表间接寻址，也就是先从<code>rax</code>里取一个地址，在去内存中根据该地址寻找数据。</p></li><li><p>指令后需要加一个标记，比如<code>pushq</code>、<code>movq</code>最后的<code>q</code>，和<code>movl</code>最后的<code>l</code>。标记有四种b,w,l,q，分别代表操作的数据长度为1，2，4，8字节。</p></li><li><p>向函数中传递参数，前六个参数分别存入<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>寄存器中，其他参数入栈。返回值存入<code>rax</code>寄存器中。</p></li></ul><p>当程序运行时，内存布局如下：</p><ul><li>栈：存储局部变量、函数参数等。</li><li>堆：存储动态分配的内容。</li><li>数据段：存储全局变量、static变量、字符串。</li><li>代码段：存储只读、可执行的机器指令。</li></ul><p>当程序编译时，各内容布局如下：</p><ul><li><code>.text</code>节：存储代码。</li><li><code>.rodata</code>节：存储只读数据（<code>printf</code>的格式串等）。</li><li><code>.data</code>节：存储数据和已经初始化的全局与静态变量。</li><li><code>.bss</code>节：存储为初始化的全局变量。</li><li><code>.symtab</code>节：存储符号表。</li><li>…</li></ul><h1 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编"></a>3. 汇编</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>将汇编语言转换为机器语言。</p><p>通过汇编，.s文件会生成.o文件。</p><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><h2 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h2><p>最终生成一个二进制文件，而这个文件直接通过<code>cat</code>输出，没办法被阅读。需要反汇编，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -D hello.o</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:55                   push   %rbp</span><br><span class="line">   1:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   4:48 83 ec 10          sub    $0x10,%rsp</span><br><span class="line">   8:89 7d fc             mov    %edi,-0x4(%rbp)</span><br><span class="line">   b:48 89 75 f0          mov    %rsi,-0x10(%rbp)</span><br><span class="line">   f:48 8d 05 00 00 00 00 lea    0x0(%rip),%rax        # 16 &lt;main+0x16&gt;</span><br><span class="line">  16:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  19:e8 00 00 00 00       call   1e &lt;main+0x1e&gt;</span><br><span class="line">  1e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  23:c9                   leave</span><br><span class="line">  24:c3                   ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.rodata&gt;:</span><br><span class="line">   0:48                   rex.W</span><br><span class="line">   1:65 6c                gs insb (%dx),%es:(%rdi)</span><br><span class="line">   3:6c                   insb   (%dx),%es:(%rdi)</span><br><span class="line">   4:6f                   outsl  %ds:(%rsi),(%dx)</span><br><span class="line">   5:20 77 6f             and    %dh,0x6f(%rdi)</span><br><span class="line">   8:72 6c                jb     76 &lt;main+0x76&gt;</span><br><span class="line">   a:64 21 00             and    %eax,%fs:(%rax)</span><br><span class="line"></span><br><span class="line">Disassembly of section .comment:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.comment&gt;:</span><br><span class="line">   0:00 47 43             add    %al,0x43(%rdi)</span><br><span class="line">   3:43 3a 20             rex.XB cmp (%r8),%spl</span><br><span class="line">   6:28 47 4e             sub    %al,0x4e(%rdi)</span><br><span class="line">   9:55                   push   %rbp</span><br><span class="line">   a:29 20                sub    %esp,(%rax)</span><br><span class="line">   c:31 33                xor    %esi,(%rbx)</span><br><span class="line">   e:2e 31 2e             cs xor %ebp,(%rsi)</span><br><span class="line">  11:31 20                xor    %esp,(%rax)</span><br><span class="line">  13:32 30                xor    (%rax),%dh</span><br><span class="line">  15:32 33                xor    (%rbx),%dh</span><br><span class="line">  17:30 34 32             xor    %dh,(%rdx,%rsi,1)</span><br><span class="line">  1a:39 00                cmp    %eax,(%rax)</span><br><span class="line"></span><br><span class="line">Disassembly of section .note.gnu.property:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.note.gnu.property&gt;:</span><br><span class="line">   0:04 00                add    $0x0,%al</span><br><span class="line">   2:00 00                add    %al,(%rax)</span><br><span class="line">   4:20 00                and    %al,(%rax)</span><br><span class="line">   6:00 00                add    %al,(%rax)</span><br><span class="line">   8:05 00 00 00 47       add    $0x47000000,%eax</span><br><span class="line">   d:4e 55                rex.WRX push %rbp</span><br><span class="line">   f:00 02                add    %al,(%rdx)</span><br><span class="line">  11:00 01                add    %al,(%rcx)</span><br><span class="line">  13:c0 04 00 00          rolb   $0x0,(%rax,%rax,1)</span><br><span class="line">...</span><br><span class="line">  1f:00 01                add    %al,(%rcx)</span><br><span class="line">  21:00 01                add    %al,(%rcx)</span><br><span class="line">  23:c0 04 00 00          rolb   $0x0,(%rax,%rax,1)</span><br><span class="line">  27:00 01                add    %al,(%rcx)</span><br><span class="line">  29:00 00                add    %al,(%rax)</span><br><span class="line">  2b:00 00                add    %al,(%rax)</span><br><span class="line">  2d:00 00                add    %al,(%rax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Disassembly of section .eh_frame:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.eh_frame&gt;:</span><br><span class="line">   0:14 00                adc    $0x0,%al</span><br><span class="line">   2:00 00                add    %al,(%rax)</span><br><span class="line">   4:00 00                add    %al,(%rax)</span><br><span class="line">   6:00 00                add    %al,(%rax)</span><br><span class="line">   8:01 7a 52             add    %edi,0x52(%rdx)</span><br><span class="line">   b:00 01                add    %al,(%rcx)</span><br><span class="line">   d:78 10                js     1f &lt;.eh_frame+0x1f&gt;</span><br><span class="line">   f:01 1b                add    %ebx,(%rbx)</span><br><span class="line">  11:0c 07                or     $0x7,%al</span><br><span class="line">  13:08 90 01 00 00 1c    or     %dl,0x1c000001(%rax)</span><br><span class="line">  19:00 00                add    %al,(%rax)</span><br><span class="line">  1b:00 1c 00             add    %bl,(%rax,%rax,1)</span><br><span class="line">  1e:00 00                add    %al,(%rax)</span><br><span class="line">  20:00 00                add    %al,(%rax)</span><br><span class="line">  22:00 00                add    %al,(%rax)</span><br><span class="line">  24:25 00 00 00 00       and    $0x0,%eax</span><br><span class="line">  29:41 0e                rex.B (bad)</span><br><span class="line">  2b:10 86 02 43 0d 06    adc    %al,0x60d4302(%rsi)</span><br><span class="line">  31:60                   (bad)</span><br><span class="line">  32:0c 07                or     $0x7,%al</span><br><span class="line">  34:08 00                or     %al,(%rax)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行说明了该文件为ELF文件，ELF即Executable and Linkable Format，可执行可链接文件格式。和上一步输出得到的文件相比，本文件有如下几个特点：</p><ol><li><code>call</code>指令后面是具体的地址，而非抽象的文件名。</li><li>开始使用十六进制操作数。</li><li>出现了很多节，起始地址都为0。</li><li>…</li></ol><h1 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>一个程序可能有很多个模块，比如假设一个程序由三个源文件组成，其中第一个文件中的很多变量可能在第二个文件中定义。和<code>#include</code>引入头文件不同，链接一般是将多个<code>.o</code>文件拼凑起一个完整的程序。</p><p>可以在编译时链接，也可以在运行时通过<code>dlopen()</code>等函数动态链接一些其他文件，在Windows下，动态链接的是动态链接表<code>.dll</code>文件，在Linux下，动态链接的是共享库文件<code>.so</code>。</p><p>链接分两个步骤：符号解析和重定位，前者解释所有的符号，将每一个符号与一个解释关联起来，所谓符号，要么是函数名，要么是变量；后者则给这些符号一个安身之所，定位到一个绝对内存位置。</p><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><p>通过链接器<code>ld</code>链接即可。本例可以通过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/crt1.o /usr/lib/crti.o hello.o /usr/lib/libc.so /usr/lib/crtn.o</span><br></pre></td></tr></table></figure><p>进行编译时链接。</p><h2 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h2><p>通过反编译，链接后的文件部分输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0000000000400458 &lt;.gnu.version_r&gt;:</span><br><span class="line">  400458:01 00                add    %eax,(%rax)</span><br><span class="line">  40045a:02 00                add    (%rax),%al</span><br><span class="line">  40045c:18 00                sbb    %al,(%rax)</span><br><span class="line">  40045e:00 00                add    %al,(%rax)</span><br><span class="line">  400460:10 00                adc    %al,(%rax)</span><br><span class="line">  400462:00 00                add    %al,(%rax)</span><br><span class="line">  400464:00 00                add    %al,(%rax)</span><br><span class="line">  400466:00 00                add    %al,(%rax)</span><br><span class="line">  400468:75 1a                jne    400484 &lt;_init-0xb7c&gt;</span><br><span class="line">  40046a:69 09 00 00 03 00    imul   $0x30000,(%rcx),%ecx</span><br><span class="line">  400470:22 00                and    (%rax),%al</span><br><span class="line">  400472:00 00                add    %al,(%rax)</span><br><span class="line">  400474:10 00                adc    %al,(%rax)</span><br><span class="line">  400476:00 00                add    %al,(%rax)</span><br><span class="line">  400478:b4 91                mov    $0x91,%ah</span><br><span class="line">  40047a:96                   xchg   %eax,%esi</span><br><span class="line">  40047b:06                   (bad)</span><br><span class="line">  40047c:00 00                add    %al,(%rax)</span><br><span class="line">  40047e:02 00                add    (%rax),%al</span><br><span class="line">  400480:2e 00 00             cs add %al,(%rax)</span><br><span class="line">  400483:00 00                add    %al,(%rax)</span><br><span class="line">  400485:00 00                add    %al,(%rax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Disassembly of section .rela.dyn:</span><br><span class="line"></span><br><span class="line">0000000000400488 &lt;.rela.dyn&gt;:</span><br><span class="line">  400488:d8 3f                fdivrs (%rdi)</span><br><span class="line">  40048a:40 00 00             rex add %al,(%rax)</span><br><span class="line">  40048d:00 00                add    %al,(%rax)</span><br><span class="line">  40048f:00 06                add    %al,(%rsi)</span><br><span class="line">  400491:00 00                add    %al,(%rax)</span><br><span class="line">  400493:00 01                add    %al,(%rcx)</span><br><span class="line">...</span><br><span class="line">  40049d:00 00                add    %al,(%rax)</span><br><span class="line">  40049f:00 e0                add    %ah,%al</span><br><span class="line">  4004a1:3f                   (bad)</span><br><span class="line">  4004a2:40 00 00             rex add %al,(%rax)</span><br><span class="line">  4004a5:00 00                add    %al,(%rax)</span><br><span class="line">  4004a7:00 06                add    %al,(%rsi)</span><br><span class="line">  4004a9:00 00                add    %al,(%rax)</span><br><span class="line">  4004ab:00 03                add    %al,(%rbx)</span><br></pre></td></tr></table></figure><p>最大的变化是，文件变长了，除此之外也有一个显著的新特点：每一个节的开始位置不再是0,而是一个具体的地址。</p><h1 id="5-进程管理、信号与内存管理"><a href="#5-进程管理、信号与内存管理" class="headerlink" title="5. 进程管理、信号与内存管理"></a>5. 进程管理、信号与内存管理</h1><h2 id="进程管理与信号"><a href="#进程管理与信号" class="headerlink" title="进程管理与信号"></a>进程管理与信号</h2><p>当我们在Shell中运行程序时，会经历几个步骤：</p><ol><li>读取命令。</li><li>判断命令的准确性。</li><li>使用<code>fork()</code>创建子进程，在子进程中调用<code>execve()</code>启动程序。</li><li>Shell等待子进程完成。</li></ol><p>其中，用户可以给进程发出一些“信号”，比如按下<code>C-z</code>键，就会向进程输出SIGSTOP信号，按下<code>C-c</code>键，就会向进程输出SIGINT信号。当接收到这些信号时，程序可能有如下几种反应：</p><ul><li>忽略。</li><li>调用相应的信号处理函数处理信号。</li><li>执行默认的信号处理方式。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>一定程度上，进程之间彼此独立。在创建子进程后，在父进程中修改全局变量，子进程中的对应变量不会被更改。二者的内存区域指向不同的物理空间。</p><p>若想要在进程中通信，可以通过管道进行数据传输。</p><h1 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h1><p>源程序首先经过预处理，处理掉一些宏定义，经过编译，将之转换为汇编语言文件，经过汇编，将之转换为二进制文件，最后经过链接，定义符号，将程序各段重定位到绝对内存地址。</p><p>之后，通过Shell，读取命令，创建子进程，输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现康威生命游戏</title>
      <link href="/2023/05/01/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
      <url>/2023/05/01/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>某个假期，在看《黑客》这本书时，看到以前MIT的黑客很喜欢玩这个游戏。规则看起来不是很复杂，就试着实现一下吧。</p><p>生命游戏中，对于任意细胞，规则如下：</p><ul><li>每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）</li><li>当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态。（模拟生命数量稀少）</li><li>当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。</li><li>当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li><li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）</li></ul><p>可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。</p><h1 id="1-主体逻辑实现"><a href="#1-主体逻辑实现" class="headerlink" title="1. 主体逻辑实现"></a>1. 主体逻辑实现</h1><p>主体的逻辑实现不难，用两个布尔类型的二维数组表示新、旧地图，根据旧地图，计算出新地图中每一个cell的状态即可。</p><p>对于一个cell来说，首先根据旧地图，获取其存活的邻居数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getNeighbor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span> oldMatrix[BOARD_HEIGHT][BOARD_WIDTH])</span> &#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> xCord = x - <span class="number">1</span>; xCord &lt;= x + <span class="number">1</span>; xCord++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(xCord &lt; <span class="number">0</span> || xCord &gt;= BOARD_HEIGHT) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> yCord = y - <span class="number">1</span>; yCord &lt;= y + <span class="number">1</span>; yCord++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(yCord &lt; <span class="number">0</span> || yCord &gt;= BOARD_WIDTH) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!(xCord == x &amp;&amp; yCord == y)) &#123;</span><br><span class="line"><span class="keyword">if</span>(oldMatrix[xCord][yCord]) &#123;</span><br><span class="line">  result++;</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据自身的状态和邻居的个数，获取其将要变成什么状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">getStatus</span><span class="params">(<span class="type">int</span> neighbor, <span class="type">bool</span> originalStatus)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(originalStatus) &#123;</span><br><span class="line">    <span class="keyword">if</span>(neighbor == <span class="number">2</span> || neighbor == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(neighbor == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中，设置两个二维数组<code>matrix1</code>和<code>matrix2</code>，在主循环中，先将<code>matrix1</code>看作旧地图，将<code>matrix2</code>看作新地图，遍历地图上每一个点，在更新完一次地图之后，再把<code>matrix2</code>看作旧地图，<code>matrix1</code>看作新地图，周而复始，删减的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BOARD_HEIGHT; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; BOARD_WIDTH; j++) &#123;</span><br><span class="line">neighbor = getNeighbor(i, j, matrix1);</span><br><span class="line">matrix2[i][j] = getStatus(neighbor, matrix1[i][j]);</span><br><span class="line">neighbor = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   outputMatrix(matrix2);</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BOARD_HEIGHT; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; BOARD_WIDTH; j++) &#123;</span><br><span class="line">neighbor = getNeighbor(i, j, matrix2);</span><br><span class="line">matrix1[i][j] = getStatus(neighbor, matrix2[i][j]);</span><br><span class="line">neighbor = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   outputMatrix(matrix1);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-一些不重要的细节"><a href="#2-一些不重要的细节" class="headerlink" title="2. 一些不重要的细节"></a>2. 一些不重要的细节</h1><p>最开始的地图可以通过一个文件来读取，也可以随机地生成一些存活的cell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次网络谜题的解谜记录</title>
      <link href="/2023/05/01/%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%B0%9C%E9%A2%98%E7%9A%84%E8%A7%A3%E8%B0%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/05/01/%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%B0%9C%E9%A2%98%E7%9A%84%E8%A7%A3%E8%B0%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近在Lainchan上看到这样一个帖子，OP发言如下:</p><blockquote><p>Hello, I’ve recently stumbled upon this puzzle, that apparently dates  back to 2018 (I know I need to lurk moar). Has any lainon solved it  before? I’ve been stuck on the penultimate step 9 for 14 hours now.</p><p>&gt;hsvvrp.zjsvzlsfo.paola.lluayhjlp..pzy.bolyl.</p></blockquote><p>下面陆续有人留言，最终指向了这样一个网址：</p><p><a href="https://desuarchive.org/g/thread/66074121/#66091837">https://desuarchive.org/g/thread/66074121/#66091837</a></p><p>哦，原来是4chan上一位用户发布的网络谜题！</p><p>那就来试一试解谜吧。</p><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>以前在密码吧学到，对于一个短文本的加密，通常应用两种方式：凯撒密码、栅栏算法。</p><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>所谓凯撒密码，就是将字母在字母表中进行偏移，比如通常的字母表第一个字母是A，应用凯撒密码，我们可以把第一个字母设置为C。根据这样的一个对应关系对文本进行加密，比如说单词<code>apple</code>，每个单词往后移位，就可以是<code>bqqmf</code>。</p><h2 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h2><p>将想要加密的字符串从上到下，从左到右写成多行。按行读取就得到了密文。</p><p>比如说单词<code>apple</code>，可以写成：</p><blockquote><p>APE</p><p>PL</p></blockquote><p>密文就是<code>APEPL</code>。</p><p>除了这两种方法，也可以用一些图形对字母进行加密，比如卢恩符文、猪圈密码等。</p><p>回到现在的解谜过程。</p><p>第一阶段密文是：</p><blockquote><p>hsvvrp.zjsvzlsfo.paola.lluayhjlp..pzy.bolyl.</p></blockquote><p>链接在这里:<a href="https://pastebin.com/teBKxmLh">点击这里</a>。</p><p>首先应用栅栏密码，没什么收获。</p><p>然后应用凯撒密码解码方式，得到一种可能的明文：</p><blockquote><p>alooki.scloselyh.ithet.eentracei..isr.uhere.</p></blockquote><p>为什么可能？因为我看见了closely这个单词。似乎每组的第一个字母和最后一个字母是后加上去的。</p><p>每组的首字母、尾字母连接起来就是：</p><blockquote><p>aishitei.rue</p></blockquote><p>日语里的我爱你？</p><p>但是这个网站打不开，反复尝试得到链接：</p><blockquote><p>aishitei.ru</p></blockquote><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>OK。我们来到了一个网页。按下F12检查元素。</p><p>网页里有段注释:</p><blockquote><p>—- You’re off to a good start. Now look up.<br>—- Or maybe it was down?<br>—- Try asking the girl, Lain, for help.<br>—- She should be around here somewhere.</p></blockquote><p><code>Lain</code>，是番剧《玲音的系列试验》的女主角。我的博客头像就是Lain。</p><p>幻发现，每次刷新网页，网页中的图片都会改变，或许能通过不断刷新，当图片变为Lain时，就能解谜成功？</p><p>然而刷新了四五十次也没刷出来……</p><p>那么找找别的线索吧。</p><p>发现在网页底部有几个按钮，通过调查发现，这个网站似乎是某人的私人网盘，在FAQ中有这样一句话：</p><blockquote><p>Can I always use the same waifu mascot?</p><p>Find the number for the mascot you like and append, without quotes, <code>?waifu=*##*</code> to the URL. For example, Yuno is <code>?waifu=1</code>.</p></blockquote><p>OK。</p><p>当网址为<a href="https://aishitei.ru/?waifu=19">这个</a>时，所谓的<code>mascot</code>变成了Lain的样子。</p><p>下载这个<code>mascot</code>。</p><h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><p>So far so good！</p><p>我曾经在<a href="https://coder109.github.io/2023/02/10/Security03/#5-%E9%9A%90%E8%97%8F%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF">业余安全漫谈（三）：密码、存储、信息传输安全</a>中提到过一个查看图片元数据的网站。在这个网站上处理图片，最终提取到了这样的文字:</p><blockquote><p>Lavc51.28.0</p><p>…</p><p>you’re on the right track..kcart thgir eht no er’ouy<br>the wired is calling for you..ouy rof gnillca si deriw eht<br>can you hear it yet??tey ti raeh uoy nacRIFF</p><p>…</p><p>you’re on the right track..kcart thgir eht no er’ouy<br>the wired is calling for you..ouy rof gnillca si deriw eht<br>can you hear it yet??tey ti raeh uoy nac<br>track_44.wavvaw.44_kcart</p></blockquote><p>Btw，这个图片中有几个醒目的大字：</p><blockquote><p>Play Track 44</p></blockquote><p>这和幻正在汉化的游戏(英语太差了，汉化已经鸽了好久！)有关。曾经有一款古早的、和玲音有关的PSX游戏，它由许许多多的视频片段组成，您可以通过这个网站体验一下：<a href="https://laingame.net/">lainTSX</a>。</p><p>或者您可以在这收听Track 44，<a href="https://www.youtube.com/watch?v=w_wx2jag7xI">点击这里！</a>。</p><p>电子舞曲。</p><p>但是有什么用呢？你总不可能回到过去，和作曲人商量好，在这段曲子里加密一段信息吧。</p><p>……</p><p>幻没了任何思路。</p><p>直到幻突然想到了隐写术。</p><h2 id="隐写术与不断试错"><a href="#隐写术与不断试错" class="headerlink" title="隐写术与不断试错"></a>隐写术与不断试错</h2><p>我在<a href="https://coder109.github.io/2023/02/10/Security03/#%E9%9A%90%E5%86%99%E6%9C%AF">业余安全漫谈（三）：密码、存储、信息传输安全</a>里提到了隐写术的相关工具。</p><p>那么就把常用的工具都用上去吧。</p><p>终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -r mascot_19.jpg track_44.wav</span><br></pre></td></tr></table></figure><p>成功提取该文件。但是没法播放。</p><p>直接将图片改为<code>.wav</code>格式也不行。</p><p>试过了<code>Steghide</code>、<code>Stegsolve</code>等工具，都不行。</p><p>而使用<code>foremost</code>工具，则能提取出音频文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foremost -i mascot_19.jpg</span><br></pre></td></tr></table></figure><p>最终得到一个包含摩尔斯电码的音频文件。</p><p>懒得自己听了，直接用在线工具解码。</p><p>工具网站在这里:<a href="https://morsecode.world/">https://morsecode.world/</a>。</p><p>得到结果如下：</p><blockquote><p>C A N Y O U H E A R M E C A N Y O U H E A R M E L I S T E N C L O S E L Y L I S T E N C L O S E L Y D A N G E R D A N G E R R U N N A D Y A N A Y D O T M E F I N D M E T H E R E </p></blockquote><p>弄好看点是这样的：</p><blockquote><p>Can you hear me? Can you hear me? Listen closely. Listen CLosely. Danger,danger,run! NadyaNay.me Find me there.</p></blockquote><h1 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h1><p>访问<a href="nadyanay.me">nadyanay.me</a>。发现有几个按钮。里面的内容分别如下：</p><h2 id="Find-Me"><a href="#Find-Me" class="headerlink" title="Find Me"></a>Find Me</h2><p>所谓<code>Nadya</code>的身份信息，和一个PGP加密的信息。</p><h2 id="Anime-Recs"><a href="#Anime-Recs" class="headerlink" title="Anime Recs"></a>Anime Recs</h2><p>动漫推荐。<del>老二次元了。</del></p><h2 id="Music-Recs"><a href="#Music-Recs" class="headerlink" title="Music Recs"></a>Music Recs</h2><p>音乐推荐。<del>老二次元了。</del></p><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>虽然自己没打过CTF，但上面所应用的加密、解密工具的确是CTFer常用的。</p><p>还有一点内容：</p><blockquote><p>There are ten steps to escape The Wired.<br>Number of people who have escaped: <strong>4</strong> Anonymous Users<br>Date of last escape: 16&#x2F;03&#x2F;2023</p></blockquote><p>就四个人成功解密了。</p><p>哈哈，十步。怎么弄算一步呢？</p><h2 id="Not-a-Blog"><a href="#Not-a-Blog" class="headerlink" title="Not a Blog"></a>Not a Blog</h2><p>一页博客。</p><hr><p>嗯……我们先根据N(我下面会把设置这个谜题的人Nadya称为N)的公钥，把PGP讯息破解掉。或许会有用。</p><p>GPG咋用来着……？</p><p>不管了，经过解密最后的讯息如下：</p><blockquote><p>I am Nadya at Neocities. I claim ownership of all accounts listed on this page.</p></blockquote><p>好的。没啥用。</p><p>找找找～主页的HTML代码里有这样一条十六进制注释:</p><blockquote><p>6e616479616e61792e6d652f77697265642e747874 </p></blockquote><p>转成二进制、十进制也没啥用。</p><p>转成ASCII呢？</p><p>结果如下：</p><blockquote><p>nadyanay.me&#x2F;wired.txt</p></blockquote><p>哈哈！</p><h1 id="第五（七）阶段"><a href="#第五（七）阶段" class="headerlink" title="第五（七）阶段"></a>第五（七）阶段</h1><p>下载这个wired.txt。</p><p>发现最后一大串字符，但是文件最后俩字符是等号。</p><p>经过我在密码吧的多年潜水经验……这肯定是Base64！</p><p>然后解码，就乱码了。哈哈，打脸来的如此突然。</p><p>别气馁！把所有换行符删掉！！！！</p><p>由于笔者不是很会使用sed命令，写了个小小Java程序来实现这个功能（</p><p>解码之后输出结果还是乱码？？？</p><p>那么就把里面可读的字符提取出来吧。然而这么做也毫无作用。</p><p>因为部分结果如下：</p><blockquote><p>itbmzemicijscdqsbjzbvlodfadyojpvtbotzenpycjlzxtkclkghdsororxtztljdfwgfxccukunxtknxjzjimznyfstfgdrekruvtxreglkmgvkvehsfznilmlcijoewdjuvbfnyhlxkskvqpsqoofqkmkxmhzsaeeuopqkbkeoxosobupdpnxpxvjavqxwtbspaylctqujmwbhwxxcbdvvhqcqohwejwruvjtrzhdfolusurvmtsigzlxxrwxvzgjfifizuqjpohkqxdjqvppalrvbmookgwstdmpffiwaszdosbmmsikpepozgbpwdwpoqiihamukizliarquyxznoeeuuxtbssybkjimshkmjpvircyfkoyvuthbzxzieqisudwmmgpfruqqxqbblkgdiheqbvqplvavmdxhndffklvcepujkiaeiaoclomekvgskavwmjxjvoffvcqdhmyifeyfoccayrkunwuhxxqszvagxtqyribrftzgrzyzpowfcwmkmnqdqnurwbdxrfzkchujfxyhwgvrbtivlcyrytrugjfqlyxlmyqxxptitybnnzokdwlfewckcpzaofvxmbnhtlttlodwhwiwhidpubpdbczglwnvybjbnjkgjmgjtmyjmjdupxbqatughonuhbftpmlgqokmfbhgnbtofrpuuhhyysczchbinzgbxzwylesiozgzaxoqnpqydswekzemqwuaxtwxgcspuqifuecwohvhzaxqixqdzctkcfmjvryxsimxvfqowxhujovlvuycshmhsedjrflgiwyroqiamcjufaslaiexlgzemkeofgmhwhdaoibfffpmrooprfieakcdamymmuefum</p></blockquote><p>谁会在一堆字母之间掺杂无用讯息，然后加密呢？</p><p>直到……当我在查看wired.txt的时候，突然在一片小写字母中看到了大写的NEED。如果……这不是Base64，而只是将明文隐藏起来了呢？</p><p>使用Java提取大写字母。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rmvNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./data.list&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;~/Downloads/wired.txt&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="keyword">while</span>(line != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(line.charAt(i) &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; line.charAt(i) &gt;= <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(line.charAt(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;   </span><br><span class="line">                os.write(sb.toString().getBytes());</span><br><span class="line">                sb.setLength(<span class="number">0</span>);</span><br><span class="line">                line = br.readLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到：</p><blockquote><p>INOWENEEDYOURHELPWHATDOESITWANTTHEENTRANCECANBEFOUNDKEEPLOOKINGPROCEEDTOSTEPEIGHTTXT</p></blockquote><p>格式化：</p><blockquote><p>INO(I know?) WE NEED YOUR HELP. WHAT DOES IT WANT? THE ENTRANCE CAN BE FOUND. KEEP LOOKING! PROCEED TO STEP EIGHT.TXT</p></blockquote><h1 id="第八阶段"><a href="#第八阶段" class="headerlink" title="第八阶段"></a>第八阶段</h1><p><a href="https://nadyanay.me/eight.txt">https://nadyanay.me/eight.txt</a>里面什么也没有……</p><p>断句错了！</p><p><a href="https://nadyanay.me/stepeight.txt">https://nadyanay.me/stepeight.txt</a>，下一步的提示在这里。</p><blockquote><p>BLP KLPUE PX<br>HYQTLMY FL FWY HSCYE<br>XWW FWYB TJU WYJC BLP<br>AL ZJTO FL FWY ASCQX<br>QJSU HJUFX BLP FL HJFTW<br>LMUSVCYXYUTY MOR<br>FWYU CYJE<br>LMUSVCYXYUTY LMUSVCYXYUTY </p></blockquote><p>这次凯撒密码不好用了。应用栅栏密码也没什么用。</p><p>去密码吧找找提示……试了很多密码都没有用。</p><p>最终选择了一个很不优雅的方式-暴力破解。</p><h2 id="字频统计"><a href="#字频统计" class="headerlink" title="字频统计"></a>字频统计</h2><p>如您所知，英文单词中，每个单词出现的频率都是不一样的。根据这个密文，统计字母出现的频率，根据英语中字母常见的出现频率进行猜测。</p><blockquote><p>Y-18 L-12 U-11 F-9 W-8 X-7 T-7 C-7 J-7 S-6 M-5 P-5 B-4 H-4 E-3 Q-3 V-3 A-2 O-2 K-1 R-1 Z-1</p></blockquote><p>Y出现频率最多，将Y换成E。</p><p>FL出现次数很多，盲猜是to、on、in、of之中的一个。</p><p>BLP出现次数也很多，且出现在开头，盲猜为You。</p><p>……</p><p>乱猜。</p><p>之后可以大概修改为这样，替换得到的字母为小写，没猜出来的字母为大写：</p><blockquote><p>you found us<br>welcome to the wired<br>sh they can hear you<br>go back to the girls<br>lain wants you to watch<br>omnipresence mkR<br>then read<br>omnipresence omnipresence </p></blockquote><p>大概差不多了，所以N让我们回到女孩那里，或许是aishitei.ru？</p><p>至于mkR什么，盲猜是文件名，mkv？</p><p>然而<a href="https://aishitei.ru/omnipresence.mkv">https://aishitei.ru/omnipresence.mkv</a>并不是一个有效的链接。我从mka试到mkz,都不好使。</p><h1 id="第九阶段"><a href="#第九阶段" class="headerlink" title="第九阶段"></a>第九阶段</h1><p>那就用不优雅的方法吧。生成aishitei.ru和nadyanay.me网站的sitemap，看看哪里有我们想要的文件。</p><p>我使用<code>dirsearch</code>工具。</p><p>不断尝试，发现了以下两个文件：</p><p><a href="https://aishitei.ru/images/mascots/omnipresence.mkv">https://aishitei.ru/images/mascots/omnipresence.mkv</a></p><p><a href="https://aishitei.ru/images/mascots/omnipresence.omnipresence">https://aishitei.ru/images/mascots/omnipresence.omnipresence</a></p><p>Finally!最后一步啦！</p><p>mkv文件是玲音的OP,由Boa乐队演唱的Duvet。</p><p>至于另一个文件，我还没有思路。</p><p>先看看里面是什么吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> omnipresence.omnipresence</span><br></pre></td></tr></table></figure><p>得到一系列：</p><blockquote><p> O|X|X<br> X| |O<br> O|O|O<br> O|X|X<br> X| |O<br> O|X|O<br> O|X|X<br> O| |O<br> X|O|X<br> O|X|X<br> X| |O<br> O|X|X<br> O|X|X</p><p>…</p></blockquote><p>中间隔开了，会不会是四个一组的二进制数？</p><p>如果O为1,X为0,经过上面的步骤，先将这个二进制数转化成十六进制，再转换成ASCII,如果不行就让O为0，X为1.</p><p>前者输出乱码。</p><p>后者输出：</p><blockquote><p>present day<br>present time<br>how does it feel<br>to have entered the wired?<br>this is the final step<br>you must escape</p></blockquote><p>那么这个文件只是告诉我们，这是最后一步了。关键还是在视频中。</p><p>将音频从视频中分离开来，使用<code>deepsound</code>解码，得到的输出和上面一样。</p><p>失望……</p><h1 id="最终阶段"><a href="#最终阶段" class="headerlink" title="最终阶段"></a>最终阶段</h1><p>毫无线索。</p><p>回看Lainchan和4chan的归档，发现了几个提示：</p><ol><li>不要将这个视频当作视频看待，要跳脱出这个思维怪圈。</li><li>使用<code>hexdump</code>工具。多看几行，或许能发现规律。</li><li>N提到，没有任何东西是受密码保护的。</li></ol><p>在网上搜索到别人的<a href="https://a4sc7d.me/#org9f3aadb">解谜过程</a>，前几步和我的解法差不多，但是最后一步，作者只提到了：</p><blockquote><p><em>Hint: this step has to do with endianness.</em></p></blockquote><p>我目前没有解出这个谜题，我尝试过以下方法：</p><ol><li>将之转换为大端法表示，使用<code>foremost</code>、<code>steghide</code>、<code>stegsolver</code>、<code>outguess</code>等工具都没有什么进展。</li><li>使用<code>Audacity</code>查看音频波形、频谱，没有任何发现。</li><li>使用<code>hexdump</code>查看十六进制码，依旧没有任何发现。</li><li>将之转换为大端法表示，将其中的数字、大写字母、小写字母、全部字母、全部字母和数字分别单独提取出来仍没有任何发现。应用解密软件也没有收获。</li></ol><p>是的，这些方法都不优雅，也不合理。</p><p>目前幻没有任何思路，想到再更。或许解谜需要一些CTF的相关知识？</p><h1 id="更新：你管这叫CTF？"><a href="#更新：你管这叫CTF？" class="headerlink" title="更新：你管这叫CTF？"></a>更新：你管这叫CTF？</h1><p>于是乎，我在Lainchan上看到了一个新的文章：<a href="https://lainchan.org/%CE%BB/res/34490.html">点击这里</a>。</p><p>大意就是说，当下的时间就是答案，然而，根据不同的时区，有不同的时间值。所以，你要应用穷举法猜出N所在的时区，然后转换时间，将答案发给他。</p><p>我懒得去用什么穷举法了……</p><p>烂尾啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs的小技巧</title>
      <link href="/2023/04/29/Emacs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/04/29/Emacs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-缩进格式统一"><a href="#1-缩进格式统一" class="headerlink" title="1. 缩进格式统一"></a>1. 缩进格式统一</h1><p>如果您常用4空格缩进，而收到了一个2空格缩进的文件，可以采用如下操作将收到的文件缩进格式化：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-h </span><br><span class="line">M-x indent-region</span><br></pre></td></tr></table></figure><p>先选中全部文本，之后将缩进格式化。</p><h1 id="2-删除无效字符"><a href="#2-删除无效字符" class="headerlink" title="2. 删除无效字符"></a>2. 删除无效字符</h1><p>对于一些从Mac或Windows发来的C语言文件，每一行的末尾常常会出现^M的字符，采用如下操作删除：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x replace-string RET C-q C-m RET RET</span><br></pre></td></tr></table></figure><p>RET为回车键。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Emacs】坎坷之路，终抵群星</title>
      <link href="/2023/04/17/emacs-config/"/>
      <url>/2023/04/17/emacs-config/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关键词：Emacs、Emacs Lisp</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Emacs是什么？让我们来看看Emacs吧的标语：“不能煮咖啡的编辑器不是一个好操作系统”。</p><p>首先，Emacs是个编辑器，由Richard M Stallman等人最开始编写而成，后来有很多的衍生，现在常常使用的是1984年由Stallman发起维护的GNU Emacs，如果您对这段历史感兴趣，强烈推荐您读一读Steven Levy的《黑客》这本书。这本书对黑客道德、开源文化的历史等等有着非常详细的介绍。。</p><p>与此同时，Emacs又不只是一个编辑器。经过合理配置之后，Emacs可以变成不同语言的编程环境，可以编写Markdown、LaTeX文件，可以浏览PDF、网页，可以播放音乐、视频，也可以接发邮件，进行IRC聊天等等。至于“煮咖啡”“操作系统”一类的说法，仅仅是为了体现其功能强大而已。</p><p>本文只作为自己的Emacs学习记录而已，若可以给您一些启发，再好不过。用多了Emacs，真觉得把手从键盘挪到鼠标上太费劲了。</p><p>我的配置已经上传到github上：<a href="http://github.com/coder109/.emacs.d">coder109&#x2F;.emacs.d</a>。Emacs的配置主要用到Emacs Lisp语言。</p><h2 id="为什么要用Emacs？"><a href="#为什么要用Emacs？" class="headerlink" title="为什么要用Emacs？"></a>为什么要用Emacs？</h2><ul><li>快捷键多。熟练之后，写代码双手几乎不需要离开键盘。</li><li>自由度、模块化程度高。有需要的配置可以找现成的模块，或者用强大的Emacs Lisp写个新的。如果自己配置，可以完全贴近自己的需求，避免功能冗余。</li><li>兼容性高。Window、Linux、MacOS都可以用Emacs。</li><li>配置后功能强大。需要其它软件的频率会降低。</li><li>资源比较丰富。自带文档、Emacs China论坛里都有很多资料可供参考。</li><li>…</li></ul><h1 id="1-配置文件的结构"><a href="#1-配置文件的结构" class="headerlink" title="1. 配置文件的结构"></a>1. 配置文件的结构</h1><p>通常来说，一般采用如下的方法：</p><ul><li><p><code>~/.emacs.d/init.el</code>作为主配置文件，通过设置，Emacs可以从这个文件中调取配置。</p></li><li><p><code>~/.emacs.d/lisp/</code>作为其它配置文件的文件夹，<code>init.el</code>可以从这个文件夹里读取其它的配置文件。你可以使用<code>provide</code>、<code>require</code>这两个过程进行配置文件的读取，比如，在<code>~/.emacs.d/lisp/init-emacs.el</code>的末尾写下如下的代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">provide</span> &#x27;init-emacs)</span><br></pre></td></tr></table></figure><p>这就相当于把<code>init-emacs.el</code>文件以<code>init-emacs</code>的名字暴露在<code>init.el</code>前面，而在<code>init.el</code>中，只需要：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-to-list</span> &#x27;load-path <span class="string">&quot;~/.emacs.d/lisp&quot;</span>)</span><br><span class="line">(<span class="name">require</span> &#x27;init-emacs)</span><br></pre></td></tr></table></figure><p>就可以将<code>init-emacs.el</code>引入主配置文件了。</p></li></ul><h1 id="2-包的安装"><a href="#2-包的安装" class="headerlink" title="2. 包的安装"></a>2. 包的安装</h1><p>可以手动安装，输入如下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x package-install</span><br></pre></td></tr></table></figure><p>然后安装想要的包就可以了。</p><p>但这显然不方便，可以采用<code>use-package</code>包管理器统一管理包的安装，在相应的设置文件中设置：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 如果没安装use-package，就安装它。</span></span><br><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> &#x27;use-package)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 自动安装所有需要的软件包</span></span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><p>之后你就可以应用它了。格式大概如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> rainbow-delimiters</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . rainbow-delimiters-mode))</span><br></pre></td></tr></table></figure><h1 id="3-主题设置"><a href="#3-主题设置" class="headerlink" title="3. 主题设置"></a>3. 主题设置</h1><p>您可以根据自己所需，进行配置。</p><h2 id="1-基本的UI设置"><a href="#1-基本的UI设置" class="headerlink" title="1. 基本的UI设置"></a>1. 基本的UI设置</h2><p>令工具栏、滚动栏等不显示，并显示行号。在右下角显示时间。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">tool-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">scroll-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">global-display-line-numbers-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">column-number-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">display-time-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> display-time-24hr-format <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> display-time-day-and-date <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h2 id="2-主题和modeline设置"><a href="#2-主题和modeline设置" class="headerlink" title="2. 主题和modeline设置"></a>2. 主题和modeline设置</h2><p>您可以去github上搜索主题。笔者采用<code>moe-theme</code>+<code>powerline</code>的方案，顺便使用<code>nyan-mode</code>，在右下角显示一个彩虹猫，权当装饰，配置如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> &#x27;after-init-hook &#x27;nyan-mode)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> moe-theme)</span><br><span class="line">(<span class="name">show-paren-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> moe-theme-mode-line-color &#x27;blue)</span><br><span class="line">(<span class="name">setq</span> show-paren-style &#x27;expression)</span><br><span class="line">(<span class="name">moe-dark</span>)</span><br><span class="line">(<span class="name">powerline-default-theme</span>)</span><br></pre></td></tr></table></figure><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3. 字体"></a>3. 字体</h2><p>笔者曾经在Emacs China论坛上找到一个中英文都能妥善设置的方案：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> fonts &#x27;(<span class="string">&quot;Source Code Pro Medium&quot;</span> <span class="string">&quot;Microsoft YaHei&quot;</span>))</span><br><span class="line">(<span class="name">set-fontset-font</span> <span class="literal">t</span> &#x27;unicode <span class="string">&quot;Segoe UI Emoji&quot;</span> <span class="literal">nil</span> &#x27;prepend)</span><br><span class="line">(<span class="name">set-face-attribute</span> &#x27;default <span class="literal">nil</span></span><br><span class="line">    <span class="symbol">:font</span> (<span class="name">format</span> <span class="string">&quot;%s:pixelsize=%d&quot;</span> (<span class="name">car</span> fonts) <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> default-frame-alist &#x27;((font . <span class="string">&quot;Source Code Pro-16&quot;</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">if</span> (<span class="name">display-graphic-p</span>)</span><br><span class="line">    (<span class="name">dolist</span> (<span class="name">charset</span> &#x27;(kana han symbol cjk-misc bopomofo))</span><br><span class="line">      (<span class="name">set-fontset-font</span> (<span class="name">frame-parameter</span> <span class="literal">nil</span> &#x27;font) charset</span><br><span class="line">(<span class="name">font-spec</span> <span class="symbol">:family</span> (<span class="name">car</span> (<span class="name">cdr</span> fonts))))))</span><br></pre></td></tr></table></figure><h2 id="4-欢迎界面"><a href="#4-欢迎界面" class="headerlink" title="4. 欢迎界面"></a>4. 欢迎界面</h2><p>使用<code>dashboard</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> dashboard</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">dashboard-setup-startup-hook</span>))</span><br><span class="line">(<span class="name">setq</span> dashboard-banner-logo-title <span class="string">&quot;Let&#x27;s all love Lain...&quot;</span>)</span><br><span class="line">(<span class="name">setq</span> dashboard-startup-banner <span class="string">&quot;/home/bruce/Lain_avatar.png&quot;</span>)</span><br><span class="line">(<span class="name">setq</span> dashboard-image-banner-max-height <span class="number">300</span>) <span class="comment">;; 设置图片高度</span></span><br><span class="line">(<span class="name">setq</span> dashboard-image-banner-max-width <span class="number">300</span>)  <span class="comment">;; 设置图片宽度</span></span><br><span class="line">(<span class="name">setq</span> dashboard-center-content <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h1 id="4-编程相关设置"><a href="#4-编程相关设置" class="headerlink" title="4. 编程相关设置"></a>4. 编程相关设置</h1><h2 id="1-编码设置"><a href="#1-编码设置" class="headerlink" title="1. 编码设置"></a>1. 编码设置</h2><p>笔者将编码设置为<code>UTF-8</code>。毕竟，看见乱码再修改编码方式实在令人恼火。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-keyboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-clipboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-terminal-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-buffer-file-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-selection-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">modify-coding-system-alist</span> &#x27;process <span class="string">&quot;*&quot;</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">setq</span> default-process-coding-system &#x27;(utf-8 . utf-8))</span><br><span class="line">(<span class="name">setq-default</span> pathname-coding-system &#x27;utf-8)</span><br></pre></td></tr></table></figure><h2 id="2-LSP与DAP的设置"><a href="#2-LSP与DAP的设置" class="headerlink" title="2. LSP与DAP的设置"></a>2. LSP与DAP的设置</h2><p>LSP，全称叫做Language Server Protocol，大概的作用就是能提供语法高亮、语法提示功能的工具。</p><p>DAP，全称叫做Debug Adapter Protocol，和调试有关的工具。</p><p>建议参考github进行lsp的配置以及相应语言服务器的下载。</p><p>我的配置如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> lsp-mode</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="comment">;; set prefix for lsp-command-keymap (few alternatives - &quot;C-l&quot;, &quot;C-c l&quot;)</span></span><br><span class="line">  (<span class="name">setq</span> lsp-keymap-prefix <span class="string">&quot;C-c l&quot;</span>)</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="comment">;; replace XXX-mode with concrete major-mode(e. g. python-mode)</span></span><br><span class="line">         (<span class="name">c-mode</span>      . lsp)</span><br><span class="line"> (<span class="name">julia-mode</span> . lsp)</span><br><span class="line"> (<span class="name">lua-mode</span>   . lsp)</span><br><span class="line"> (<span class="name">ocaml-mode</span> . lsp)</span><br><span class="line"> (<span class="name">perl-mode</span>  . lsp)</span><br><span class="line"> (<span class="name">dart-mode</span>  . lsp)</span><br><span class="line"> (<span class="name">haskell-mode</span> . lsp)</span><br><span class="line"> (<span class="name">go-mode</span> . lsp)</span><br><span class="line"> (<span class="name">php-mode</span> . lsp)</span><br><span class="line"> (<span class="name">racket-mode</span> . lsp)</span><br><span class="line"> (<span class="name">ruby-mode</span> . lsp)</span><br><span class="line"> (<span class="name">rust-mode</span> . lsp)</span><br><span class="line"> (<span class="name">erlang-mode</span> . lsp)</span><br><span class="line"> (<span class="name">elixir-mode</span> . lsp)</span><br><span class="line"> (<span class="name">clojure-mode</span> . lsp)</span><br><span class="line"> (<span class="name">verilog-mode</span> . lsp)</span><br><span class="line"> )</span><br><span class="line">  <span class="symbol">:commands</span> lsp</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> lsp-auto-configure <span class="literal">t</span></span><br><span class="line">lsp-auto-guess-root <span class="literal">t</span></span><br><span class="line">lsp-idle-delay <span class="number">0.500</span></span><br><span class="line">lsp-session-file <span class="string">&quot;~/.emacs/.cache.lsp-sessions&quot;</span>))</span><br><span class="line">(<span class="name">require</span> &#x27;lsp-python-ms)</span><br><span class="line">(<span class="name">setq</span> lsp-python-ms-auto-install-server <span class="literal">t</span>)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;python-mode-hook &#x27;lsp)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-mode-hook &#x27;lsp)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; LSP-latex</span></span><br><span class="line">(<span class="name">setq</span> lsp-latex-java-executable <span class="string">&quot;usr/bin/java&quot;</span>)</span><br><span class="line">(<span class="name">setq</span> lsp-latex-texlab-jar-file &#x27;search-from-exec-path)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; LSP-juliaLang</span></span><br><span class="line">(<span class="name">use-package</span> lsp-julia</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> lsp-julia-default-environment <span class="string">&quot;~/.julia/environments/v1.7&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Set up before-save hooks to format buffer and add/delete imports.</span></span><br><span class="line"><span class="comment">;; Make sure you don&#x27;t have other gofmt/goimports hooks enabled.</span></span><br><span class="line">(<span class="name">defun</span> lsp-go-install-save-hooks ()</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;before-save-hook #&#x27;lsp-format-buffer <span class="literal">t</span> <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;before-save-hook #&#x27;lsp-organize-imports <span class="literal">t</span> <span class="literal">t</span>))</span><br><span class="line">(<span class="name">add-hook</span> &#x27;go-mode-hook #&#x27;lsp-go-install-save-hooks)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; LSP-Haskell</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;haskell-mode-hook #&#x27;lsp)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;haskell-literate-mode-hook #&#x27;lsp)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; optional</span></span><br><span class="line">(<span class="name">use-package</span> lsp-ui <span class="symbol">:commands</span> lsp-ui-mode)</span><br><span class="line"><span class="comment">;; if you are helm user</span></span><br><span class="line">(<span class="name">use-package</span> helm-lsp <span class="symbol">:commands</span> helm-lsp-workspace-symbol)</span><br><span class="line"><span class="comment">;; if you are ivy user</span></span><br><span class="line"><span class="comment">;;(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)</span></span><br><span class="line"><span class="comment">;;(use-package lsp-treemacs :commands lsp-treemacs-errors-list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; Debugger</span></span><br><span class="line">(<span class="name">use-package</span> dap-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> dap-debug</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  (<span class="name">dap-auto-configure-mode</span> <span class="literal">t</span>)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">dap-ui-mode</span> <span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">(<span class="name">require</span> &#x27;dap-python)</span><br></pre></td></tr></table></figure><h2 id="3-Emacs命令补全与加强"><a href="#3-Emacs命令补全与加强" class="headerlink" title="3. Emacs命令补全与加强"></a>3. Emacs命令补全与加强</h2><p>我使用<code>Helm</code>+<code>smex</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">helm-mode</span> <span class="number">1</span>)</span><br><span class="line">(<span class="name">smex-initialize</span>)</span><br></pre></td></tr></table></figure><h2 id="4-文本补全"><a href="#4-文本补全" class="headerlink" title="4. 文本补全"></a>4. 文本补全</h2><p>我使用<code>company</code>。它会自动根据你在当前文件中输入过的单词进行补全。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-company-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> company-minimum-prefix-length <span class="number">2</span>)</span><br><span class="line">(<span class="name">setq</span> company-idle-delay <span class="number">0</span>)</span><br><span class="line">(<span class="name">setq</span> company-selection-wrap-around <span class="literal">t</span>)</span><br><span class="line">(<span class="name">company-quickhelp-mode</span>)</span><br></pre></td></tr></table></figure><h2 id="5-括号的分级显示"><a href="#5-括号的分级显示" class="headerlink" title="5. 括号的分级显示"></a>5. 括号的分级显示</h2><p>Lisp语言的一大特点就是：括号太tm多了。</p><p>有必要对不同等级的括号，用不同的颜色显示出来，我选用<code>rainbow-delimiters</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> rainbow-delimiters</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . rainbow-delimiters-mode))</span><br></pre></td></tr></table></figure><h2 id="6-撤销操作树"><a href="#6-撤销操作树" class="headerlink" title="6. 撤销操作树"></a>6. 撤销操作树</h2><p>通过使用<code>undo-tree</code>包，可以通过<code>C-u</code>快捷键方便地回滚到过去的状态。我的第二行配置是为了将<code>undo-tree</code>文件，也就是记录撤销操作树的文件都存到统一的文件夹中，相信我，这很有必要。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> &#x27;after-init-hook &#x27;global-undo-tree-mode)</span><br><span class="line">(<span class="name">setq</span> undo-tree-history-directory-alist &#x27;((<span class="string">&quot;.&quot;</span> . <span class="string">&quot;~/.emacs.d/undo&quot;</span>)))</span><br></pre></td></tr></table></figure><h2 id="7-语法检查"><a href="#7-语法检查" class="headerlink" title="7. 语法检查"></a>7. 语法检查</h2><p>我使用<code>flycheck</code>，感觉比自带的<code>flymake</code>好用一些。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-flycheck-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h2 id="8-Vim键位"><a href="#8-Vim键位" class="headerlink" title="8. Vim键位"></a>8. Vim键位</h2><p>Vim键位实在是太香了。我使用<code>evil</code>包，将Vim的键位和Emacs的键位结合在一起，非常好用。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">evil-mode</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="9-搜索强化"><a href="#9-搜索强化" class="headerlink" title="9. 搜索强化"></a>9. 搜索强化</h2><p>您可以试一试<code>iedit</code>和<code>avy</code>。</p><h2 id="10-杂项"><a href="#10-杂项" class="headerlink" title="10. 杂项"></a>10. 杂项</h2><p>我还使用用于项目管理的<code>projectile</code>和版本管理的<code>magit</code>。</p><h1 id="5-自编写过程"><a href="#5-自编写过程" class="headerlink" title="5. 自编写过程"></a>5. 自编写过程</h1><p>我自己写了几个自动编译运行的过程，有挺多bug的。</p><p>但是我懒得改了。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> c-quick-compile ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">compile</span> (<span class="name">format</span> <span class="string">&quot;gcc %s &amp;&amp; ./a.out&quot;</span> (<span class="name">buffer-name</span>) ) <span class="literal">t</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> c-compile-no-run ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">compile</span> (<span class="name">format</span> <span class="string">&quot;gcc %s&quot;</span> (<span class="name">buffer-name</span>)))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> compile-no-run ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">eq</span> major-mode &#x27;java-mode)</span><br><span class="line">      (<span class="name">java-compile-no-run</span>))</span><br><span class="line">  (<span class="name">if</span> (<span class="name">eq</span> major-mode &#x27;c-mode)</span><br><span class="line">      (<span class="name">c-compile-no-run</span>))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h1 id="6-键位绑定"><a href="#6-键位绑定" class="headerlink" title="6. 键位绑定"></a>6. 键位绑定</h1><p>您可以使用如下的键位绑定过程：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a l&quot;</span>) &#x27;avy-goto-line)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a a&quot;</span>) &#x27;avy-copy-line)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a b&quot;</span>) &#x27;avy-copy-region)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a m&quot;</span>) &#x27;avy-move-line)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a n&quot;</span>) &#x27;avy-move-region)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>参考了Emacs China、Reddit(r&#x2F;emacs)、知乎、CSDN等平台的配置。有一些小package没有列出。本文会持续更新。私以为Emacs的配置也是如此，从编程菜鸟到编程老鸟的过程中，Emacs的配置也会随着需求逐渐变化迭代，有现成的包就用，没有符合自己需求的包，便自己写一个。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的stm32flash连接问题</title>
      <link href="/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h2><p>stm32flash是一个开源的烧录软件。描述为：</p><blockquote><p>Open source flash program for the STM32 ARM processors using the <strong>ST serial bootloader</strong> over UART or I2C    </p></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>当我尝试通过stm32flash连接单片机时，出现了如下的错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to init device</span><br></pre></td></tr></table></figure><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>查阅资料后，发现有人提到了这样一句：</p><blockquote><p>That often happens when you don’t have the BOOT pin set correctly. What upload method are you using?</p></blockquote><p>我去检查了自己的BOOT引脚上跳线帽的连接方式，是这样的：</p><blockquote><p>B1 - GND</p><p>B0 - GND</p></blockquote><p>查看官方文献，发现：</p><p><img src="/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/Screenshot_20230303_160708.png"></p><p>stm32flash描述里不是说过，它使用bootloader吗？于是将跳线帽连接改为：</p><blockquote><p>B1 - GND</p><p>B0 - HIGH</p></blockquote><p>成功连接！</p><p>输出如下：</p><p><img src="/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/Screenshot_20230303_161057.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://forum.arduino.cc/t/stm32f103c8t6-cannot-upload/634949">stm32f103c8t6 cannot upload</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择</title>
      <link href="/2023/02/10/LinuxRoad/"/>
      <url>/2023/02/10/LinuxRoad/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux苦痛之路（三）：漫谈-Arch-Linux软件配置选择"><a href="#Linux苦痛之路（三）：漫谈-Arch-Linux软件配置选择" class="headerlink" title="Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择"></a>Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前写的关于Arch Linux的那篇文章错误百出，也不够详细。重新写一篇。</p><p>请注意，本文主观性极强。</p><h2 id="0-我为什么要用Linux？"><a href="#0-我为什么要用Linux？" class="headerlink" title="0. 我为什么要用Linux？"></a>0. 我为什么要用Linux？</h2><p>它有几个优点：</p><ol><li>安全性高。Linux下恶意软件更少。</li><li>花销较少。至少大部分知名发行版都可以免费获取安装文件。</li><li>配置要求低。在低配置机器上表现出色。</li><li>轻量化。相对Windows来说，基本存储空间占用比较小。</li><li>客制化强。桌面环境、软件选择多种多样。</li><li>（这一点对于Arch Linux一类的滚动发行版更明显）更新迅速。</li><li>开源。</li><li>很多东西配置起来比较简单。大多数编程语言环境的配置、命令行工具的配置都很简单。</li></ol><p>这里，我想阐明几个概念：</p><ol><li>Linux严格意义上讲只是内核，我这里讲的Linux是以Linux为内核的发行版&#x2F;滚动发行版（distro）。</li><li>开源不完全等于开放源代码，它不仅包括开放源代码，还包括很多与修改、分发代码有关的权利。</li></ol><p>此外，并不是所有人都适合日常使用Linux,比如：</p><ol><li>很忙，没时间折腾的人。</li><li>不懂得如何正确提问、获取信息的人。</li><li>重度大型游戏玩家。</li></ol><h2 id="0-5-怎么选择发行版？"><a href="#0-5-怎么选择发行版？" class="headerlink" title="0.5 怎么选择发行版？"></a>0.5 怎么选择发行版？</h2><p>发行版数不胜数，适合自己的才是最重要的。</p><p>如果您是新手，<code>Linux Mint</code>、<code>Zorin</code>等是不错的选择，尤其是新版本的<code>Linux Mint</code>，它的桌面环境<code>Cinnamon</code>很漂亮，而且操作逻辑和Windows的差不了多少。您可以通过它们熟悉Linux的基本操作、文件树结构。当然，正如鸟哥说的那样，用Linux了就不要专注于图形界面，要学会在终端进行操作，这样才能成为Linux高手。</p><p>如果您差不多熟悉了Linux,可以选择其它发行版，它们更为成熟，客制化能力也比较强。</p><p>想追求较为稳定的体验，<code>Debian</code>、<code>Ubuntu</code>是不错的选择。<code>Debian</code>更为稳定，但是相应的，包版本更低。<code>Ubuntu</code>要比<code>Debian</code>更新策略激进一点，包相对较新，同时也保证了稳定性，此外也有以之为基础的<code>Lubuntu</code>、<code>Xubuntu</code>、<code>Kubuntu</code>等使用不同桌面环境的发行版。最近（2023-01-13）新出了一个同样基于Ubuntu的，叫作<code>Vanilla OS</code>的发行版。</p><p>想要时刻保持系统最新，可以使用滚动发行版。滚动发行版一般在新版本组件发布之后，很快就更新。比如<code>Arch Linux</code>，和以之为基础的<code>Arco Linux</code>、<code>Artix Linux</code>、<code>Archcraft</code>、<code>Manjaro</code>；也有<code>OpenSUSE</code>、<code>Gentoo</code>、<code>Void Linux</code>可供选择。</p><p>此外，也有各种针对某些特定领域开发的Linux发行版，比如针对渗透、安全开发的<code>Kali Linux</code>、<code>BlackArch</code>，针对科学计算开发的<code>DAT Linux</code>等等。</p><p>如果您是安全、隐私方面的偏执狂，那么可以使用<code>Qubes OS</code>、<code>Tails OS</code>、<code>Whonix</code>。</p><p>如果您对于<code>systemd</code>有着强烈的排斥感，可以选用<code>Devuan</code>、<code>Artix Linux</code>。</p><p>如果您想完全使用开源的、非专有的软件，请使用<code>GNU GUIX</code>。</p><p>如果您想获得最大化的个性化配置体验，可以选用<code>Gentoo</code>、<code>Arch Linux</code>。</p><p>如果您想要在服务器上运行，推荐您使用尽可能稳定的发行版。</p><p>这篇文章，我主要讲一讲我配置<code>Arch Linux</code>的软件选择。</p><h2 id="1-基本环境安装"><a href="#1-基本环境安装" class="headerlink" title="1.基本环境安装"></a>1.基本环境安装</h2><p>详见<a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">Arch Wiki上的安装指南</a>。</p><p>另外也有安装助手<a href="https://wiki.archlinux.org/title/Archinstall">Arch Install</a>可供使用，能在一定程度上减轻安装Arch Linux的难度。</p><p>假定您已经安装好了基本的环境，配置好了日常用户。</p><p><a href="https://wiki.archlinux.org/">Arch Wiki</a>是非常有用的信息源，你可以在上面查到应用程序的相关信息、配置方法、疑难解答等等。</p><p>不推荐您参考知乎、CSDN、各种博客等来源上的安装教程，它们的严谨性不够高，上面的信息也很有可能是过时的。</p><h3 id="密钥问题"><a href="#密钥问题" class="headerlink" title="密钥问题"></a>密钥问题</h3><p>在安装过程中，有可能出现由于密钥产生的错误，当安装来自<code>archlinuxcn</code>源的软件时，这个错误十分常见。这时请确保相应的keyring安装、更新完毕，如果还是出现错误，请运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate</span><br></pre></td></tr></table></figure><p>这一般能解决问题。</p><h2 id="2-包管理器"><a href="#2-包管理器" class="headerlink" title="2. 包管理器"></a>2. 包管理器</h2><p>包管理器能够帮助您安装、卸载、管理包。</p><p>系统初始只有<code>pacman</code>，它只能安装<code>Arch Linux</code>官方的包，没法安装<a href="https://wiki.archlinuxcn.org/wiki/Arch_%E7%94%A8%E6%88%B7%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93_(AUR)">AUR</a>包，也就是用户软件仓库的包。AUR是<code>Arch Linux</code>的优势之一，它是一个由用户社区维护的库。用户可以从AUR上克隆生成脚本，在本地生成包，从而安装。</p><p>举个例子，在<code>Ubuntu</code>上安装<code>deepin-wine</code>版本的微信，那么我需要先花很大力气找到<code>deepin-wine</code>的安装包，之后还要再花很大力气找到<code>deepin-wine-wechat</code>的安装包。我在写<a href="https://coder109.github.io/2022/11/01/linuxRoad1/">Linux苦痛之路（一）</a>的时候就经历过这种折磨，当时使用的是<code>Ubuntu 22.04</code>，不仅安装费劲，也很容易出现依赖版本对不上的问题。</p><p>而在<code>Arch Linux</code>上，我只需要从<a href="https://aur.archlinux.org/">Arch Wiki的AUR搜索面板</a>找到<code>deepin-wine-wechat</code>，将生成脚本克隆到本地，输入两行命令构建、安装，就可以了。甚至，如果我安装了<a href="https://wiki.archlinuxcn.org/wiki/AUR_%E5%8A%A9%E6%89%8B">AUR助手</a>，直接输入一行命令就可以安装了，省时省力。</p><p>AUR助手我主要用<code>yay</code>，它用go语言编写而成，解析依赖的能力比较强。</p><p>也有一些图形化的工具可以搜索包，但是我个人一般直接上Wiki查找，用不到。</p><p>如何管理您的包也是很重要的一部分，详情见推荐阅读中的系统维护页面。</p><h2 id="3-显示管理器"><a href="#3-显示管理器" class="headerlink" title="3. 显示管理器"></a>3. 显示管理器</h2><p>它允许你登录到桌面环境，相当于从启动过程到桌面环境的一个桥梁。比较常见的有<code>sddm</code>、<code>lightdm</code>等等。如果嫌丑，github上有很多相关的主题可供选择。</p><h2 id="3-5-桌面环境"><a href="#3-5-桌面环境" class="headerlink" title="3.5 桌面环境"></a>3.5 桌面环境</h2><p>如果您嫌麻烦，不愿配置窗口管理器，那么可以直接下载桌面环境。所谓桌面环境，就是一堆组件包，包括窗口管理器、实用小组件、文件管理器等等，开箱即用，而且大多数桌面环境可配置能力也很强。比较出名的有：</p><ol><li><code>GNOME</code>，其也是<code>Ubuntu</code>的桌面环境。</li><li><code>KDE</code>，定制性非常强，缺点是系统占用比较多。</li><li><code>Xfce</code>，轻量化的桌面环境，就是有点丑。</li></ol><h2 id="4-窗口管理器"><a href="#4-窗口管理器" class="headerlink" title="4. 窗口管理器"></a>4. 窗口管理器</h2><p>窗口管理器和桌面环境有什么不同？<a href="https://wiki.archlinuxcn.org/wiki/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8">窗口管理器</a>提供了图形界面，它允许你操纵窗口，打开应用程序，但是不提供状态栏、文件管理器等工具。桌面环境包括窗口管理器，同时也提供了一些设置工具、状态栏、组件等等。使用窗口管理器相对来说定制性强，更加轻量化，能够自定义自己想要用的工具包，缺点是配置起来更加麻烦。</p><p>窗口管理器有三大门派，一派是<strong>层叠式窗口管理器</strong>，另一派是<strong>平铺式窗口管理器</strong>，还有一派是<strong>动态窗口管理器</strong>。</p><h3 id="层叠式窗口管理器"><a href="#层叠式窗口管理器" class="headerlink" title="层叠式窗口管理器"></a>层叠式窗口管理器</h3><p>这种窗口管理器就像Windows的窗口管理器一样，窗口之间可以重叠，比较出名的是<code>KDE</code>桌面自带的<code>KWin</code>，<code>Xfce</code>桌面自带的<code>Xfwm</code>等等。</p><h3 id="平铺式窗口管理器"><a href="#平铺式窗口管理器" class="headerlink" title="平铺式窗口管理器"></a>平铺式窗口管理器</h3><p>这种窗口管理器的窗口之间一般没有重叠，平铺在桌面上，占据着不同的空间。当你打开一个软件时，它占据整个屏幕，当您打开另一个软件时，它们会各自占据一半屏幕。</p><p>这种窗口管理模式对于键盘操作非常友好，可以通过快捷键选中、操纵窗口，比较出名的有<code>Bspwm</code>，<code>i3wm</code>等等。</p><p><code>Bspwm</code>可以结合<code>sxhkd</code>来设置快捷键，二者的配置非常简单、方便。</p><h3 id="动态窗口管理器"><a href="#动态窗口管理器" class="headerlink" title="动态窗口管理器"></a>动态窗口管理器</h3><p>它们结合不同的管理方法，可以应用层叠式的，也可以应用平铺式的，功能比较强大，比较出名的有<code>Xmonad</code>,<code> awesome</code>，<code>dwm</code>。</p><p>PS：<code>dwm</code>打补丁有些麻烦。</p><h3 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h3><p>这些窗口管理器遵循UNIX原则，通常不提供状态栏，您可以通过<code>polybar</code>进行配置。</p><p>如果想要配置背景透明度和窗口渐入渐出动画，可以使用<code>picom</code>。</p><p>快速启动应用，可以使用<code>rofi</code>。</p><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p>我比较喜欢的配色方案是<a href="https://www.nordtheme.com/docs/colors-and-palettes">nord</a>和<a href="https://ssshooter.github.io/nippon-color/">nipponcolor</a>。</p><h2 id="5-电源管理"><a href="#5-电源管理" class="headerlink" title="5.电源管理"></a>5.电源管理</h2><p>有很多用户报告说，Linux比Windows更耗电。我还没有验证过这个结论。但是用Linux日常工作，我的笔记本风扇声音更小，温度更低。内存占用、CPU占用也更少。</p><p>如果您想配置电源，可以使用<code>powertop</code>和<code>tlp</code>两个工具，我更推荐前者，后者导致我的无线网经常断连。</p><h2 id="6-浏览器"><a href="#6-浏览器" class="headerlink" title="6.浏览器"></a>6.浏览器</h2><p>我使用<code>Firefox</code>和<code>ungoogled-chromium</code>。其中，对于Firefox，我应用了<a href="https://github.com/arkenfox/user.js/">arkenfox&#x2F;user.js</a>，对隐私保护进行了优化，如果嫌麻烦，可以直接使用<code>LibreWolf</code>。此外，可以使用<code>Vimium</code>插件将Vim键位应用到网页浏览上。</p><p>您可以通过<a href="https://www.deviceinfo.me/">此网站</a>测试您浏览器的隐私程度。</p><h2 id="7-安全"><a href="#7-安全" class="headerlink" title="7.安全"></a>7.安全</h2><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>您需要它。的确，Linux下的恶意软件更少，但是仍然面临着被黑入的风险。</p><p><code>firewalld</code>和<code>ufw</code>都是不错的选择，它们分别使用<code>nftables</code>和<code>iptables</code>作为后端。我日常使用后者，<code>gufw</code>包提供了一个图形界面来配置<code>ufw</code>的规则、端口等等。</p><h3 id="密码管理器"><a href="#密码管理器" class="headerlink" title="密码管理器"></a>密码管理器</h3><p>您可能将大部分密码保存在浏览器里，但是我不推荐这种方法，因为浏览器并不是为管理密码设计的。我更推荐用专用的密码管理器。</p><p>现在的密码管理器大概分为两种，一种将密码库放在云端，另一种将密码库存储在本地。前者比较方便，可以多设备同步，但是面临着数据泄露的风险，比如<a href="https://www.wired.com/story/lastpass-breach-vaults-password-managers/">LastPass密码库泄露事件</a>。所以我更推荐使用后者，只要你能够妥善保管，就很安全，我日常使用的是<code>KeePassXC</code>。</p><p>这里也推荐一个方法，在设置密钥时，可以在设置密码的同时设置密钥文件，这样基本上没有暴力破解的可能性。</p><h3 id="加密卷"><a href="#加密卷" class="headerlink" title="加密卷"></a>加密卷</h3><p>如果您有些敏感信息要存放，可以使用<code>Veracrypt</code>，它不仅可以创建加密卷，也可以加密U盘、硬盘等，是很强大的工具。</p><p>同样，采用密钥文件+密码的模式，会很安全。</p><h3 id="快照-x2F-备份"><a href="#快照-x2F-备份" class="headerlink" title="快照&#x2F;备份"></a>快照&#x2F;备份</h3><p>滚动更新面临着系统崩溃的风险，而Arch Linux的更新策略尤为激进。所以您需要定期备份，好在系统崩溃时回滚，相关工具有<code>timeshift</code>等等。</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>妥善管理好文件的权限！</p><p>此外，用<code>sudo</code>代替<code> su root</code>。</p><p>看到过许多Linux用户，常年用<code>root</code>用户操作……为他们捏把汗。</p><p>不过也有些单用户的发行版，就不太需要考虑权限的事情，比如说<code>Haiku</code>。</p><h3 id="三思而后行"><a href="#三思而后行" class="headerlink" title="三思而后行"></a>三思而后行</h3><p>在执行命令前，看清楚语法是否正确。举个例子，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./ ss</span><br></pre></td></tr></table></figure><p>这个命令会删除你所在文件夹的所有内容，如果只想删除ss,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./ss</span><br></pre></td></tr></table></figure><p>我就曾经多打了一个空格，导致删除了我所有的配置文件和重要文档。</p><h2 id="8-游戏"><a href="#8-游戏" class="headerlink" title="8.游戏"></a>8.游戏</h2><p>我没有找到一个完美的方案。</p><p>如果游戏支持Linux,直接运行即可。</p><p>对于Windows独占的游戏，Steam上的游戏可以使用Steam自带的Proton运行，Proton集成了wine等有用的工具，对于steam游戏也做了相应的优化，体验还算不错，但是在游戏过程中，游戏内存占用会不断增长，最终导致系统卡死。</p><p>我也听说过使用<code>DXVK</code>、<code>lutris</code>和<code>play on linux</code>的方案，不知道体验如何。</p><h2 id="9-编辑器"><a href="#9-编辑器" class="headerlink" title="9.编辑器"></a>9.编辑器</h2><p>如果您习惯了键盘操作，那么您也许会发现，工作效率也会有显著的提高。此外，流畅的键盘操作更容易进行流畅的编码，免去切换鼠标带来的思路卡顿。</p><p>以键盘操作为主的编辑器，无非是Emacs和Vim，一直以来始终有一个争论：Emacs还是Vim？</p><p>这个问题和“哪个发行版最好”一样毫无意义，不过是茶余饭后闲聊的谈资而已。</p><p>Emacs功能强大，可以作为邮件客户端、笔记软件、音乐软件、图片查看器等，被称为“神之编辑器”。</p><p>Vim&#x2F;Neovim键位更友好，大大提升编码效率，被称为“编辑器之神”。</p><p>对于Emacs,有很多开箱即用的用户预配置版本：<code>doomemacs</code>、<code>spacemacs</code>。</p><p>对于Vim,则有：<code>Lunarvim</code>等。</p><p>此外，我也经常使用<code>IDEA</code>等编辑器。工具嘛，哪个好用用哪个。</p><h2 id="10-输入法"><a href="#10-输入法" class="headerlink" title="10.输入法"></a>10.输入法</h2><p>输入法参考维基，安装fcitx5就好，不过我想在这里写下一个问题的解决方法。</p><h3 id="fcitx5无法输入中文中括号的解决方案"><a href="#fcitx5无法输入中文中括号的解决方案" class="headerlink" title="fcitx5无法输入中文中括号的解决方案"></a>fcitx5无法输入中文中括号的解决方案</h3><p>在<code>/usr/share/fcitx5/punctuation/punc.mb.zh_CN</code>这个文件中，</p><p>将[，]两行改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 【</span><br><span class="line">] 】</span><br></pre></td></tr></table></figure><p>如果您想打出中文的人名分隔符的话：</p><p>在文件末尾添加：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ·</span><br></pre></td></tr></table></figure><p>即可。</p><h2 id="11-个性化配置"><a href="#11-个性化配置" class="headerlink" title="11.个性化配置"></a>11.个性化配置</h2><h3 id="键位绑定"><a href="#键位绑定" class="headerlink" title="键位绑定"></a>键位绑定</h3><p>可以使用<code>xmodmap</code>工具，比如，您可以用它将Caps Lock键和Ctrl键映射互换。</p><h3 id="外设配置-x2F-灯效配置"><a href="#外设配置-x2F-灯效配置" class="headerlink" title="外设配置&#x2F;灯效配置"></a>外设配置&#x2F;灯效配置</h3><p>如果您要配置鼠标的额外按键功能、RGB灯效的话，可以使用<code>piper</code>，但有可能出现无法绑定键位的错误。</p><p>灯效可以通过<code>openrgb</code>进行配置。</p><h3 id="终端模拟器-x2F-Shell"><a href="#终端模拟器-x2F-Shell" class="headerlink" title="终端模拟器&#x2F;Shell"></a>终端模拟器&#x2F;Shell</h3><p>对于终端模拟器，<code>Alacritty</code>是个不错的选择，支持跨平台操作，也支持一定程度的自配置。</p><p>Shell则纯看个人喜好，我使用<code>zsh</code>，搭配<code>oh-my-zsh</code>的示例配置文件。</p><h3 id="系统监测"><a href="#系统监测" class="headerlink" title="系统监测"></a>系统监测</h3><p><code>htop</code>可以查看进程。</p><p><code>neofetch</code>可以查看系统信息。</p><h3 id="dotfiles"><a href="#dotfiles" class="headerlink" title="dotfiles"></a>dotfiles</h3><p>所谓dotfiles，就是您的自定义配置文件，因为大多配置文件都以<code>.</code>开头，或者储存在<code>.config</code>文件夹内，您可以通过git或者其他管理工具管理它们，上传到github，这样在配置新系统时会很方便。</p><h2 id="Ex-注意事项"><a href="#Ex-注意事项" class="headerlink" title="Ex.注意事项"></a>Ex.注意事项</h2><h3 id="Emacs的使用"><a href="#Emacs的使用" class="headerlink" title="Emacs的使用"></a>Emacs的使用</h3><p>将Emacs设置为守护进程将节省启动的时间。开机时启动守护进程，Emacs就将始终在后台运行，每次打开Emacs(Client)即可，免去加载时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/emacs --daemon &amp;</span><br></pre></td></tr></table></figure><h3 id="NVIDIA驱动"><a href="#NVIDIA驱动" class="headerlink" title="NVIDIA驱动"></a>NVIDIA驱动</h3><p>不要从NVIDIA官网安装！参见<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA">Arch Wiki：NVIDIA</a>。</p><h3 id="信息源"><a href="#信息源" class="headerlink" title="信息源"></a>信息源</h3><p><code>Arch Wiki</code>中包含大多数常用包的说明、设置方法、疑难解答。</p><p><code>Arch Forum</code>中包含很多用户遇到的问题和解决方案。</p><p><code>Github</code>上有许多包的源码，可以在issue中查看一些问题的解决方法。</p><h3 id="Haskell配置"><a href="#Haskell配置" class="headerlink" title="Haskell配置"></a>Haskell配置</h3><p>不要使用Arch Linux提供的<code>ghc</code>，<code>ghci</code>，正确的方法是只安装官方库的<code>ghcup</code>，通过<code>ghcup</code>安装相关的包。</p><h3 id="发行版彼此不同"><a href="#发行版彼此不同" class="headerlink" title="发行版彼此不同"></a>发行版彼此不同</h3><p><code>Manjaro</code>、<code>Arco Linux</code>、<code>Artix Linux</code>不是<code>Arch Linux</code>，它们是<strong>基于</strong><code>Arch Linux</code>的发行版。</p><p><code>Ubuntu</code>不是<code>Debian</code>,它是<strong>基于</strong><code>Debian</code>的发行版。</p><p>也就是说，举个例子，在<code>Manjaro</code>发行版上遇到的问题，尽量去<code>Manjaro</code>专门的论坛，而不是去<code>Arch Linux</code>的论坛寻求解答；在<code>Debian</code>上遇到的问题就尽量去<code>Debian</code>论坛寻求解答。</p><h3 id="软件替代品"><a href="#软件替代品" class="headerlink" title="软件替代品"></a>软件替代品</h3><p>您可以去<a href="https://alternativeto.net/">alternativeto.net</a>查询Windows下软件在Linux系统上的替代品。</p><h3 id="一寸光阴一寸金"><a href="#一寸光阴一寸金" class="headerlink" title="一寸光阴一寸金"></a>一寸光阴一寸金</h3><p>不要花费太多时间在切换、尝试不同的Linux发行版上，也不要花费太多时间在配置桌面环境、选择软件上。能用就行。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4">Arch Wiki：系统维护</a></p><p><a href="https://zhuanlan.zhihu.com/p/163805070">fcitx5中文输入法方括号问题的解决</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】平摊分析</title>
      <link href="/2022/11/23/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/23/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h1><p>执行一系列数据结构上操作的时间复杂度，可以通过对每个操作的时间复杂度进行分析，取平均，进行估计。</p><p>常用的方法有三种：聚焦方法、会计方法、势能方法。</p><h1 id="1-聚焦方法"><a href="#1-聚焦方法" class="headerlink" title="1.聚焦方法"></a>1.聚焦方法</h1><p>该方法大意为：考察每个操作的最坏时间复杂度，然后作平均得到整体的一个复杂度上界。</p><p>这个方法比较简单，易于操作，但是它估计出来的结果有的时候非常不精确，放缩的范围太大。</p><h2 id="实例：栈操作"><a href="#实例：栈操作" class="headerlink" title="实例：栈操作"></a>实例：栈操作</h2><p>考察：初始栈为空，经过一系列操作的代价。操作有三种：</p><ul><li>Push：压栈。</li><li>Pop：弹栈。</li><li>MultiPop：多重弹栈。</li></ul><p>由于一个对象在每次压栈后，至多被弹出一次，MultiPop弹栈的次数折算成Pop的次数，必然和压栈次数相等。如果压栈n次，那么MultiPop折算成Pop，也相当于Pop了n次，设最终栈空，则整体代价为2n&#x3D;O(n)，平摊下来，每个操作都是O(1)的复杂度。</p><h1 id="2-会计方法"><a href="#2-会计方法" class="headerlink" title="2.会计方法"></a>2.会计方法</h1><p>一系列操作的实际代价可能彼此不同。那么我们可以为每种操作分配不同的平摊代价，其有两种情况：</p><ul><li>如果平摊代价大于、等于实际代价，则平摊代价一部分用于抵消实际代价，一部分用于当作余额，支付其他操作的代价。</li><li>如果平摊代价小于实际代价，则平摊代价全部用作抵消自身实际代价，还要从其他操作的余额中索取一部分，补充抵消自身的代价。</li></ul><p>我们选取的平摊代价之和，必须大于实际代价之和，这样我们才能获取一个整体的代价上界，来估计实际代价。</p><h2 id="实例：栈操作-1"><a href="#实例：栈操作-1" class="headerlink" title="实例：栈操作"></a>实例：栈操作</h2><p>已知三种状态的实际代价为：</p><ul><li>Cost(Push)&#x3D;1</li><li>Cost(Pop)&#x3D;1</li><li>Cost(MultiPop)&#x3D;min(n,k)，k为栈中元素个数，n为MultiPop折算成Pop的弹栈次数。</li></ul><p>平摊代价为：</p><ul><li>Cost(Push)&#x3D;2,一个1用来支付Push的开销，剩下一个1用来预支Pop的开销。</li><li>Cost(Pop)&#x3D;0。</li><li>Cost(MultiPop)&#x3D;0。</li></ul><p>那么最坏总代价（最终栈空）为2n,n为压栈次数。总平摊代价也就为O(n)，每个操作的平摊代价就是O(1)。</p><h1 id="3-势能方法"><a href="#3-势能方法" class="headerlink" title="3.势能方法"></a>3.势能方法</h1><p>我们把进行一个操作的前后看作两个状态的转变，设每个状态$D_i$都有一个势能（潜力）$\phi(D_i)$，那么代价就是：<br>$$<br>AmortizedCost(Procedure)&#x3D;ActualCost(Procedure)+\Delta\phi<br>$$<br>势能怎么得到？认为规定即可，但是它要满足几个条件：</p><ul><li>恒正。</li><li>$\phi(D_i)\ge\phi(D_0)$，保证总平摊代价是总实际代价的上界。</li></ul><h2 id="实例：栈操作-2"><a href="#实例：栈操作-2" class="headerlink" title="实例：栈操作"></a>实例：栈操作</h2><p>规定$\phi(D_i)$为$D_i$状态下，栈中元素的个数，那么对于每个操作来说，它们的平摊代价为：</p><ul><li>Cost(Push)&#x3D;1+n-(n-1)&#x3D;2</li><li>Cost(Pop)&#x3D;1+(n-1)-n&#x3D;0</li><li>Cost(MultiPop)&#x3D;0</li></ul><p>n个栈操作的最坏总平摊代价为2n，其他结论同上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】树搜索</title>
      <link href="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="0-为什么要树搜索？"><a href="#0-为什么要树搜索？" class="headerlink" title="0.为什么要树搜索？"></a>0.为什么要树搜索？</h1><p>有许多问题，它们的解可以表示为树。举个例子：</p><h2 id="布尔表达式可满足性问题"><a href="#布尔表达式可满足性问题" class="headerlink" title="布尔表达式可满足性问题"></a>布尔表达式可满足性问题</h2><p>q输入：由$x_1,x_2,\cdots,x_n$n个逻辑变元组成的逻辑表达式$A$。</p><p>输出：指派$v$，令$A^v&#x3D;T$，即一种变元赋值，让表达式为真。</p><p>对于每一个变元，都有0,1或者F,T两种取值，那么我们可以构造出这样一棵树来：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree1.png"></p><p>于是乎，我们可以应用树的相关算法，求解这样的一些问题。</p><h2 id="8-puzzle问题"><a href="#8-puzzle问题" class="headerlink" title="8-puzzle问题"></a>8-puzzle问题</h2><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree2.png"></p><p>该问题根据每一次挪动，可以被转化为树搜索问题：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree3.png"></p><p>首先我们先介绍两个算法：DFS,BFS。之后我们讨论如何优化树搜索的相关算法。</p><h1 id="1-深度优先搜索-DFS"><a href="#1-深度优先搜索-DFS" class="headerlink" title="1.深度优先搜索(DFS)"></a>1.深度优先搜索(DFS)</h1><p>对于一个图，我们想知道两个点之间是否有一条通路，可以使用DFS算法。</p><p>DFS算法有种“不撞南墙不回头”的感觉，算法如下：</p><ol><li>将起点压栈，标记为访问过。（从起点）</li><li>将一个与栈顶点邻接的，且未被访问过的节点压栈，标记为访问过，递归此步。（一直走下去）</li><li>如果最后没有没访问过的节点，且目标点没有遍历过，则回溯，将当前节点弹出，重新选择节点压栈。（直到走不通，往回走）</li></ol><h1 id="2-广度优先搜索-BFS"><a href="#2-广度优先搜索-BFS" class="headerlink" title="2.广度优先搜索(BFS)"></a>2.广度优先搜索(BFS)</h1><p>BFS相比于DFS,就灵活很多，它有种“扩散”的感觉，算法如下：</p><ol><li>将起点入队，标记为访问过。（从起点）</li><li>将与起点所有邻接点入队，标记为访问过，同时将起点出队，递归此步。（扩散）</li></ol><h1 id="3-爬山法"><a href="#3-爬山法" class="headerlink" title="3.爬山法"></a>3.爬山法</h1><p>对于一个可以用树搜索+DFS解决的问题，在深度优先搜索中，如何判定令哪个节点入栈最优呢？</p><p>我们可以使用贪心算法，即每一步都选令局部最优的那个解。</p><p>对于8-puzzle问题中的每一个步骤，我们可以编写出一个代价判据，每次都根据栈顶点，选择让这个代价判据最小的新点入栈。</p><p>通俗的来讲，就是在DFS“一直走下去”的过程中，每次都选择最“方便”的那一个点。</p><p>举个例子，我们让代价判据为“所有处于错误位置的方块数”，那么应用爬山法：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree4.png"></p><p>就可以找到一个解啦。</p><h1 id="4-Best-First搜索算法"><a href="#4-Best-First搜索算法" class="headerlink" title="4.Best-First搜索算法"></a>4.Best-First搜索算法</h1><p>但是，这不够好，贪心是<strong>局部最优的</strong>，有的时候局部最优显然不是全局最优解，Best-First算法就是为了解决这个情况而生的。</p><p>我们同样设立一个代价判据，但是，在所有节点中选择令代价判据最小的方案。</p><p>同样对于8-puzzle问题，如果应用这个算法：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree5.png"></p><ol><li>先走第一层，出现3,3,4,4的代价。</li><li>让两个3代价的展开，出现3,4,2,4的代价。</li><li>展开2代价的点。</li><li>$\cdots$</li></ol><h1 id="5-分支限界法"><a href="#5-分支限界法" class="headerlink" title="5.分支限界法"></a>5.分支限界法</h1><p>除此之外，我们可以采用这样的模式：把不可行的解都排除，只留下可行的解，再在可行解空间内讨论最优解。</p><h1 id="6-旅行商问题（TSP）"><a href="#6-旅行商问题（TSP）" class="headerlink" title="6.旅行商问题（TSP）"></a>6.旅行商问题（TSP）</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个有向图，这个图满足如下条件：</p><ol><li>每个节点都没有到自己的边。</li><li>每对节点间都有一条非负加权边。</li></ol><p>输出从任意一个节点开始，经过每个节点一次，最终返回开始节点的最短路径。</p><p>对于这个问题，我们采用如下的步骤求解：</p><ol><li>将所有解集合作为树根，设定一个基础代价，由代价矩阵计算所有解的代价的下界。</li><li>用爬山法递归地划分解空间，得到二叉树。</li></ol><p>划分过程：</p><ol><li>选择图上的任意一条边$(i,j)$划分，该划分要让左子树代价下界不变，右子树代价下界增加最大；且所有不包含$(i,j)$的解集合作为左子树，不包含的解集合作为右子树。</li><li>计算左右子树代价下界。</li></ol><p>划分到最后会出现一个解，这个解的代价$\alpha$是所有解的代价上界，如果对于其他子节点来说，它们的下界超过了$\alpha$，就停止继续划分。</p><p>这样的求解方法相当于：先将所有解汇总起来，通过二叉树的搜索方法，排除掉那些代价高的，最终筛选出一个低代价的解。</p><h2 id="基础代价的设定"><a href="#基础代价的设定" class="headerlink" title="基础代价的设定"></a>基础代价的设定</h2><p>代价矩阵里，包括着两点间每一条边的长度，如果不存在边，就设为$\infty$，举个例子：<br>$$<br>\left[<br>\begin{matrix}<br>\infty &amp; 3 &amp; 5 &amp; 9\<br>4 &amp; \infty &amp; 6 &amp; 8\<br>7 &amp; 3 &amp; \infty &amp; 2\<br>3 &amp; 5 &amp; 7 &amp; \infty\<br>\end{matrix}<br>\right]<br>$$<br>第$i$行，第$j$列的点表示$(i,j)$的长度。</p><p>基础代价肯定是几条边的长度的和，怎么选呢？我们不妨选择一些最小边，让每一行、每一列都有被选择出来的边。后续根据这些边再构造解。</p><p>我们在每一行都减去一个最小值：<br>$$<br>\left[<br>\begin{matrix}<br>\infty &amp; 0 &amp; 5 &amp; 9\<br>0 &amp; \infty &amp; 6 &amp; 8\<br>7 &amp; 3 &amp; \infty &amp; 0\<br>0 &amp; 5 &amp; 7 &amp; \infty\<br>\end{matrix}<br>\right]<br>$$<br>同时把所有减去的值加起来。这是为什么？</p><p>此外，要求：每一列都有0,每一行都有0。因为我们最终要把每个点都跑一遍。于是矩阵变成：<br>$$<br>\left[<br>\begin{matrix}<br>\infty &amp; 0 &amp; 0 &amp; 9\<br>0 &amp; \infty &amp; 6 &amp; 8\<br>7 &amp; 3 &amp; \infty &amp; 0\<br>0 &amp; 5 &amp; 7 &amp; \infty\<br>\end{matrix}<br>\right]<br>$$<br>初始代价为$3+4+2+3+5&#x3D;17$。这就是我们的代价下界。</p><h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>选择让右子树代价下界增加最多的划分边$(i,j)$，这又怎么选呢？</p><p>左子树代价不能变，所以只能从矩阵中那些为0的边中选择。其次，右子树是不包括划分边的，我们可以在矩阵中把划分边所在的行、列都不予考虑，重新构造代价下界，让剩下的每一行、每一列都出0。</p><p>之后在左右子树内都不断再分，可以选择先分割左子树，最终得到一个代价上界。</p><h1 id="7-A-算法"><a href="#7-A-算法" class="headerlink" title="7.A*算法"></a>7.A*算法</h1><p>一个很有效的搜索最短路径的算法。</p><p>原理：<br>$$<br>f(n)&#x3D;g(n)+h(n)<br>$$<br>其中，对于任一节点$n$，$f(n)$是经过节点$n$到目标节点的代价，$g(n)$是从起始节点到节点$n$的代价，$h(n)$是从节点$n$到目标节点的最小估计代价。</p><p>我们可以采用Best-First算法和BFS算法结合实现对$h(n)$的估计，从起始节点开始跑BFS,每一个节点的$h(n)$就是这个节点所有未被遍历过的边的最小值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux苦痛之路(二)：从Ubuntu到Manjaro</title>
      <link href="/2022/11/10/LinuxRoad2/"/>
      <url>/2022/11/10/LinuxRoad2/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h1><p>某天早上起来开机，发现进入了grub，心下大惊:“这必然是引导文件损坏啦！”。果不其然，登录到系统后，发现报了一连串的错误，打开几个软件后，系统卡得几乎无法工作。由于我的Linux水平还比较小白……那么，不修！直接换系统！</p><p>一直以来，幻都想尝试Arch系的滚动升级版Linux，不仅因为Arch Wiki写得非常非常细致，也因为AUR安装软件包很方便，于是决定试一试比较出名的Manjaro。这篇博文当作Manjaro的踩坑记录和备忘录。</p><h1 id="1-更新源-amp-准许AUR"><a href="#1-更新源-amp-准许AUR" class="headerlink" title="1.更新源&amp;准许AUR"></a>1.更新源&amp;准许AUR</h1><p>由于Manjaro是滚动发行版，更新的话软件大多会更新到最新版，有的甚至是beta版本，这些版本的软件有可能不稳定，建议慎重更新。参考：</p><p><a href="https://wiki.archlinux.org/title/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:System maintenance (简体中文)</a></p><p><a href="https://wiki.archlinux.org/title/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:pacman (简体中文)</a></p><p>更新源为国内源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -c China</span><br></pre></td></tr></table></figure><p>AUR是第三方软件源，参考<a href="https://wiki.archlinux.org/title/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:Arch User Repository (简体中文)</a>，是一个强大的软件源。在“添加&#x2F;删除软件”界面配置。</p><p><img src="/2022/11/10/LinuxRoad2/aur.png"></p><p>如何安装AUR源上的软件呢？举个例子：</p><p><img src="/2022/11/10/LinuxRoad2/aur2.png"></p><p>复制“Git Clone URL”，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;URL&quot;</span></span><br></pre></td></tr></table></figure><p>之后进入该文件夹，里面会有一个PKGBUILD文件，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makepkg ./PKGBUILD</span><br></pre></td></tr></table></figure><p>即可构建出一个安装包出来，之后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -U *.zst</span><br></pre></td></tr></table></figure><p>安装软件包即可。</p><h1 id="2-N卡驱动"><a href="#2-N卡驱动" class="headerlink" title="2.N卡驱动"></a>2.N卡驱动</h1><p>听一些久用Arch的老鸟说，要先把驱动装好，免得后面出现错误，造成损失。在更新驱动之前，我们要知道：</p><p>驱动和内核是有关联的，如果驱动支持的内核版本和机器的内核版本不匹配，很容易出现进不去图形界面等错误。在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia</span><br></pre></td></tr></table></figure><p>查看可安装的驱动版本，安装内核对应版本的驱动即可。</p><h1 id="3-输入法问题"><a href="#3-输入法问题" class="headerlink" title="3.输入法问题"></a>3.输入法问题</h1><p>具体安装，参考<a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:Fcitx5 (简体中文)</a></p><p>至于终端无法输入汉字的问题，请在终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S manjaro-asian-input-support-fcitx5</span><br></pre></td></tr></table></figure><h1 id="4-QQ-amp-微信解决方案"><a href="#4-QQ-amp-微信解决方案" class="headerlink" title="4.QQ&amp;微信解决方案"></a>4.QQ&amp;微信解决方案</h1><p>体验比在Ubuntu下好很多。</p><p>QQ:<a href="https://aur.archlinux.org/packages/com.qq.tim.spark">AUR:com.qq.tim.spark</a></p><p>微信：<a href="https://aur.archlinux.org/packages/deepin-wine-wechat">AUR:deepin-wine-wechat</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】动态规划</title>
      <link href="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="1-何为动态规划？"><a href="#1-何为动态规划？" class="headerlink" title="1.何为动态规划？"></a>1.何为动态规划？</h1><p>书接上文，可以把分治法看作是：把一个问题分成若干个<strong>独立</strong>的子问题。如果子问题不独立呢？</p><p>拿$Fibonacci$数列问题来说，每一个子问题都和其他子问题有关系。这个时候用分治法就不是很合理了，比如说，求解$Fib(5)$就必然要求$Fib(4),Fib(3)$，而求$Fib(4)$还要求一次$Fib(3)$，这就导致，有的子问题要被多次求解，专业点的说法就是<strong>子问题重叠</strong>。</p><p>这时候George说了，“那我们不妨从小问题开始求，把结果都记下来，最后一步步求解到原问题吧”。</p><p>这就是动态规划：把原始问题划分成若干个子问题，求解每个子问题仅一次，并将其结果保存，以后用到时直接存取，不重复计算，节省计算时间。</p><p>什么样的问题适用于动态规划呢？</p><p><strong>优化问题</strong>：问题可能有很多解，每个可能的解都对应有一个值，这个值通常称为代价。优化问题是要在该问题所有可能的解中找到代价最大&#x2F;最小的解，即问题的一个优化解（最优解）。</p><p><strong>重叠问题</strong>:在问题的求解过程中，很多子问题的解将被多次使用。</p><p>动态规划求解的步骤大致为：简化原问题-建立递归方程-求解子问题-求解原问题。</p><h1 id="2-矩阵乘法链"><a href="#2-矩阵乘法链" class="headerlink" title="2.矩阵乘法链"></a>2.矩阵乘法链</h1><p>输入：表达式：$A_1\times A_2\times \cdots\times A_n$，其中$A_i$是$p_{i-1}\times p_i$矩阵。</p><p>输出：乘法的最小代价方法，代价为乘法运算次数。</p><p>最小代价？代价从哪里来？根据矩阵的乘法原理，$A_{10\times 100}\times B_{100\times 5}\times C_{5\times 50}&#x3D;(A\times B)\times C&#x3D;A\times (B\times C)$。对于$(A\times B)\times C$来说，$A\times B$的代价是$10\times 100\times 5&#x3D;5000$，而产出一个$10\times 5$矩阵，与$C$相乘，代价为$10\times 5\times 50&#x3D;2500$，相加得$7500$。同理，$A\times(B\times C)$代价为$75000$。</p><p>引入概念：</p><p>最优子结构：问题最优解由子问题最优解组成。</p><p>讨论下图中所有的乘法方案最优性：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes.png"></p><p>设$C[i,j]$为计算$A_i\times A_{i+1}\times\cdots\times A_j$的最小代价，可以作出代价的递归方程：<br>$$<br>C[i,j]&#x3D;min_{i\leq k&lt; j}{C[i,k]+C[k+1,j]+(i-1)kj},i&lt;j\<br>C[i,j]&#x3D;0,i&#x3D;j<br>$$<br>递归得到两个括号内的最优乘法方案，合并就是最优乘法方案了。但是：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes2.png"></p><p>不难看出有子问题重叠。</p><p>那么根据动态规划的思想，计算$C[i,j]$需要计算出每一个$C[a,b],i\leq a\leq j,a\leq b\leq j$，可作出下图：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes3.png"></p><p>每个红线上的矩阵链长度相同。从最长的对角线一直求到目标长度。</p><p>时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$。</p><h1 id="3-最长公共子序列"><a href="#3-最长公共子序列" class="headerlink" title="3.最长公共子序列"></a>3.最长公共子序列</h1><p>输入：$X&#x3D;(x_1,x_2,x_3,\cdots,x_m),Y&#x3D;(y_1,y_2,y_3,\cdots,y_n)$</p><p>输出：$Z&#x3D;(z_1,z_2,z_3,\cdots)$为$X,Y$最长的公共子序列。</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes4.png"></p><p>由此推得，子问题有重叠性：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes5.png"></p><p>对于$X,Y$的所有子串，可以列出公共子序列长度方程：<br>$$<br>C[i,j] &#x3D; 0\ \ \ \ ij&#x3D;0\<br>C[i,j]&#x3D;C[i-1,j-1]+1\ \ \ \ i,j&gt;0,x_i&#x3D;y_j\<br>C[i,j]&#x3D;Max(C[i,j-1],C[i-1,j])\ \ \ \ i,j&gt;0,x_i\neq y_j<br>$$<br>对于每一个$x_i,y_j$，都依靠上式计算，自底向上求解，即在求$C[i,j]$之前，先求出$C[i-1,j-1],C[i-1,j],C[i,j-1]$，并记录下<strong>此时对应的子问题</strong>，作出下表：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes6.png"></p><p>每一个格子，里面的箭头表示其对应的子问题，比如如果对某个格子来说，$x_i&#x3D;y_j$，箭头就指向$C[i-1,j-1]$；里面的数字代表公共子序列的长度。</p><p>时间复杂度为$O(mn)$，因为要讨论$mn$个元素，而每个元素讨论的时候复杂度是$O(1)$；构造子序列，即查看子序列的具体内容，复杂度是$O(m+n)$，因为可以看作从右下角走到边界。合并起来时间复杂度是$O(mn)$</p><p>空间复杂度是$O(mn)$。</p><h1 id="4-0-1背包问题"><a href="#4-0-1背包问题" class="headerlink" title="4.0-1背包问题"></a>4.0-1背包问题</h1><p>问题概述：给定$n$种物品和一个背包，物品$i$的重量是$w_i$，价值$v_i$, 背包承重为$C$, 问如何选择装入背包的物品，使装入背包中的物品的总价值最大？对于每种物品只能选择完全装入或不装入，一个物品至多装入一次。</p><p>抽象成一个问题：</p><p>输入：给定$C&gt;0,w_i&gt;0,v_i&gt;0,1\leq i \leq n$</p><p>输出：$(x_1,x_2,\cdots,x_n),x_i\in {0,1},Q&#x3D;\sum_{1\leq i\leq n}w_ix_i\leq C$，求满足条件的最大$Q$。</p><p>原问题，记作：$(x_1,x_2,x_3,\cdots,x_n),C$，意思是把$(x_1,x_2,x_3,\cdots,x_n)$装入容量为$C$的背包中，根据是否装第一个物品，可划归成两个子问题：</p><ol><li>$(x_2,x_3,\cdots,x_n),C-w_1$</li><li>$(x_2,x_3,\cdots,x_n),C$</li></ol><p>那么，可以分析出子问题重叠：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes7.png"></p><p>作递归方程，设$C[i,j]$是可选物品为$i,i+1,\cdots,n$，背包容量为$j$时的最大价值：<br>$$<br>C[i,j]&#x3D;C[i+1,j],0\leq j \leq w_i\<br>C[i,j]&#x3D;Max(C[i+1,j],C[i+1,j-w_i]+v_i),j&gt;w_i<br>$$<br>第一个式子的意思是，装不下，只好讨论下一个物品。第二个式子则是讨论装与不装哪个更划算一些。</p><p>根据上面的这个表达式，参考最长公共子序列的计算方式，可以求解。</p><p>时间复杂度是$O(Cn)$，空间复杂度是$O(Cn)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】分治法&amp;减治法</title>
      <link href="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-何为分治？何为减治？"><a href="#1-何为分治？何为减治？" class="headerlink" title="1.何为分治？何为减治？"></a>1.何为分治？何为减治？</h1><p>分治法就是把一个大问题拆成<strong>很多</strong>小问题，然后分别解决，最后归并。</p><p>分治法一般有三个步骤：划分-求解-合并。</p><p>减治就是把问题划归为<strong>一个</strong>小问题，得到原问题解。</p><h1 id="2-二分查找最值"><a href="#2-二分查找最值" class="headerlink" title="2.二分查找最值"></a>2.二分查找最值</h1><p>输入：数组$A$</p><p>输出：数组中的最大值$Max$、最小值$Min$</p><p>划分：把$A$对半拆分，使拆分得到的每个小数组长度不超过2。</p><p>求解：对于每个数组都找出最大最小值。不断比较。</p><p>合并：无需合并，最后输出的数就是最终结果。</p><p>最终比较的次数为$\frac{3n}{2}-2$：</p><p>根据下面的图示：</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/MaxMin.png"></p><p>列出比较次数的递推方程：<br>$$<br>T(n)&#x3D;2T(\frac{n}{2})+2<br>$$<br>加2是因为两半数组比较之后，还要比较输出的最大最小值，由迭代法求得：<br>$$<br>T(n)&#x3D;\frac{3n}{2}-2<br>$$</p><h1 id="3-二进制大整数乘法"><a href="#3-二进制大整数乘法" class="headerlink" title="3.二进制大整数乘法"></a>3.二进制大整数乘法</h1><p>输入：n位二进制整数$X,Y$</p><p>输出：$X,Y$的乘积</p><p>通常分治复杂性为$O(n^2)$，改进分治法可以把复杂度改为$O(n^{1.59})$。</p><h2 id="通常分治法"><a href="#通常分治法" class="headerlink" title="通常分治法"></a>通常分治法</h2><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/BigTimes.png"></p><p>划分：将$X,Y$各自对半分，产生$A,B,C,D$。</p><p>求解&amp;合并：计算$AC,AD,BC,BD$，再计算$AD+BC$，将$AC$左移n位，$AD+BC$左移$\frac{n}{2}$位，从而计算。</p><p>时间复杂性为：<br>$$<br>T(n)&#x3D;4T(\frac{n}{2})+O(n)\to T(n)&#x3D;O(n^2)<br>$$</p><h2 id="改进分治法"><a href="#改进分治法" class="headerlink" title="改进分治法"></a>改进分治法</h2><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/BigTimes2.png"></p><p>这样分割完后，只需要计算$AC,BD,(A+B)(C+D)$即可。</p><p>根据$Master$定理，时间复杂性为：<br>$$<br>T(n)&#x3D;3T(\frac{n}{2})+O(n)\to T(n)&#x3D;O(n^{1.59})<br>$$</p><h1 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h1><p>输入：数组$A$</p><p>输出：排好序的数组$B$</p><p>划分：将数组依照一个参考点$A[i]$分割为两个部分，将比$A[i]$小的元素放在其左，比它大的放在其右。</p><p>求解：递归划分。</p><p>合并：无需合并，直接输出即可。</p><p>最好情况：每次分割，都将数组分割为两个相等的子集合：<br>$$<br>T(n)&#x3D;2T(\frac{n}{2})+\theta (n)\to T(n)&#x3D;\theta(nlogn)<br>$$<br>$\theta(n)$是因为每次分割都要把数组中的元素同分割点作比较，时间复杂度为$\theta(n)$。</p><p>最坏情况：每次分割，所有元素都落在一边：<br>$$<br>T(n)&#x3D;T(n-1)+\theta(n)\to \theta(n^2)<br>$$<br>平均复杂性为$O(nlogn)$。</p><h1 id="5-中位数和顺序统计量"><a href="#5-中位数和顺序统计量" class="headerlink" title="5.中位数和顺序统计量"></a>5.中位数和顺序统计量</h1><p>输入：由$n$个数构成的多重集合$S$和数$k$</p><p>输出：$S$中第$k$小的元素$x$</p><p>划分：分组，每组5个数，最后一组可能小于5个数，用$+\infty$补足。$O(n)$，一次循环即可解决。</p><p>求解：每组数分别插入排序选出中位数($O(n)$)，递归地排序所有中位数($T(\frac{n}{5})$)，并得出所有中位数的中位数$p$。</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/minusAlgorithm.png"></p><p>这样，根据上图我们把$S$划分为三个集合$S_1,S_2,S_3$，它们中的元素分别小于、等于、大于$p$。$O(n)$</p><p>合并：如果$|S_1|\geq k$，递归地在$S_1$中搜索$x$；否则，如果$|S_1|+|S_2|\geq k$，$x&#x3D;p$；否则，$k’&#x3D;k-|S_1|-|S_2|$，递归地在$S_3$中搜索第$k’$小元素。这一步花费是$T(\frac{3n}{4})$，看上面那张图，合并这一步至少删除了$\frac{n}{4}$个元素，只需要在$\frac{3n}{4}$个元素中进行操作。</p><p>时间复杂性：<br>$$<br>T(n)&#x3D;T(\frac{3n}{4})+T(\frac{n}{5})+O(n)\to T(n)&#x3D;O(n)<br>$$</p><h1 id="6-最邻近点对"><a href="#6-最邻近点对" class="headerlink" title="6.最邻近点对"></a>6.最邻近点对</h1><p>输入：欧氏空间上$n$个点的集合$Q$</p><p>输出：$Q$中欧氏距离最近的两个点$A,B$</p><p>划分：按照横&#x2F;纵坐标对各个点进行排序，求解出中位数$m$。依据之将$Q$分割成两个集合$Q_1,Q_2$，两个集合内的坐标点的横&#x2F;纵坐标分别小于、大于$m$。</p><p>求解：如果最后划分的集合中只有两个点，就返回这两个点，否则，递归划分。</p><p>合并：在选择最邻近点的时候，不仅要考虑分割得到的集合，也要考虑分割点和其他点形成的点对。具体怎么实现？首先得到$Q_1,Q_2$中的最短距离$d$，然后在$m\pm d$的范围内寻找是否存在$d’&lt;d$。最多有六个这样的点，证明如下：</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/nearest.png"></p><p>时间复杂性：<br>$$<br>T(n)&#x3D;2T(\frac{n}{2})+O(n)\to T(n)&#x3D;O(nlogn)<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】算法的数学基础</title>
      <link href="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-函数的阶"><a href="#1-函数的阶" class="headerlink" title="1.函数的阶"></a>1.函数的阶</h1><p>$\Theta$为同阶函数，即：<br>$$<br>\Theta(g(n))&#x3D;{f(n)|\exists c_1,c_2&gt;0,n_0,\forall n&gt;n_0,c_1g(n)\leq f(n)\leq c_2g(n)}<br>$$<br>举个例子，<br>$$<br>\frac{1}{2}n^2-3n&#x3D;\Theta(n^2)\<br>6n^3\neq \Theta(n^2)<br>$$<br>$O$为低阶函数，即：<br>$$<br>O(g(n))&#x3D;{f(n)|\exists c&gt;0,n_0,\forall n&gt;n_0,0\leq f(n)\leq cg(n)}<br>$$<br>几何上来看，就是超过一个常数时，$f(n)$不会超过$cg(n)$。</p><p>$\Omega$为高阶函数。</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/funPic.png" alt="image-20221102145353340"></p><h1 id="2-递归方程及其解法"><a href="#2-递归方程及其解法" class="headerlink" title="2.递归方程及其解法"></a>2.递归方程及其解法</h1><p>什么是递归方程呢？由自身定义自身的方程。</p><p>举个例子：<br>$$<br>T(n)&#x3D;T(\frac{n}{2})+3<br>$$<br>就是一个递推方程。值得一提的解法有两种：迭代法、$Master$定理法</p><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>很简单，就是把递归方程循环地展开，把递归式转化为和式，根据级数关系求解，举个例子：</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/recursionEquation.png"></p><h2 id="Master-定理法"><a href="#Master-定理法" class="headerlink" title="$Master$定理法"></a>$Master$定理法</h2><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/masterTh.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux苦痛之路(一)：基本配置篇</title>
      <link href="/2022/11/01/linuxRoad1/"/>
      <url>/2022/11/01/linuxRoad1/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h2><p>最近购置了一台台式机，在配置的时候，突发奇想，“不如安个Linux吧！”。于是安上了Fedora，安完发现发现新版本的Fedora没有网卡驱动，而我手头又没有网线，安装其它驱动也有问题。</p><p>秉持着“能折腾就折腾，不能折腾就逃跑”的思想，我重新安了个Ubuntu 22.04。由于一直都在用windows，感觉linux配置起来没有windows那么简单。</p><p>这篇blog就当作是自己的踩坑记录了。</p><h2 id="1-QQ-amp-微信解决方案"><a href="#1-QQ-amp-微信解决方案" class="headerlink" title="1.QQ&amp;微信解决方案"></a>1.QQ&amp;微信解决方案</h2><p>这两个软件也算是国内相当一部分人没有选择Linux作为主力系统的原因，QQ for Linux做得太垃圾，甚至没有办法登陆。</p><p>一开始想要用原生的wine，一路配置好，发现微信和QQ都非常卡，还容易闪退，只好放弃这个方案。</p><p>后来，幻采用deepin-wine方案，但是网上流传的各大版本都存在依赖的问题，最终尝试后，微信可以在<a href="https://github.com/zq1997/deepin-wine">zq1997’s deepin-wine</a>下运行，有时会报错，但是不影响运行。</p><p>那么QQ呢？QQ在zq1997的deepin-wine下会闪退，采取作者在Issue中提到的方法也无济于事。</p><p>后来幻又尝试了一下docker qq，但是由于版本过低无法登陆。</p><p>最后幻选择不用qq。</p><h2 id="2-Nvidia驱动"><a href="#2-Nvidia驱动" class="headerlink" title="2.Nvidia驱动"></a>2.Nvidia驱动</h2><p>本人的显卡是GeForce GTX 1050Ti。</p><p>先要禁用Nouveau：</p><p>在&#x2F;etc&#x2F;modprobe.d&#x2F;blacklist.conf最后加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>即可。</p><p>在nvidia官网下载驱动文件安装。</p><p>最后用nvidia-smi命令验证即可，能够看到驱动版本就说明安装成功啦。</p><h2 id="3-代替方案"><a href="#3-代替方案" class="headerlink" title="3.代替方案"></a>3.代替方案</h2><p>左边是Linux下软件名，右边是Win下的。</p><p>KeepassX-Keepass2</p><p>Zotero-NoteExpress</p><h2 id="4-字体安装"><a href="#4-字体安装" class="headerlink" title="4.字体安装"></a>4.字体安装</h2><p>各种报告、论文要用到一些特定字体。</p><p>下载下来.ttc,.ttf等类型的字体文件，首先将字体移动到指定文件夹里，更改权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> &lt;fontFiles&gt; /usr/share/fonts/myFonts</span><br><span class="line">sudo <span class="built_in">chmod</span> 644 /usr/share/fonts/myFonts</span><br></pre></td></tr></table></figure><p>接着执行指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache fv</span><br></pre></td></tr></table></figure><p>大功告成。</p><h2 id="5-Hey-Hexo"><a href="#5-Hey-Hexo" class="headerlink" title="5.Hey!Hexo!"></a>5.Hey!Hexo!</h2><p>一直都在考虑把博客迁移到Hexo上面，Gridea的操作还是有些不人性化，同步起来也有问题。在安装Hexo、部署博客的过程中，也出现了不少困难。</p><h3 id="cannot-read-properties"><a href="#cannot-read-properties" class="headerlink" title="cannot read properties"></a>cannot read properties</h3><p>用apt安装好node.js，采用npm安装hexo，结果报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="variable constant_">ERR</span>! <span class="title class_">Cannot</span> read property <span class="string">&#x27;insert&#x27;</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>困扰了将近一天后，突然觉得应该是版本的问题，可能旧版本没有insert这个属性，于是查看node.js的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>分别输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12.22.9</span><br><span class="line">8.5.1</span><br></pre></td></tr></table></figure><p>然后看了看node.js的官网，发现已经出到19.x.x系列了，果然是版本的问题！</p><p>于是卸载node.js，去官网查看<a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions">Ubuntu下node.js的安装方式</a>,最终跟随指引成功安装，也能够安装hexo了。</p><h3 id="权限不够"><a href="#权限不够" class="headerlink" title="权限不够"></a>权限不够</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>报错，其中有permission denied字样，改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>成功安装。</p><h2 id="6-安装Battlefield-1"><a href="#6-安装Battlefield-1" class="headerlink" title="6.安装Battlefield 1"></a>6.安装Battlefield 1</h2><p>让我们来打游戏吧！我想在Ubuntu下安装战地一。很不巧，战地一并不支持Linux下运行，只好寻找一些替代的解决方案。</p><p>wine？太卡了！还有许多不明不白的bug，不算是很好的选择。</p><p>deepin-wine？没有提供战地一的包，安装不了。</p><p>经过搜索，选择lutris。</p><p>从github上安装lutris的稳定版本，安装。</p><p>首先要去lutris注册一个账号，搜索相关的游戏，安装。</p><p>然而由于lutris官网的问题，我们没办法下载游戏，会报错（链接已重置）。</p><p>再搜索……proton！proton是steam play出品的工具，集成了wine等工具。首先我们要切换steam为beta版本，之后在设置-steam play里把Advanced里面的勾勾勾上，然后下载战地一即可。</p><p>在Linux下打游戏没有在Windows下面顺畅，安装游戏很麻烦，玩游戏的时候也能感觉到明显的卡顿。</p><h2 id="7-OBS-Virtual-Camera无法加载"><a href="#7-OBS-Virtual-Camera无法加载" class="headerlink" title="7.OBS Virtual Camera无法加载"></a>7.OBS Virtual Camera无法加载</h2><p>首先安装obs-v4l2sink包，运行obs之前执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -r v4l2loopback</span><br><span class="line">sudo modprobe v4l2loopback devices=1 video_nr=2 exclusive_caps=1 card_label=<span class="string">&quot;VirtualWebCam&quot;</span></span><br></pre></td></tr></table></figure><p>之后打开obs，启动虚拟摄像机，再打开腾讯会议等软件，就能调用虚拟摄像头了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】点亮STM32F103ZE的LED</title>
      <link href="/2022/08/05/STM32_LED/"/>
      <url>/2022/08/05/STM32_LED/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关键词：GPIO、单片机、C语言</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文是自己的单片机学习记录。我会从硬件开始，一步步研究，点亮STM32F103ZE的LED小灯，并使之闪烁。如果能给您一点启发，再好不过。我选择的是正点原子的STM32F103ZET6精英开发板。</p><p>要完成这个任务，你需要：</p><ul><li>Keil uVision5</li><li>FlyMcu（或者其他烧录工具）</li><li>开发板原理图</li><li>STM32参考手册</li><li>一点数字电路和模拟电路的知识</li><li>C语言的基础知识</li></ul><h1 id="一、硬件连接"><a href="#一、硬件连接" class="headerlink" title="一、硬件连接"></a>一、硬件连接</h1><p><img src="/2022/08/05/STM32_LED/1659701072743.png"></p><p>LED0和PB5引脚相连，LED1和PE5相连，那么我们就要操纵这两个GPIO引脚的电平，给高电平还是低电平呢？</p><p><img src="/2022/08/05/STM32_LED/1659701344954.png"></p><p>LED和VCC<a href="%E7%94%B5%E8%B7%AF%E4%BE%9B%E7%94%B5%E7%94%B5%E5%8E%8B">^1</a>3.3V相连，所以我们要在引脚处给予低电平，才能使LED小灯亮起，要让它们闪烁，交替给予高低电平就可以了。</p><h1 id="二、GPIO"><a href="#二、GPIO" class="headerlink" title="二、GPIO"></a>二、GPIO</h1><p>GPIO[^2]口的基本结构如下：</p><p><img src="/2022/08/05/STM32_LED/1659701896357.png"></p><p>几个小元件&#x2F;称谓：</p><ul><li>TTL肖特基触发器：即由TTL元件构成的施密特触发器&#x2F;滞回比较器，可以将模拟信号转化为数字信号。</li><li>上拉&#x2F;下拉电阻：同图中VDD[^3]相连为上拉电阻，VSS[^4]相连为下拉电阻。</li></ul><p>GPIO口的几种输入模式：</p><ul><li>浮空输入</li><li>上拉输入</li><li>下拉输入</li><li>模拟输入</li></ul><p>输出模式：</p><ul><li>开漏输出</li><li>开漏复用</li><li>推挽输出</li><li>推挽复用</li></ul><h2 id="浮空输入"><a href="#浮空输入" class="headerlink" title="浮空输入"></a>浮空输入</h2><p>上下拉电阻的开关都不闭合，信号直接通过“IO-触发器-输入数据寄存器”。I&#x2F;O口悬空的时候，输入端电平高低无法确定。</p><h2 id="上拉输入"><a href="#上拉输入" class="headerlink" title="上拉输入"></a>上拉输入</h2><p>在浮空输入基础上，如果上拉电阻的开关闭合，就成了上拉输入模式。I&#x2F;O口悬空时，输入端上拉为高电平。输入低电平时，输出也能为低电平。<font color="red">这里不要错以为输入低电平时，输出由于上拉电阻的影响为高电平！</font></p><h2 id="下拉输入"><a href="#下拉输入" class="headerlink" title="下拉输入"></a>下拉输入</h2><p>在浮空输入的基础上，把下拉电阻的开关闭合，就成了下拉输入模式。I&#x2F;O口悬空时，输入端下拉为低电平。</p><h2 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h2><p>上下拉电阻的开关都不闭合，信号直接通过“IO-模拟输入”至片上外设模块。如果通过触发器，模拟信号会变成数字信号。</p><h2 id="开漏（Open-Drain）和推挽（Push-Pull）"><a href="#开漏（Open-Drain）和推挽（Push-Pull）" class="headerlink" title="开漏（Open-Drain）和推挽（Push-Pull）"></a>开漏（Open-Drain）和推挽（Push-Pull）</h2><p>开漏指输出信号只与NMOS管，而与PMOS管无关。输出为低电平，低电平到达NMOS管栅极，NMOS导通，输出拉至GND[^5]低电平。当高电平到达NMOS管时，不导通，输出悬空。</p><blockquote><p>开漏输出的这一特性一个明显的优势就是可以很方便的调节输出的电平，因为输出电平完全由上拉电阻连接的电源电平决定。所以在需要进行电平转换的地方，非常适合使用开漏输出。<br>开漏输出的这一特性另一个好处在于可以实现”线与”功能，所谓的”线与”指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平。而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件。</p></blockquote><p>推挽指输出信号与PMOS、NMOS管都有关系，低电平令NMOS导通，输出拉低至GND，高电平令PMOS导通，输出拉高至VDD。其电平转换快，但是功耗也高。</p><h2 id="复用输出"><a href="#复用输出" class="headerlink" title="复用输出"></a>复用输出</h2><p>其与另外两种输出的区别就是输出信号的来源不同而已，如图所示。</p><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><p>如何在Keil中创建项目就不再赘述了，具体步骤大概为：创建.c文件-创建项目-引入头文件-把.c文件引入项目中。</p><h2 id="Step-1-LED的初始化函数"><a href="#Step-1-LED的初始化函数" class="headerlink" title="Step 1 LED的初始化函数"></a>Step 1 LED的初始化函数</h2><p>GPIOB,GPIOE分布在APB2总线上，所以使能应该调用APB2的相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE); </span><br></pre></td></tr></table></figure><p>之后，初始化PB5、PE5引脚，设置输入模式、反转速度等等，通过看相关函数的定义，这几句不难写出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Output-Push&amp;Pull</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED0-&gt;PB.5</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Output-Push&amp;Pull</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED1-&gt;PE.5</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOE,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><p>这里将PB5、PE5设置成50MHz的推挽输出。</p><p>然后，我们要设置灯的初态，亮或是灭：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br></pre></td></tr></table></figure><p>这里，我们将PB5、PE5初始状态设为高电平，也就是让LED小灯先灭掉。</p><h2 id="Step2-主函数"><a href="#Step2-主函数" class="headerlink" title="Step2 主函数"></a>Step2 主函数</h2><p>对于单片机来讲，主函数一般是这样的结构——“初始化-死循环”。</p><p>主函数没什么可讲的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED_Init();<span class="comment">//初始化LED</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PB5、PE5变成高电平，LED熄灭</span></span><br><span class="line">        GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">        GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line"></span><br><span class="line">        delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms便于观察情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//PB5、PE5变成低电平，LED亮起</span></span><br><span class="line">        GPIO_ResetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">        GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>喂喂喂，等等！延时函数怎么写哇！正点原子官方给提供了，我会在下一篇文章中研究一下时钟系统。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单纯调库函数属实没多大意思，那些底层的东西，往往才是最有价值的。我写作水平不是很高，诸位凑活着看吧！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/210910238">你彻底弄清GPIO内部结构和各种模式了吗？</a></p><p>[^2]:General Purpose Input Output，通用输入输出<br>[^3]:设备工作电压<br>[^4]:地&#x2F;电源负极，我当作接地来理解<br>[^5]:GrouND，接地<br>[^6]:High Speed Internal<br>[^7]:High Speed External<br>[^8]:Low Speed Internal<br>[^9]:Low Speed External<br>[^10]:Phase Locked Loop，锁相环</p>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
