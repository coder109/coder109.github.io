<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>人工智能技术（一）：基础深度学习模型</title>
      <link href="/2024/11/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/11/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述如何用<code>pytorch</code>编写基础的深度学习架构，并尝试用基础的架构拟合一个加法函数。</p><h2 id="程序代码段"><a href="#程序代码段" class="headerlink" title="程序代码段"></a>程序代码段</h2><p>基本的代码段如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">200</span></span><br><span class="line">lr = <span class="number">1e-2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicPlus</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.l1 = torch.nn.Linear(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.l1(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlusDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 data_num: <span class="number">2000</span>,</span></span><br><span class="line"><span class="params">                 </span>):</span><br><span class="line">        self.data_num = data_num</span><br><span class="line">        data_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_num):</span><br><span class="line">            x = torch.rand(<span class="number">2</span>)</span><br><span class="line">            y = torch.tensor([x[<span class="number">0</span>] + x[<span class="number">1</span>]])</span><br><span class="line">            data_list.append((x, y))</span><br><span class="line">        self.data_list = data_list</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_list[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Setup datasets and dataloaders</span></span><br><span class="line">    train_dataset, val_dataset, eval_dataset = PlusDataset(<span class="number">700</span>), PlusDataset(<span class="number">100</span>), PlusDataset(<span class="number">200</span>)</span><br><span class="line">    train_loader = DataLoader(train_dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">    val_loader = DataLoader(val_dataset, batch_size=<span class="number">32</span>)</span><br><span class="line">    eval_loader = DataLoader(eval_dataset, batch_size=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setup model and training hyperparameters</span></span><br><span class="line">    my_model = BasicPlus()</span><br><span class="line">    loss_fn = torch.nn.MSELoss()</span><br><span class="line">    optimizer = torch.optim.SGD(my_model.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        loss_value = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> batch_idx, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            <span class="comment"># Compute prediction and loss</span></span><br><span class="line">            pred = my_model(x)</span><br><span class="line">            loss = loss_fn(pred, y)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Accumulate Loss for Visualization</span></span><br><span class="line">            loss_value += loss.item()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Backpropagation</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch: <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, Loss: <span class="subst">&#123;loss_value / <span class="built_in">len</span>(train_loader)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Validate</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            val_loss_value = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> val_loader:</span><br><span class="line">                pred = my_model(x)</span><br><span class="line">                loss = loss_fn(pred, y)</span><br><span class="line">                val_loss_value += loss.item()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Validation Loss: <span class="subst">&#123;val_loss_value / <span class="built_in">len</span>(val_loader)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># Eval</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        eval_loss_value = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> eval_loader:</span><br><span class="line">            pred = my_model(x)</span><br><span class="line">            loss = loss_fn(pred, y)</span><br><span class="line">            eval_loss_value += loss.item()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Eval Loss: <span class="subst">&#123;eval_loss_value / <span class="built_in">len</span>(eval_loader)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Visualize the result</span></span><br><span class="line">    <span class="built_in">print</span>(my_model(torch.tensor([<span class="number">1.0</span>, <span class="number">1.0</span>])))</span><br><span class="line">    <span class="built_in">print</span>(my_model(torch.tensor([<span class="number">2.0</span>, <span class="number">2.0</span>])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="步骤说明"><a href="#步骤说明" class="headerlink" title="步骤说明"></a>步骤说明</h2><p>这是一个用<code>pytorch</code>搭建的基础的深度学习代码框架。所有的深度学习流程，都遵循着这样的步骤：</p><ol><li>数据预处理。</li><li>模型加载。</li><li>训练流程的编写。</li><li>模型的测试与保存。</li></ol><h2 id="预备知识：张量"><a href="#预备知识：张量" class="headerlink" title="预备知识：张量"></a>预备知识：张量</h2><p><code>pytorch</code>中，最基本的数据是<code>tensor</code>——张量。<code>pytorch</code>中的张量与其他领域不同，您可以将之理解为<strong>标量、矩阵以及矩阵之矩阵的集合</strong>。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor(<span class="number">1</span>) <span class="comment"># 这是一个标量式的张量，可以看作一个数字（标量），无形状可言</span></span><br><span class="line">torch.tensor([<span class="number">1</span>,<span class="number">2</span>]) <span class="comment"># 这是一个矩阵式的张量，可以看作一个一行二列的矩阵，形状为3</span></span><br><span class="line">torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]) <span class="comment"># 这是一个矩阵式的张量，可以看作一个二行三列的矩阵，形状为2x3 </span></span><br><span class="line">torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]]) <span class="comment"># 这是一个矩阵之矩阵，可以看作一个一行一列的矩阵，成员是一个二行三列的矩阵，形状为1x2x3</span></span><br></pre></td></tr></table></figure><p>您可以通过<code>Tensor.shape</code>来查看一个张量的形状。</p><p>也可以将其理解为，<strong>标量、列表、等长列表之列表的集合。</strong>这是从数据组织的角度，而非计算角度来理解张量。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>深度学习的数据通常按照如下的方法组织：<strong>（输入，预期输出）</strong>。数据集的质量直接影响着模型的表现。</p><p>作为示例，我们所使用的数据集是代码生成的，在应用<code>pytorch</code>编码时，我们首先会将以其他形式组织的数据集，变化为<code>torch.utils.data.Dataset</code>的子类，这个类是将各种各样数据集做规范化的一个类。</p><p>作为子类，我们通常要重写这样三个方法：<code>__init__()</code>、<code>__len__()</code>和<code>__getitem__()</code>。</p><p><code>__init__()</code>是构造器，我们通常在这个方法中对数据做一些预处理，将数据变为（输入，预期输出）这样的格式，并将全部数据转化为可以迭代的结构，便于后续的迭代操作。在上述的示例代码中，我们在这个方法里完成了：导入数据、将数据组织为列表这两个功能。</p><p><code>__len__()</code>方法，需要返回数据集的大小。</p><p><code>__getitem__()</code>方法，则需要完成这样的功能：给定索引，返回数据集中对应的子数据。</p><p>数据预处理的关键在于预处理，通常，在代码编写完毕后，我们要print一些处理后的数据，观察它们的数据、形状是否与预期相符。</p><p>在加载数据为<code>Dataset</code>之后，我们还需要一个<code>DataLoader</code>来将<code>Dataset</code>进一步处理。<code>DataLoader</code>能够完成包括但不限于这样几个工作：对数据集进行分组、打乱数据集顺序等。在实际的训练过程中，如果从<code>Dataset</code>里，每次挑出一个来训练，会很慢，所以训练通常是按照批次（batch）来训练的，<code>DataLoader</code>就完成了这样一个工作。</p><h2 id="模型加载：构造器"><a href="#模型加载：构造器" class="headerlink" title="模型加载：构造器"></a>模型加载：构造器</h2><p>我们通常会借助<code>torch.nn.Module</code>，实现我们的模型。</p><p>我们通常会重写它的两个方法：<code>__init__()</code>和<code>forward()</code>。</p><p>在构造器<code>__init__()</code>中，我们会声明模型的架构，即内部包含哪些层。在我们的示例代码中，我们在构造器里定义了一个线性层（Linear Layer），所谓线性层，实际上功能和这样一个函数类似：<br>$$<br>\mathbf{y}&#x3D;\mathbf{Wx}+\mathbf{b}<br>$$</p><p><code>torch.nn.Linear(2,1)</code>的意思就是，声明上面公式中的$\mathbf{W}$是一个2$\times$1的矩阵。这个2和1代表的是<code>in_features</code>与<code>out_features</code>。所谓<code>feature</code>就是输入的<strong>特征</strong>的数量，如果一个数据，能被表征成<code>torch.tensor([1,2,3])</code>的形式，其特征有3个。</p><p>不过，和线性代数中不同的是，线性层可以对多个数据同时做操作。还记得我们之前说过的<code>DataLoader</code>吗，我们通常用模型+<code>DataLoader</code>的形式进行训练。两个数据组织成<code>torch.tensor([[1,2,3], [1,2,3]])</code>的形式，那么，线性层可以对这两个数据同时处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_layer = torch.nn.Linear(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">test_layer(torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], dtype=torch.<span class="built_in">float</span>)) <span class="comment"># 返回tensor([-1.1655], grad_fn=&lt;ViewBackward0&gt;)</span></span><br><span class="line">test_layer(torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], dtype=torch.<span class="built_in">float</span>)) <span class="comment"># 返回tensor([[-1.1655],[-3.2795]], grad_fn=&lt;AddmmBackward0&gt;)</span></span><br></pre></td></tr></table></figure><p>如果您本地的结果和我不一样，无需担心，因为每次线性层初始化，其权重都会随机生成。</p><h2 id="模型加载：前向传播"><a href="#模型加载：前向传播" class="headerlink" title="模型加载：前向传播"></a>模型加载：前向传播</h2><p>我们来讨论一下<code>forward()</code>方法。这个方法负责<strong>前向传播</strong>。前向传播过程，实际上就是推理过程。您需要在这个方法中编写处理输入的逻辑。依靠在<code>__init__()</code>中预先设置好的层，对输入一步步进行处理。我们的示例代码很简单，其<code>forward()</code>方法实现了这样一个功能，对于输入，经过线性层处理，然后输出。</p><h2 id="训练流程编写"><a href="#训练流程编写" class="headerlink" title="训练流程编写"></a>训练流程编写</h2><p>到目前为止，我们加载好了数据集，也编写了模型架构，让我们开始编写训练代码！</p><p>训练流程通常为：</p><ol start="0"><li><p>初始化数据与模型。</p></li><li><p>迭代数据。</p></li><li><p>依靠模型，生成对输入的预测值。</p></li><li><p>计算预测值与预期的误差。</p></li><li><p>依靠优化器对模型权重进行优化、更新。</p></li></ol><h3 id="第零步：初始化"><a href="#第零步：初始化" class="headerlink" title="第零步：初始化"></a>第零步：初始化</h3><p>这里我们主要谈<code>DataLoader</code>的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataLoader(train_dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>这里的<code>batch_size</code>是批次的大小，即模型同时对多少个数据进行处理，而<code>shuffle</code>参数则表示我们要对数据集进行打乱，我们通常对训练集进行打乱，原因见<a href="#%E9%99%84%E5%BD%95">附录</a>。</p><h3 id="第一步：迭代数据"><a href="#第一步：迭代数据" class="headerlink" title="第一步：迭代数据"></a>第一步：迭代数据</h3><p>我们有时会将<code>DataLoader</code>组织成一个枚举类，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> batch_idx, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br></pre></td></tr></table></figure><p>因为有时，我们需要获取数据的下标信息。</p><h3 id="第二步：生成预测"><a href="#第二步：生成预测" class="headerlink" title="第二步：生成预测"></a>第二步：生成预测</h3><p>由于模型通常已经写好了<code>__call__()</code>方法，直接用<code>model(x)</code>类似的代码段即可。</p><h3 id="第三步：计算误差"><a href="#第三步：计算误差" class="headerlink" title="第三步：计算误差"></a>第三步：计算误差</h3><p>我们会预先设置一些损失函数，来计算误差。损失函数的选择通常是任务敏感的。比如分类任务常用交叉熵损失，预测任务常用均方误差损失。我们想实现一个加法器，那么就是一个预测任务，选用均方误差比较好，其公式为：<br>$$<br>MSE(T)&#x3D;E((T-\theta)^2)&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n(y_i-\hat{y}_i)^2<br>$$<br>选用L1误差函数等也都可以。</p><h3 id="第四步：优化"><a href="#第四步：优化" class="headerlink" title="第四步：优化"></a>第四步：优化</h3><p>优化器是一个根据loss计算梯度，优化模型权重的模块。</p><p>为什么要优化？当然是为了loss最低。这是一个极其显然的想法。此外，我们也知道，现在可以改变的东西，只有模型的权重，所以我们的任务变成了：如何寻找到权重-损失函数的鞍点，横轴是权重，纵轴是损失。怎么找？梯度下降法。</p><p>假设我们的权重只有一个，而损失函数恰好满足$y&#x3D;x^2$这个函数：</p><p><img src="/2024/11/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/Figure_1.png"></p><p>那么我们作这样一张图：</p><p><img src="/2024/11/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/example.png"></p><p>假设我们现在的函数在黑橙交点（这个点也是函数线上的点），为了优化，我们需要<strong>左移</strong>，左移的步长是橘红交点左侧红线的长度，这就引出了我们第一个公式：<br>$$<br>\exist \lambda, F(x-\lambda\nabla F(x_0))&lt;F(x_0)<br>$$<br>其中，$x_0$就是我们的黑橙交点。这个$\lambda$就是学习率(learning rate，代码中的$lr$)。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="训练集、验证集、测试集"><a href="#训练集、验证集、测试集" class="headerlink" title="训练集、验证集、测试集"></a>训练集、验证集、测试集</h3><p>训练集是用于训练、优化模型参数的集合；验证集是在训练过程中，用于推理，检测模型临时训练效果的集合；测试集则是在训练后，单纯用于推理，检测模型训练效果的集合。</p><h3 id="Shuffle的必要性"><a href="#Shuffle的必要性" class="headerlink" title="Shuffle的必要性"></a>Shuffle的必要性</h3><p>假设我们的权重-损失函数有三个鞍点，其中只有一个是最低点。如果不shuffle，假设第一个epoch训练完毕，模型权重到达了一个局部最低点，而非极低点，那么后续的训练有可能无法跳出这个点。为了避免这个，我们通常会打乱数据集，创造更多的数据组合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大模型训练的一些问题</title>
      <link href="/2024/11/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2024/11/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ONLY NOTE</p></blockquote><h1 id="输出重复输入"><a href="#输出重复输入" class="headerlink" title="输出重复输入"></a>输出重复输入</h1><h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>大模型输出重复输入的内容，比如输入为：</p><blockquote><p>You are now an experienced lawyer. Give some advice on this case: …</p></blockquote><p>输出为：</p><blockquote><p>You are now an experienced lawyer. Give some advice on this case: … You are now an experienced lawyer. Give some advice on this case: …</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>修改输入的prompt，使之成为：</p><blockquote><p>You are now an experienced lawyer. Give some advice on this case: … </p><p>Sure, here is the advice:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>痛苦颂</title>
      <link href="/2024/11/04/%E7%97%9B%E8%8B%A6%E9%A2%82/"/>
      <url>/2024/11/04/%E7%97%9B%E8%8B%A6%E9%A2%82/</url>
      
        <content type="html"><![CDATA[<p>有什么是永恒的呢？唯有痛苦，痛苦从不消失，从不减弱。</p><p>痛苦是水，是空气，每每摄入，身体就会传来一阵痛楚。痛苦无处不在，我们的大地上长满了荆棘，万物就在这样的大地上轮转不息。</p><p>泪水流干，言语说尽，痛苦却仍不停止，钻进毛孔，沿着血管进入心脏、进入大脑。</p><p>哪里可有安宁？梦里吗？！不，梦醒时分，泪水将沾湿被褥。这是痛苦的祝福。</p><p>那么，什么是痛苦？</p><p>人生了又死，死亡又生。从痛苦中来，往痛苦中去。人睡了又醒，醒了又睡，短暂的安宁，长久的痛苦。痛苦什么都不是，痛苦就是痛苦本身。</p><p>人们将离开你，友人将死，父母将死，你也将死亡，这是短暂的痛苦。痛苦似乎是任何事物，任何事物都将带来痛苦。</p><p>啊啊，我难以忍受！</p><p>我用享乐来拯救我自己的灵魂，却只有痛苦。美好的筵席岂不终结？戏剧岂不落幕？</p><p>我用省思来拯救我自己的灵魂，却只有痛苦。思考对我有什么益处呢？我岂能想清楚这一切事物呢？</p><p>我闭眼，不看痛苦，以此来拯救我自己的灵魂，却只有痛苦。痛苦还能避而不看吗？它岂会随你的心意呢？</p><p>有人要说，唯有以痛苦对抗痛苦，才会得胜？这岂能是真理呢？难道人们喜爱自杀，如同喜爱蜜糖一样吗？</p><p>痛苦如同走在一条小道上，左边是森林大火，右边是毒水流成的河，散发毒气。小道上有路标，标识着路的尽头是幸存者的营地。可烈焰炙烤着路人，毒气让路人产生幻觉，幻觉把他们引到死那里去。</p><p>痛苦如同在黑暗中行路，黑暗的田野上只有一处光源，可光源炙烤着你，黑暗吞吃着你。人们都说，在黑暗中呆久了，会变成死尸，在光中呆久了，会变为焦炭。可人们又只看见死尸，未曾看见焦炭。</p><p>痛苦就是这样，没什么可以说的了。痛苦是无法言尽的，唯有去感受。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微调大模型的代码库</title>
      <link href="/2024/11/04/%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
      <url>/2024/11/04/%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ONLY NOTE</p></blockquote><h1 id="全量微调"><a href="#全量微调" class="headerlink" title="全量微调"></a>全量微调</h1><p>全量微调是指对大模型的全部参数进行训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> LlamaForCausalLM, LlamaTokenizer</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Trainer, TrainingArguments</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, json_file_path, tokenizer, prompt</span>):</span><br><span class="line">        self.json_blocks = json.load(<span class="built_in">open</span>(json_file_path))</span><br><span class="line">        self.tokenizer = tokenizer</span><br><span class="line">        self.prompt = prompt</span><br><span class="line">        self.max_length = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.json_blocks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        json_block = self.json_blocks[idx]</span><br><span class="line">        src, tgt = json_block[<span class="string">&quot;src&quot;</span>], json_block[<span class="string">&quot;tgt&quot;</span>]</span><br><span class="line">        src = self.prompt + src</span><br><span class="line">        return_dict =&#123;</span><br><span class="line">            <span class="string">&quot;input_ids&quot;</span>: self.tokenizer(src, return_tensors=<span class="string">&quot;pt&quot;</span>, padding=<span class="string">&quot;max_length&quot;</span>, max_length=self.max_length, truncation=<span class="literal">True</span>).input_ids[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&quot;labels&quot;</span>: self.tokenizer(tgt, return_tensors=<span class="string">&quot;pt&quot;</span>, padding=<span class="string">&quot;max_length&quot;</span>, max_length=self.max_length, truncation=<span class="literal">True</span>).input_ids[<span class="number">0</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        return_dict.update(&#123;<span class="string">&quot;attention_mask&quot;</span>: torch.tensor([<span class="number">1</span>] * self.max_length).to(<span class="string">&quot;cuda&quot;</span>)&#125;)</span><br><span class="line">        <span class="keyword">return</span> return_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="comment"># Load Models</span></span><br><span class="line">    tokenizer = LlamaTokenizer.from_pretrained(args.model_name_or_path)</span><br><span class="line">    tokenizer.pad_token = tokenizer.eos_token</span><br><span class="line">    model = LlamaForCausalLM.from_pretrained(</span><br><span class="line">        args.model_name_or_path,</span><br><span class="line">        device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load Data</span></span><br><span class="line">    dataset = CustomDataset(args.dataset, tokenizer, args.prompt)</span><br><span class="line">    <span class="built_in">print</span>(dataset[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define Trainer</span></span><br><span class="line">    training_args = TrainingArguments(</span><br><span class="line">        output_dir=args.model_name_or_path,</span><br><span class="line">        learning_rate=<span class="number">2e-5</span>,</span><br><span class="line">        per_device_train_batch_size=<span class="number">2</span>,</span><br><span class="line">        gradient_accumulation_steps=<span class="number">32</span>,</span><br><span class="line">        warmup_steps=<span class="number">100</span>,</span><br><span class="line">        num_train_epochs=<span class="number">5</span>,</span><br><span class="line">        weight_decay=<span class="number">0.01</span>,</span><br><span class="line">        logging_steps=<span class="number">10</span>,</span><br><span class="line">        save_strategy=<span class="string">&quot;epoch&quot;</span>,</span><br><span class="line">        save_total_limit=<span class="number">5</span>,</span><br><span class="line">        evaluation_strategy=<span class="string">&quot;no&quot;</span>,</span><br><span class="line">        fp16=<span class="literal">True</span>,</span><br><span class="line">        tf32=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    trainer = Trainer(</span><br><span class="line">        model=model,</span><br><span class="line">        tokenizer=tokenizer,</span><br><span class="line">        args=training_args,</span><br><span class="line">        train_dataset=dataset,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train Model</span></span><br><span class="line">    trainer.train()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--model_name_or_path&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;./models/vicuna-7b-v1.5&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;./data/alpha_train_en_de.json&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--prompt&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;Please translate following sentence from English to German: &quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    train(args)</span><br></pre></td></tr></table></figure><h1 id="部分微调"><a href="#部分微调" class="headerlink" title="部分微调"></a>部分微调</h1><p>只是对大模型的一部分进行微调，比如说LoRA。直接在上面的代码增加PEFT的部分即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> LlamaForCausalLM, LlamaTokenizer</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Trainer, TrainingArguments</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig, prepare_model_for_int8_training, get_peft_model, get_peft_model_state_dict, set_peft_model_state_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, json_file_path, tokenizer, prompt</span>):</span><br><span class="line">        self.json_blocks = json.load(<span class="built_in">open</span>(json_file_path))</span><br><span class="line">        self.tokenizer = tokenizer</span><br><span class="line">        self.prompt = prompt</span><br><span class="line">        self.max_length = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.json_blocks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        json_block = self.json_blocks[idx]</span><br><span class="line">        src, tgt = json_block[<span class="string">&quot;src&quot;</span>], json_block[<span class="string">&quot;tgt&quot;</span>]</span><br><span class="line">        src = self.prompt + src</span><br><span class="line">        return_dict =&#123;</span><br><span class="line">            <span class="string">&quot;input_ids&quot;</span>: self.tokenizer(src, return_tensors=<span class="string">&quot;pt&quot;</span>, padding=<span class="string">&quot;max_length&quot;</span>, max_length=self.max_length, truncation=<span class="literal">True</span>).input_ids[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&quot;labels&quot;</span>: self.tokenizer(tgt, return_tensors=<span class="string">&quot;pt&quot;</span>, padding=<span class="string">&quot;max_length&quot;</span>, max_length=self.max_length, truncation=<span class="literal">True</span>).input_ids[<span class="number">0</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        return_dict.update(&#123;<span class="string">&quot;attention_mask&quot;</span>: torch.tensor([<span class="number">1</span>] * self.max_length).to(<span class="string">&quot;cuda&quot;</span>)&#125;)</span><br><span class="line">        <span class="keyword">return</span> return_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="comment"># Load Hyperparameters</span></span><br><span class="line">    peft_config = LoraConfig(</span><br><span class="line">        lora_alpha=<span class="number">16</span>,</span><br><span class="line">        lora_dropout=<span class="number">0.1</span>,</span><br><span class="line">        r=<span class="number">64</span>,</span><br><span class="line">        bias=<span class="string">&quot;none&quot;</span>,</span><br><span class="line">        task_type=<span class="string">&quot;CAUSAL_LM&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load Models</span></span><br><span class="line">    tokenizer = LlamaTokenizer.from_pretrained(args.model_name_or_path)</span><br><span class="line">    tokenizer.pad_token = tokenizer.eos_token</span><br><span class="line">    model = LlamaForCausalLM.from_pretrained(</span><br><span class="line">        args.model_name_or_path,</span><br><span class="line">        device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    model.add_adapter(<span class="string">&quot;lora&quot;</span>, peft_config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load Data</span></span><br><span class="line">    dataset = CustomDataset(args.dataset, tokenizer, args.prompt)</span><br><span class="line">    <span class="built_in">print</span>(dataset[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define Trainer</span></span><br><span class="line">    training_args = TrainingArguments(</span><br><span class="line">        output_dir=args.model_name_or_path,</span><br><span class="line">        learning_rate=<span class="number">2e-5</span>,</span><br><span class="line">        per_device_train_batch_size=<span class="number">2</span>,</span><br><span class="line">        gradient_accumulation_steps=<span class="number">32</span>,</span><br><span class="line">        warmup_steps=<span class="number">100</span>,</span><br><span class="line">        num_train_epochs=<span class="number">5</span>,</span><br><span class="line">        weight_decay=<span class="number">0.01</span>,</span><br><span class="line">        logging_steps=<span class="number">10</span>,</span><br><span class="line">        save_strategy=<span class="string">&quot;epoch&quot;</span>,</span><br><span class="line">        save_total_limit=<span class="number">5</span>,</span><br><span class="line">        evaluation_strategy=<span class="string">&quot;no&quot;</span>,</span><br><span class="line">        fp16=<span class="literal">True</span>,</span><br><span class="line">        tf32=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    trainer = Trainer(</span><br><span class="line">        model=model,</span><br><span class="line">        tokenizer=tokenizer,</span><br><span class="line">        args=training_args,</span><br><span class="line">        train_dataset=dataset,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train Model</span></span><br><span class="line">    trainer.train()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--model_name_or_path&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;./models/vicuna-7b-v1.5&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;./data/alpha_train_en_de.json&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--prompt&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;Please translate following sentence from English to German: &quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    train(args)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建属于自己的MC服务器</title>
      <link href="/2024/10/29/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84MC%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/10/29/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>真不难。</p><h1 id="0-前置工作"><a href="#0-前置工作" class="headerlink" title="0. 前置工作"></a>0. 前置工作</h1><h2 id="确定服务器定位"><a href="#确定服务器定位" class="headerlink" title="确定服务器定位"></a>确定服务器定位</h2><p>常见的MC服务器大概有三种：纯净服、模组服、模组+插件服。模组是用来增添游戏性的，通常会涉及物品的添加、世界维度的添加等，而插件则是用于管理。</p><h3 id="纯净服"><a href="#纯净服" class="headerlink" title="纯净服"></a>纯净服</h3><p>所谓纯净服，就是不加模组和插件，只有原版游戏本身的游戏性、特性，没有第三方内容。这种服务器开起来简单，性能要求小，但是游戏性偏弱。一般适用于小团体内游玩。</p><h3 id="模组服"><a href="#模组服" class="headerlink" title="模组服"></a>模组服</h3><p>模组服，则是在纯净服基础上，增加了一些第三方模组(mod)。这种服务器开起来稍微复杂一些，性能要求稍高，但是游戏性比较强。不过，当玩家数量变多时，容易出现管理问题——没有办法限制玩家恶意炸服的现象。一般适用于小团体内游玩。</p><h3 id="模组-插件服"><a href="#模组-插件服" class="headerlink" title="模组+插件服"></a>模组+插件服</h3><p>这类服务器是在模组服的基础上，额外增加了一些插件，通常是一些管理类插件，比如登陆插件、圈地插件等等。这种服务器开起来很复杂，性能要求最高，游戏性很强。此外，通过借助插件的特性，管理起来也很容易。一般适用于大型服务器，面向公众开放的服务器等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>绘制成一张表，如下：</p><table><thead><tr><th>服务器类型</th><th>游戏性</th><th>性能要求</th><th>开放难度</th></tr></thead><tbody><tr><td>纯净服</td><td>低</td><td>低</td><td>低</td></tr><tr><td>模组服</td><td>中~高</td><td>中~高</td><td>中等</td></tr><tr><td>模组+插件服</td><td>中~高</td><td>高</td><td>高</td></tr></tbody></table><h2 id="确定局域网-x2F-服务器联机"><a href="#确定局域网-x2F-服务器联机" class="headerlink" title="确定局域网&#x2F;服务器联机"></a>确定局域网&#x2F;服务器联机</h2><p>如果你想开放一个私人服务器，只和朋友游玩，人数在2~8人左右，那么推荐局域网联机。</p><p>除此之外，不论是对公众开放，还是想开大型服务器，都推荐购买云服务器。</p><h2 id="确定要游玩的MC版本"><a href="#确定要游玩的MC版本" class="headerlink" title="确定要游玩的MC版本"></a>确定要游玩的MC版本</h2><p>MC版本通常类似于<code>1.12.2</code>或<code>1.20</code>，每个版本通常都有自己的特性。值得注意的是，有一些MC版本的mod较多，如<code>1.16.5</code>、<code>1.12.2</code>、<code>1.7.10</code>等。</p><h2 id="云服务器的性能要求"><a href="#云服务器的性能要求" class="headerlink" title="云服务器的性能要求"></a>云服务器的性能要求</h2><p>服务器通常有两种操作系统：Windows Server和Linux。Windows Server操作简单，但是系统本身占有资源多；Linux操作较复杂，但是系统本身占有资源少。</p><p>具体的硬件配置，参见<a href="https://minecraft.fandom.com/zh/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%9C%80%E6%B1%82/%E6%9C%8D%E5%8A%A1%E5%99%A8">Minecraft Wiki: 服务器&#x2F;需求&#x2F;服务器</a>。</p><h1 id="1-开服方法"><a href="#1-开服方法" class="headerlink" title="1. 开服方法"></a>1. 开服方法</h1><h2 id="Java的下载"><a href="#Java的下载" class="headerlink" title="Java的下载"></a>Java的下载</h2><p>常见的MC服务器都是需要依赖Java运行的。</p><p>Windows的Java下载地址：<a href="https://bell-sw.com/pages/downloads/">链接</a>。至于Linux，每个发行版都不同，请参考相关发行版的Wiki。至于MC版本和Java版本的对照，摘自Minecraft Wiki：</p><blockquote><ol><li>从1.12（17w13a）开始，运行Minecraft的最低要求是Java 8。若玩家不知道设备是否安装了Java 8，那么安装程序默认会自动安装并使用支持Minecraft运行的Java。</li><li>从1.17（21w19a）开始，运行Minecraft的最低要求是Java 16。</li><li>从1.18（1.18-pre2）开始，运行Minecraft的最低要求是Java 17。</li><li>从1.20.5（24w14a）开始，运行Minecraft的最低要求是Java 21，且操作系统要求为64位。</li></ol></blockquote><h2 id="核心的下载"><a href="#核心的下载" class="headerlink" title="核心的下载"></a>核心的下载</h2><p>核心相当于一个服务器程序，它能够自动帮你配置环境，下载一些依赖包，搭建起最基本的mc服务器环境。</p><p>常见的核心有这么几个：</p><ol><li><code>Minecraft Server</code>，该核心是创建纯净服务器的核心，由官方发布。下载地址在这里：<a href="https://mcversions.net/">mcversions.net</a>。</li><li><code>Mohist</code>，该核心可以创建模组+插件服。</li><li><code>CatServer</code>，开源，该核心可以创建模组+插件服。</li><li>…</li></ol><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>这里我们用<code>CatServer+Windows</code>做演示。</p><p>假设我们已经下载下来了<code>CatServer.jar</code>，那么我们可以用如下的方法进行配置，首先编写一个<code>.bat</code>后缀的批处理程序：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx16g -jar CatServer.jar</span><br></pre></td></tr></table></figure><p><code>.jar</code>后缀的文件需要依靠<code>java</code>运行，后面的<code>-Xmx</code>参数，是指定该<code>.jar</code>文件可以使用的最大内存量，<code>-jar</code>参数则指定要运行哪个<code>.jar</code>文件。</p><p>如果你有多个<code>java</code>版本，那么也可以用如下的方法运行：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Java <span class="built_in">Path</span>/ -Xmx16g -jar CatServer.jar</span><br></pre></td></tr></table></figure><p>将<code>/Java Path/</code>换成想使用的<code>java</code>地址即可。</p><p>运行时，该程序会自动下载依赖的文件。其会自动创建<code>mods</code>和<code>plugins</code>文件夹。</p><h2 id="模组的装填"><a href="#模组的装填" class="headerlink" title="模组的装填"></a>模组的装填</h2><p>模组可以在<code>mcmod.cn</code>网站进行下载。我的建议是，先想好想要玩哪些模组，先下载到本地，然后手动处理模组之间的冲突问题，当没有冲突的时候，再将模组上传到服务器的<code>mods</code>文件夹下。</p><h2 id="插件的装填"><a href="#插件的装填" class="headerlink" title="插件的装填"></a>插件的装填</h2><p>插件则可以在<a href="https://mineplugin.org/%E9%A6%96%E9%A1%B5">MC插件百科</a>检索。插件通常位于<code>plugins</code>文件夹内。</p><h1 id="2-连接方法"><a href="#2-连接方法" class="headerlink" title="2. 连接方法"></a>2. 连接方法</h1><p>客户端只要保证：</p><ol><li>mod版本正确。</li><li>MC版本正确。</li><li>forge版本正确。</li></ol><p>即可连接到服务器。所谓正确，就是指和服务器端一致。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>铁与冰</title>
      <link href="/2024/10/21/%E7%88%B1/"/>
      <url>/2024/10/21/%E7%88%B1/</url>
      
        <content type="html"><![CDATA[<p>又是同样的感觉，这种感觉在我四周形成透明的高墙，形成一个独属于我的房间。我可以看到外面在发生什么，但我没办法触摸到墙外面的东西。人们从我的身边、身体里穿过，他们看不见我。</p><p>这个房间里有一张椅子，一张棕色的椅子。我坐在上面，软软的，很是舒服。</p><p>我看着我周围的人，看着他们脸上的表情，看着他们匆匆走过。可我什么也没说，一点地方也没动，我只是看着。</p><p>“就这样吧！”我喊了一声。</p><p>随后，我四周的一切开始脱落，就像是老居民楼的外墙一样，开始脱落，那些碎片逐渐黯淡，留下黑色的幕布背景。</p><p>我站起身，掀开眼前的幕布。</p><hr><p>我面前的场景切换了。</p><p>我回到了我的母校，我的教室这个熟悉而陌生的地方。阳光温暖，顺着窗子洒进来。我看见年轻的我自己坐在窗边的位置上，旁边是一个女孩子。</p><p>我走进屋，走到他们的旁边。我看到我的胸口正在流血，鲜血染红了校服，滴在地上，那个女孩子的脸模糊不清。可他们好像没看到鲜血一样，自顾自聊着天。我一个字也听不清。</p><p>窗外正举办着运动会，有人在比赛，有人在助威，围绕着操场是一个个红色的帐篷。呐喊声模模糊糊的，有回声，听不真实。我想打开窗子，却一点劲也使不上。我就站在那里。</p><p>我看着年轻的我，他是那样的开心，那个女孩也是。</p><p>我听见身后有人在喊我。转过身去，那里什么都没有，只有黑暗——幕布。</p><p>我走近去，掀开眼前的幕布。</p><hr><p>我面前的场景切换了。</p><p>这里是我的家。我看着我自己躺在床上，盯着天花板，眼泪流淌。</p><p>我坐在他旁边。</p><p>他什么也没说，只是在不停地打寒颤。我看着他旁边的分数排名表，所有的名字都是我的，所有的分数都是满分，可总分是零。</p><p>窗外黑洞洞的，偶有烟花绽放。</p><p>我忽然回头看向日历，是春节。</p><p>我叹了口气，转过身去，掀开幕布。</p><hr><p>我面前的场景切换了。</p><p>我前面有一个祭坛，一个放映机。</p><p>祭坛左边是一块铁，右边是一块冰，中间是一个录像带。</p><p>我拿起录像带，插进放映机，打开开关。</p><hr><p>我回到了我的母校，我的教室这个熟悉而陌生的地方。阳光温暖，顺着窗子洒进来。我看见年轻的我自己坐在窗边的位置上，旁边是一个女孩子。</p><p>我走进屋，走到他们的旁边。我看到我的胸口正在流血，鲜血染红了校服，滴在地上，那个女孩子的脸模糊不清。可他们好像没看到鲜血一样，自顾自聊着天。我一个字也听不清。</p><p>窗外正举办着运动会，有人在比赛，有人在助威，围绕着操场是一个个红色的帐篷。呐喊声模模糊糊的，有回声，听不真实。我想打开窗子，却一点劲也使不上。我就站在那里。</p><p>我看着年轻的我，他是那样的伤心，那个女孩也是。</p><p>那个女孩只说了一句：</p><p>“你没有心！”</p><p>随后离去。</p><p>我转过身去，那里什么都没有，只有黑暗——幕布。</p><p>我走近去，掀开眼前的幕布。</p><hr><p>我回到了这个地方。</p><p>我面前只有一个祭坛。</p><p>我将铁与冰贴在一起，放进我的胸腔，那里空无一物，正滴着血，血与脓。</p><hr><p>时间消逝。</p><p>铁被我的血液与脓腐化，只留下红色的铁锈；而冰被我的体温融化，化作一滩水。</p><p>二者混合在一起，变成红黄色的液体。</p><p>我的胸腔又变的空空如也了。</p><hr><p>我在等那个感觉，等它再一次袭击我。</p><p>一切都注定了，故事的结局，早已注定。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯粹隐喻</title>
      <link href="/2024/09/27/%E7%BA%AF%E7%B2%B9%E9%9A%90%E5%96%BB/"/>
      <url>/2024/09/27/%E7%BA%AF%E7%B2%B9%E9%9A%90%E5%96%BB/</url>
      
        <content type="html"><![CDATA[<p>死亡一直在窥伺着我——用它那长而鲜红的信子引诱着我，想让我堕入那甘甜而温柔的永夜中去。那永夜里什么都有，在你死掉的那一刻，你就已经什么都有了。</p><p>“不要怕，待在我身边，安心地睡去吧。”死亡低声说着。自古以来没有人能够逃离死亡的引诱，无数仁人志士——或者地痞流氓——的肉身最终都化作尘土，而灵魂却在死亡中拥有了一切——无尽的幸福与安宁。不论生前如何，死后都是一样的。</p><p>有人问，死神是什么？死神其实什么也不是——死神不是实体，而是死亡的效应。死亡就是死亡，既不是生命的缺失，也不是消逝的充盈——死亡就是死亡本身。不要崇拜死神，而要去爱死亡——归宿。</p><p>可我终究不懂，既然死亡是归宿，我要这生命有何意义呢？死亡环伺四周，它显然早已习惯了人们问这样那样的问题，有关生死，有关命运，有关一切的一切，有关本源的本源。它不回答，只是默默地看着我。它的眼睛里，是海，是风，是阳光与一切美好的事物。只有拥有过生命，才能明白死亡是多么的伟大。</p><p>可我所要的，真是美好的事物、安宁与幸福吗？死亡闭上了眼睛，转过身去不看我。我知道，我是建立在痛苦与孤独之上的，追求美好、安宁与幸福，是终究不得的，死亡所带来的，无非是掩饰罢了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物哀</title>
      <link href="/2024/09/08/%E7%89%A9%E5%93%80/"/>
      <url>/2024/09/08/%E7%89%A9%E5%93%80/</url>
      
        <content type="html"><![CDATA[<p>我太久没更新了，因为我不知道写些什么好。</p><p>我的生活很平静，没什么事可干，每天打打游戏看看视频就过去了。每天都是一样的，没什么好写的。</p><h1 id="庸俗哲学论"><a href="#庸俗哲学论" class="headerlink" title="庸俗哲学论"></a>庸俗哲学论</h1><p>世界很大，我很小。不过，万物都是有本源的吧。我已经太久没有思考过这个问题了。德勒兹、《圣经》，结合起来就是一个逻辑极其完善的世界论模型。我懒得再去思考了。思考带来不了任何东西。我的思想已经从根系腐烂了。</p><p>我宁愿不去思考，不如将“目之所及，抑或耳之所闻，抑或身之所触，都收纳于心，加以体味，加以理解”。如今，我更关注自己的感觉，而非自己的逻辑。那些形而上学的东西——意识形态、世界论、本体论，到最后什么都改变不了，甚至连“物”本身都无法触及。毫无意义。</p><p>不如好好去生活，去享受快乐的人生。多体验事物，就足够了。<strong>有些事情这辈子改变不了了</strong>，不如向未来而生。</p><p>哲学学得越多，思考得越多，就越贴近学哲学之前，学会思考之前的天真状态。什么都没变，什么都变了。</p><p>万物行将朽腐，行将归于黑暗与光明，然后行将轮回（是的，我是轮回论的坚定信奉者）。用TNO的一句话做结——</p><p>“致瞬息万变之物，致亘古不变之物”。</p><h1 id="蓝天、阳光"><a href="#蓝天、阳光" class="headerlink" title="蓝天、阳光"></a>蓝天、阳光</h1><p>秋天到了，天好蓝，阳光好暖和。</p><p>秋天到了，冬天还会远吗？</p><p>比起花开花落，秋高气爽。我更喜欢大雪纷飞。</p><p>我喜欢冷一些的天气。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞬息万变之物，亘古不变之物</title>
      <link href="/2024/08/08/%E7%9E%AC%E6%81%AF%E4%B8%87%E5%8F%98%E4%B9%8B%E7%89%A9%EF%BC%8C%E4%BA%98%E5%8F%A4%E4%B8%8D%E5%8F%98%E4%B9%8B%E7%89%A9/"/>
      <url>/2024/08/08/%E7%9E%AC%E6%81%AF%E4%B8%87%E5%8F%98%E4%B9%8B%E7%89%A9%EF%BC%8C%E4%BA%98%E5%8F%A4%E4%B8%8D%E5%8F%98%E4%B9%8B%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4576802cac05807d6f4272dad50e50f8b574e245da26a1139a7ec41e58daeef8">57061eb5ad726e87efc47a522f4a40303dcc7d561385ed162ba1e12a401e189ccb891785299607c5c4d752ec55c9ddeee29943a96a4519e00ae7f986dd05b9a07e363fd7932feab8ee669c3cbbb4560666d792d78405b48477bd583dc2e4f776f4add5eff3f2439b19a689bd80a8666c8a895623988d3460d9484b4a7c750a3f0474aef6750cf49842eed2a4e5584445600f9d5a7a6c8aa3e1ddfa0728a47051b347a4de25d77e7aed5ac95c5c95ac459799d510ccadc89fa48e00bf194e2f11be70dcd7897dba7e6508d7ffe9baff7d216d837aa9fcb0e201d47187d83909b0b1c02b5500e55775732637f0b998169a6ed5e4e15b209f58346ae84431d36e210d0518b26a2ff0ae61c16ec30bbc9d4bed37c1be39a4978cbf5136faa91bd7703cf43640f482531e0791d1fc6860b97aba1b2254772bbc2c20cef4ee0edb943b394884ad75921d73f6057d32e487472758f7b69fa931d6528aa6497ba95f5825bc77c57f77934d585ec05b6f32b0e92ffb2eae99c55390d12eb4d755f9f2c31bf651667c7d0fdcace9d04ad10ab6229ef03fcb89b6b87792416b5697d6d904d031541bb153cff774a8b8e7d546071ac1cc7995701ed5827c29dda952820b9b38130d749416154005e168f3445089fc528dd0e585a4bac0edc4f97ecb89f0c3e0cd04d794eb91e93e2cc412712cdf4daa9c890e22144c25529532d84c6cce95378e2e6f774116dac0648877699c9fe9d28638c931b9bf04c7b3cc8c20afd607a195518053a3c1cef60c271390ebb0574974e13c0637dff422c64d81579c6e5c57356d2963373d57671a602b8a52ec31a44d4856ab365cf04a84b52f7bbc5fd35f819158900e3427bbcff30a00888107d8d86207d6f5226e1d0de5362fe1290dffd5c40b8126986ad791744a3ed7ed9fe86efc240991497203e75e38f756a721aa6e1d5f95c3eda0177db805505b4588c7f1f578d12f70cac0a4fa1eba8a6102cf059d6dcf330b10622baa4ec4bff9689773cd01861fb909d2e803f9d3d2a1522b327669c1b0fa19c7742a5458620f99a823e2e9d079bf63b0d4a5544ac040eecf17e597e69b5bb4bc46869da129e703be8597936f5058f5ef36f220801ff06c9c35c14ce7c6ae3a4b66b5dfe8b58764b71b0f738c0b81523ca4513b15e8cda6df96abb4fdc7b8d2b395692033b8d852ed51c2cac4583a76dd09505ec30ab8d4fd3a1444370f609289f6f6447389b720663d5bdcb22bc753e4704476c61362094e8de18b35bd502955ba97ddbe4e8c38ce277712e17d70d962723dabc930ec24301e2424f8270bf9bce2eeff2b6ef7fe26e64ee1ff727bb98e28d4028856e10a7521fcc628a34d05adc23264e405e7960b7f6e6e2f7bd8d747393138e353dea9b139ededb525e0b4d619a9e054653b30f4f91a8e1fe097e8c742f7505a1235a31fb2586778d4ff5357f974ddf451efb723c5174bf4d87d470d609ca3fc420ef508548745a63904ae42f66b1d5c339b31e335f70c77e414b039c4d16ee13066ffa13cba2cadbed58ae206d38821ec7bd14232d1a9bfbedfe0cb9f054729b65e069d1d56075afe52d083131bd492b04d6e8d4ee70c20c9200524675be083d2b084cbb9575e9707d659b057ef55b984f36d205641252f58d42c8b51881ba1ae752d9389d35ed3da39b04b569bb3867204a7c03b76d59e7c67a244fc482d81b73b3c9f8870498cd2fcfde84d927babc02cbacf937642b14181dbc8f874e2cc0762df4924ae461cbd92ae47ad6795b5dac9043b91b04dfcb5089647b470a66503fb252888ed64dce8eee414cd64baf267fa6a9c310f56ca4b83cd53a42b57fd5689a129efa3c5a2f772fae1f956125385bffe054ae6bd7b809e9eb4f933c43d271de1043ce845bb73a5e120129b6cd3363256e451dbf19966215d6dbf31cd8431b740f2fc007a47b643653ac553bf2307c7f9dc5651e5f6f3a8accb0cadecbd935b3ab3bdeea6d3567dae3e29dfe737614d887d20f6856fad476a0bfddb53f2d540ea3a43c8c6243304e235b505e2046c88856cf84f71ebc393a595d418c3dc411c045714c9d3a56159ab754e3f5ba2b865472d28d2e14df31a13cf5d43fda2aa03a8cc81cc5a6725b58fe7bde659a4e0561f5dd4722816e698f121d59e0ecfe1ae193e4669eb6e8ac6448066b6cd832c1dc19d38f0b7c3d3a809de599af318b3fc39a879c696f8c299bbe806525e9f80a1e2afd3e30752d2f871ce71681073e8d5d6560a625d5cedde8972275bdc2d08bcc0a90a9bf8193c3f84c7cbf49c54a1b7261ab639770e41cad55405425e669e8de991f2557f192efa22bfd3805e32ac6e8d627c9fb2e0b77b75a89f543dc9b83e15f8921053ce0be8414906321bce093382214e0e34eed26acf929b411aae2fa62be0fe4cf403cd5c882e7a516c64ab09545d3ced5814a22fde93c3283001f2899f9d651a2815d668e9d8895775acd9113fde932a73adf56e4223720c87e782bb663cfe155b21bf764f7626c96497dbb7b6687a3a1f0aca92aa055e885635ff0a04cfa62b410df4c2df45e7bfd04bb9ff46e767c9253489ebc60bf03cbfb6cf7a2b7b06902a93b03adde0fedc5e429c1b2a33aab46aba9fa855264ced691c92f4fde8df5a3c537e39975a8e09d167fe7003960ad966bee0ada1a0070735022addf6fe7d58c50c2bd85db2ad33cd85f5a3f11cd7b59e68a8c782774b5cad49064ddaa3b21121e57a416a85b810c0142f5e1bf3a6b0c67c5df55bd6884320d3f11aef9b56f149472005496fec60ca59360a0a7e11f98082dfc4ca9c3245b1f39a989c92c2d3120f32cd485ddc46277beecfaa9711f429b596ba2965978876ff433fd292e77c19b51afb6655070fad20090c38aeedf5e9061006cf69e4443ff7892348820a66e4b8f3ac26be73bd5508ab386fe2422284d6882161ac163747fd301507eb9f5a46d259c759e1daf924b9c33ab2eae63fb6397f99890e30d4034e3045a7c059ef3f62f7edc6767dd40e2869bda72214b53f24940bf5502349c4198591efc784ac8170b33675c4d8ae841998b28290424cf8037d00bb37b553c647747c5e4bed751cb6ed28db1c8cb7d24ba7eecb8acad2c94735886005c60f2ace23fa73975a112c14918f403a44f223e3689311ebd475ec5f234946cf4dd3b06054cc8dd056935feb19664a7a782d8e7f91bbe9304581c7723407bd800273d1be5b90ba3fd63db73a7a62ae41cb39d53e4371ff7228ead3286125b7b2ebfa8087caeb163882f188e7951a6c6dec6121bf1c5c9c33eab596b45e143c0d4412037549a27c8615ba852e8d02fef6e235d8cfac661ce3db79a2396f83218609c9b6094a73dc522e1f14ff5dcba48e783479813041793690f8e3a464ddd03789a4aac5d3dfffb73b3b991a4ab8cf6be52435d370abe108fbe5be8112d5958dda2c0e62f59e5de518a7cae4d235c4c01021575f25259c43ad485033199e99ee3a3b508d3eafb7857f5f202f35b7ecf8da66593faca983b5330dbaee1f4e54e87f45297b9b4b1bb4ac9402ab1fc6b90c8f03d683c81f7768462660eb987d7ab0e638f8ab6c58a1e2c584d4a253c9fd615eaa48aa17d8ebef0ddaefa72b995f6ff2de8ac04f57098662eef60087eb42cdd4f434352e7433e57450b4a7eea76e1359a55097e9a0ad4eb8cf60f6aea70ae1493a5aebe3fe54e672a487a30ba87ab7a95f74ec905a32cb0718d161cb1714f8fa83aa768f4b08a9cbbba627c12d85757b3ff30bc2d8058d2294997679611980b33cc736f4d9022625fc0fe97f7d8f9e9ebfef7d39f84b5917752c573ab1f298e6fbc94449ed8f59fa4b44f668ad7c7e97350a05f85a6137a9e889421e7eb8baef206be6a52a604679d68a8fe34a6b70fc294c6b91440be64d7b2dcf98f118b06d798d08fbfbd940a1ee71b6fa2f070f454f4f2c6bb55e4f89487374151beda704db41aa59d4b3a7970f7a50294e99e83343abdcfb33b6149b8710098aebed44f246b71581e65b9137f4529074878be65db6680d9a327f701df2335e8ee86735db8dea4621f4c5dbf200961a9ec53c778cf91ca784f5df7cbd6b24c15900ed10926bd869b157431001b25d11fa76d3fb81afc8aa867c6c03227077744adb8ea25035a8bbd526b4d7ead8af3384a60f1f5f32a436aae20a307c69275420f965a3a964e77c50038ed14552e2e5fc8201860cef10164a61b2049ef79b42af3d26360bb7d6138b27230b4a7cf375c2c2bb8a27b4fce79ee5c6c9bf93543db89cfa129d76a80d9d2f7fa4f026820288c77128d048c12916a8dc699929909288a35dc4600b56858143fcf13ae3fee40c49c09f2f0ba333dfde248f2c28bb5177f67dc071288dc5332b10b47de2f3b3a57ab8565ace339b3fbb8ea17c2bc24be4789b10385b0dad3f1dbaedf91dde0d9d5e9ac951079d87eddaaba6c0b2a89ef7dde3e9f5affb8ef4caa7061a59c156da85dd5d571177d3d6caf8a246f32f21b35ddf6aa7e87eb2fab20c16857e5dccb80f072ff81f577f59fafeba862598e1021fe625544d35c8abd493ab47e5397b8786d50762b06a151808b4ac8f3829738975abb74b8ef38205886a5b86c281b76910ca4bfe3dbf9e42e9028bad142940349ca831875532b1f7394e400463a24f6cb312c6a5a7a222a81c61d191b02358b8c6f38c4b7b137752528734f708566aed46d01dde1111fda4d7df75dfa0239ac89fb4b61a08b46d7146e6e1c87852ecdf99154f19d1b1970793d55d34da8a4f6c2a9f8b656728f9e132088711b656d164f0b63cf0e7f8aa08714b44764b28d1b47aefd07fe1fe4f0b4c5a401198aedbdef32843b7a2f1507d745f2532390f261b957bdf069d5cebf7069f2ced0754a6f986c90fd15a001aa7a5e3668dd23c0ad713de8577df9099644732d2921e32d85b6e15e1197016651412c9b8a386c9e6e1d2e4e42d64d4637174ce250ae297ae14bb47fd06aee8d73468a9173288fb87a84b04405d7f407b3de680cc7255c17be3c38adea53afd7f763306921621da8f891d9c5b22a9a98219eecba44eed7d891832ac38684e96e9c98b11c011293a4ae10040ae1d732a64fe7c09113a92a2a60e6240ebfa3a2e1a264f16dc5996f7045cf0cbe76cc41a94abd14dcf2cdf69611e46198e3898d5be15c1e60adbd78d9a09a9093c9a0c16c073346e5fe5658b4ebad33d731fb251588311c77eb7637cc497a8ea0db587e76382e8d999e82f90e588877a93bd73d24d809207caafbcfdfbabf62f45bdd9f37f7ce55c6e2ba712f14902bb337da83c7f27a53cb4bd78f842a73e67f083c1698cdfbd67aee0ff16960245d9c80fad91193163d196f68cddd82655fcfdabcba8894293f68c314f448c461f0939204b426e14b0fc2fce2143b41f48603c06793c4e5d49589b509b1497acd991b359f375c2d2351263ded15ae9c0940827faf824b73948b0f36ef5130c4299ae29ddcf1764db851417cfedbf618ad89c971e7f849ebc25a0e1a2465c72d369172321a1536df0cf8e1d874410dc02f96b6574cab701c38673267e25b7ae544c0a4d293bdea65deb898df5e3212cdb42be6e0db2faa49caea9ae3a6d3ffd217de9d6008824f38453e317df33a1741bdcc2e805fa31a85f0a2efe03b90ef65881baef1625a6b2417f3f9462e65d617c3612d061d6d9cc614cdb3ff4dce18aa6c0f93b2a355a9755e1fd4a98a76eb139b9c00cfeeafb86a3542ce5f33b8e8a562d7d1a649eaf606aae7b9942211c210ff2ef64b9947e1fa6bf49b4ebb63273992272979510b8f5cdcaf544d2421888983600e1f2ea9e45e8b251706b704ce7b35288d603ef046b2b7790a588567caa1520118531bd301869e4d182cb44ff53e7a95c4b229ac3638f94ab8c9c4cd415b457ea5a5ffcdc2042679f74ea274a617d0c6443c1834f8f0a44b46f507ee1ba838b6a2edc9f408c7fbc6a6d9846e4c9cd937a838580c438b562666c0628f3216f0fe4cb3591d35a8b9974955248ea31be826d1befbb534ff3d13e18b9d6b6bfb2221fdb23130d93f7f8932c09d1406068beaef7d5476e90d425056fb6c21f6e144427d09b35855a2b5883017a4c29cbec496aa71d79640b59ecdb689da95748cf4e8353c11ba8405a18fb16</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德勒兹：无中心的游牧</title>
      <link href="/2024/07/30/%E5%BE%B7%E5%8B%92%E5%85%B9%EF%BC%9A%E6%97%A0%E4%B8%AD%E5%BF%83%E7%9A%84%E6%B8%B8%E7%89%A7/"/>
      <url>/2024/07/30/%E5%BE%B7%E5%8B%92%E5%85%B9%EF%BC%9A%E6%97%A0%E4%B8%AD%E5%BF%83%E7%9A%84%E6%B8%B8%E7%89%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面对着我们内外最为机械、最为刻板的重复，我们从中不断地提取出微小的差异、变易和变状——这便是我们的现代生活。——德勒兹《差异与重复》</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我阅读德勒兹，差不多是和阅读拉康同时开始的。然而，由于国内德勒兹的资料较少，译本也少，我对于其思想的理解难免出现偏差。目前对于德勒兹研究最多的国家，似乎是日本——等我再学一阵日语，我说不定会修改这篇文章。</p><p>我之前说过，在我这里，德勒兹提供了一个完美的、精巧的形而上学模型。</p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>如果说，在拉康那里，欲望是无法触及之物，是人类与生俱来的原罪，那么，在德勒兹那里，欲望就是一种革命性的力量，是主观能动性的基石，它驱使人们去改变世界。</p><p>如果说，在现代心理学那里，精神分裂是一种疾病，那么，在德勒兹那里，精神分裂代表着彻底的革命性，代表着无尽的可能性。</p><h1 id="本体论：块茎"><a href="#本体论：块茎" class="headerlink" title="本体论：块茎"></a>本体论：块茎</h1><p>万物皆是块茎(rhizome)。</p><p>什么意思？</p><p>首先，我们不得不提到康德。康德认为，物体本身是无法被认知的，我们只能通过经验来认知物体，而经验，即是语言。</p><p>而语言，则可以看作一个一个的能指&#x2F;符号，分散在我们的认知世界中。我们对于一个事物的认知，可以看作某些能指的相互作用。这样，这些能指搭建起来了一张网——如同植物彼此相连的块茎，如同真菌的菌丝一样——任意两个能指之间都彼此作用，而全部能指的整体，搭建起来了我们对于事物的认知。</p><p>这样的网就叫做块茎——一个植物学的概念。德勒兹的一大特点，就是通过引用其他学科的概念，来搭建自己的哲学框架。</p><p>块茎是无中心的，在《千高原》中，德勒兹通过这种物体的组织模式与树形结构作比较。</p><p>树形结构——参考数据结构中的多叉树结构——有一个根节点，这个根节点对其他的节点有统摄作用，此外，父节点也会统摄自己的子节点。这样的结构是固化的。</p><p>块茎是流动的，因为块茎可以方便地变化，加入一个节点，删除一个节点，都很方便。其实，在德勒兹那里，块茎里面没有点，只有线，纯粹的线。</p><h1 id="变化：结域-解域-再结域"><a href="#变化：结域-解域-再结域" class="headerlink" title="变化：结域-解域-再结域"></a>变化：结域-解域-再结域</h1><p>一切事物，都遵循结域-解域-再结域的过程。</p><p>什么意思？</p><p>块茎是有一个界限、一个轮廓的，通俗理解，就是那些能指和它们之间关系的总和。然而，块茎是不断变化的——比如，在时间、空间上进行解域。</p><p>时间永远向前，我们不妨把世界看作一个视频，每个时刻的世界看作单独的一帧，每一帧每个块茎都有着自己的界限，然而当下一帧来到，这个块茎会变化。比如我面前有一杯水，在现在这一时刻的水，和下一时刻的水，是不一样的，因为它们所处的时间不一样。你可以这样理解：下一刻包含前一刻的全部信息，下一刻又有着自己的信息。</p><p>这其实是柏格森的思想——没有什么东西是完全相同的，这也反驳了哲学上的同一性——忒修斯之船根本不是原来的那个船。</p><p>现在时刻的水，有一个范围，就是结域——凝结出一个范围。然后，随着时间流逝，这个范围抹除了——在现在时刻与下一时刻之间，没有范围——这就是解域。最后，下一时刻，这个水又有一个范围——这就是再结域。</p><p>时间上是这样，空间上也是如此，只不过，空间上的变化没有这么剧烈，比如我面前的这杯水，静置10s，再移动到其它的地方——也是一个这样的过程！</p><p>那么，概念呢？我个人倾向于用集体无意识理解。</p><p>每一时刻，人们都会有全新的想法，这些想法修改了前一时刻的概念，增添了其内涵。</p><p>万物如此。</p><h1 id="控制论：机器"><a href="#控制论：机器" class="headerlink" title="控制论：机器"></a>控制论：机器</h1><p>德勒兹认为，社会是由无数的机器和机器的机器组成的。这是一个极具控制论(cybernetic)色彩的断言。</p><p>机器是什么？机器是这样一种东西——接收输入，产生输出。比如小学，就是一个机器，接收幼童，产出准初中生。</p><p>机器的机器是什么？是由机器组成的机器。宏观看来，机器的机器就是个机器，接收输入，产生输出。然而内部又有很多小机器，这个机器的输出可能是那个机器的输入。</p><p>后德勒兹主义者认为，在很久之前，社会还是规训社会——即权威会告诉你应该做什么。而现在是控制论社会——权威一声不吭，而你的一切已经通过机器们安置好了。</p><p>如今，权威不存在了——正如德勒兹所言——只有机器和机器性的配置。</p><h1 id="欲望：完全的解域"><a href="#欲望：完全的解域" class="headerlink" title="欲望：完全的解域"></a>欲望：完全的解域</h1><p>人是追求完全的解域的——这就是欲望的工作。社会是限制欲望的，将人束缚在一个框里。人希望自己的界限无穷大——万物如此。</p><p>完全的解域即是精神分裂——这时的人已经没有任何束缚和限制了。这里的精神分裂不是病态的精神分裂，而是一种类似于狂喜的状态。</p><p>那么，神经症又是怎么一回事呢？因为没有办法解域——解域的过程被粗暴地中断了。解域是什么？是欲望！</p><p>如同在拉康那里，幼儿时期如果没有办法及时脱离母亲，就会患有一些奇怪的神经症，有一些奇怪的性倒错现象。</p><p>也就是说，分析精神问题的时候，要看哪里的解域出了问题，哪里欲望的释放出了问题。</p><p>正因为万物都是块茎——都是按照结域-解域-再结域的过程发展的，那么分析社会问题、解决问题等，都可以利用这个原理。</p><p>哪里的解域出了问题？哪里的解域出了问题？哪里的解域出了问题？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
            <tag> 德勒兹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精神分析学习手记</title>
      <link href="/2024/07/25/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/"/>
      <url>/2024/07/25/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考资料：《疾風怒濤精神分析入門》· 片岡 一竹</p><blockquote><p>疯狂是比健康更加本源的东西，健康反而是一种被建构的状态。——《疾風怒濤精神分析入門》· 片岡 一竹</p></blockquote><p>人的欲望是永远无法实现的，除非死掉。</p><p>很多情况下，在接近死亡的时候，人会获得快感。这种快感，就叫做享乐。吸烟、喝酒——明知道这些行为对身体不好，却执意要做，为什么？因为快感。自残、自杀也是同样的道理。</p><p>享乐是一种痛苦中的快感。而死亡，就是最大的痛苦。</p><p>欲望为什么没办法实现呢？因为，当你满足当前的欲望，旋即，下一个欲望就会跳出来。欲望所指向的永远是“那个东西”，那个无法得到的东西，是什么？欲望！欲望，无非是欲望欲望的欲望。</p><hr><p>我已经太久没有睡觉了，一旦躺下，头就会像撕裂般疼痛，哪怕极端的困意也没法让我短暂忘记这种痛楚。</p><p>……药物，我想，如果没有药物，我还能活多久呢？</p><p>吃了药，勉强躺下。痛苦逐渐消散，半永久的黑夜来临了。</p><hr><p>压抑的欲望，究竟是压抑了什么？压抑了能指。压抑的能指会进入无意识的深处，然后浮上水面。</p><p>能指，大部分指语言。比如一个杀人犯，杀小孩未遂，那么有可能，“幼子”这个能指会被推进无意识的深处，然后进行相似变换——有可能变成柚子？那么，这个人有可能对于柚子有特殊的快感。</p><p>精神分析就是为了发觉这种，症状背后所代表的东西，是操纵无意识的艺术。</p><p>梦就是能指的浮现，任何对于梦的分析，都要按照隐喻的方式处理。</p><hr><p>我做梦了。</p><p>我梦见梦中的自己，用一把刀，一块一块地割下自己的肌肤。每割下一块，就有无数的苍蝇飞到我身上，进入我的鼻子、嘴巴、耳朵里。</p><p>我没有办法停止这一切，我似乎被困在身体里了。我只能机械性的一下一下切割着自己的皮肤。</p><p>我的血滴落在地上，滴落的地方有婴儿的脸。婴儿的脸旋即消失，四面响起巨大的啼哭声。</p><p>我的内心在哀嚎，可我的手，却没有停下。</p><hr><p>在会诊中，要尽可能让患者表现出自己的无意识，诊疗者要避免干扰患者的表述。诊疗者的作用是，强调患者表述中那习以为常的事物。</p><p>让患者意识到，症结的背后是什么，症结的目的是什么。</p><hr><p>我醒了，天还是黑色的。</p><p>我的家里没有表。</p><p>打开手机，发现我睡了整整一天。</p><p>厕所的水龙头还在滴水，盆里的水早已满溢。哗啦啦。</p><p>“这下麻烦了”，我自言自语道。</p><p>厕所里的虫子始终杀不干净。</p><hr><p>男孩俄狄浦斯情结的三个阶段：</p><ol><li>认为母亲是一切。母亲掌握着孩子的生杀予夺的大权，然而却不能时时刻刻都陪在孩子身边。孩子的原初享乐。</li><li>孩子想要成为母亲欲望的对象，想让母亲时刻待在自己身边。孩子要成为菲勒斯。</li><li>父之名干预孩子，让孩子意识到，母亲欲望父亲，自己成为母亲的欲望对象是不可能的，于是，孩子选择通过成为父亲来迂回到这个目标上。</li></ol><p>有了父之名，人才能健康的成长，父之名是非常重要的一个东西，也是诊疗的重点。</p><hr><p>我索然无味，开始打扫起家里的卫生来。</p><p>我在卧室的柜子上找到了一本相册，我从来没见过这本相册。绿色封皮。</p><p>我翻开了看，里面是我和一个女人的照片，我从来没见过这个人。</p><p>我和她似乎举止亲密，如同男女朋友一般。</p><p>深夜里，这些照片带给我一阵恶寒。</p><p>我翻到最后一页，里面的东西让我战栗。</p><p>那是一张血腥的照片，那个女人摆着诡异的笑容，满脸是血，眼睛就这样死死盯着——盯着我。</p><hr><p>如果没有俄狄浦斯情结的第三阶段，人会患有一些神经症。这是弗洛伊德的看法。</p><hr><p>我猛地把相册合上。有人敲门。</p><p>我没敢出声，静静地拿起角落的刀，缓缓向门走去。</p><p>敲门声越来越重。我走到门前，大喊了一句：</p><p>“谁？”</p><p>无人回应，只有越来越重的敲门声。</p><hr><p>无意识的东西往往很重要。</p><p>此外，我们要时刻记得，症状本身是有目的的，是要遮盖一些欲望的。</p><hr><p>我打开门，什么都没有。</p><p>黑洞洞的走廊，毫无亮光。</p><p>我拿着刀对空气挥舞了几下，关上了门。</p><p>此刻，我听见屋子里有女人的嚎叫，有苍蝇飞舞的声音。</p><p>我重重地倒在地上。</p><hr><p>我写了一个非常老土的故事，或许您能理解到底发生了什么。</p><p>无意识就是这样，有的时候，现实和感受是完全不同的。</p><p>压抑的欲望、俄狄浦斯，这在拉康那里是很重要的。</p><p>也就是说，在拉康那里，人一辈子都是痛苦的呢。</p><p>然而，德勒兹却给了个不太一样的解释。那是欲望的解放性力量。我们稍后再讲。</p><p>在我这里，德勒兹即是哲学的终结，一个完美的、精巧的形而上学模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
            <tag> 精神分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json、jsonl文件格式与处理、转化方法</title>
      <link href="/2024/07/18/json%E3%80%81jsonl%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%A4%84%E7%90%86%E3%80%81%E8%BD%AC%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2024/07/18/json%E3%80%81jsonl%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%A4%84%E7%90%86%E3%80%81%E8%BD%AC%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在机器学习领域中，<code>.json</code>和<code>.jsonl</code>格式的文件是非常常见的。大量数据集都以这两种格式处理。然而，在导出这种类型文件的时候，会遇到很多问题。这篇文章就来谈一谈这两种文件格式以及如何解决相关问题。</p><h1 id="1-文件格式"><a href="#1-文件格式" class="headerlink" title="1. 文件格式"></a>1. 文件格式</h1><h2 id="json格式"><a href="#json格式" class="headerlink" title=".json格式"></a><code>.json</code>格式</h2><p>JSON的全称是JavaScript Object Notation，是一种以键值对存储信息的文件格式。其基本数据类型有：</p><ol><li>数字。</li><li>字符串。</li><li>布尔值。</li><li>数组，由中括号括起。</li><li>对象：由大括号括起。</li><li>空值：null</li></ol><p>我们随便打开一个<code>.json</code>文件，观察一下其结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">     <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the text&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dark_red&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;bold&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;strikethough&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;clickEvent&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;open_url&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zh.wikipedia.org&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;hoverEvent&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show_text&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span></span><br><span class="line">               <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;something&quot;</span></span><br><span class="line">               <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;translate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item.dirt.name&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;bold&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;italic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>熟悉Python语言的朋友们都知道，这个格式就是：<strong>由一个或多个字典组织起来的列表</strong>。</p><p>值得一提的是，在<code>.json</code>文件中，字符串只能由双括号括起，不能由单括号括起来。此外，键也只能是字符串。</p><h2 id="jsonl格式"><a href="#jsonl格式" class="headerlink" title=".jsonl格式"></a><code>.jsonl</code>格式</h2><p><code>.jsonl</code>格式的文件可以看作<code>.json</code>文件的一个扩展，其例子如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个格式就是：<strong>多个字典，按照一行一个的排列方式排列起来的格式</strong>。同样，字符串只能由双括号括起，不能由单括号括起来。</p><h1 id="2-导出字典为-json格式"><a href="#2-导出字典为-json格式" class="headerlink" title="2. 导出字典为.json格式"></a>2. 导出字典为<code>.json</code>格式</h1><p>假设我们有这样一个字典列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;w&quot;</span>, <span class="number">1</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;t&quot;</span>, <span class="number">3</span>:<span class="number">4</span>&#125;]</span><br></pre></td></tr></table></figure><p>想要将其导出为<code>.json</code>格式，应该怎么做呢？</p><h2 id="1-字典转为字符串，直接导出"><a href="#1-字典转为字符串，直接导出" class="headerlink" title="1.字典转为字符串，直接导出"></a>1.字典转为字符串，直接导出</h2><p>乍一看，<code>a</code>符合<code>.json</code>文件的格式，那么，我们会很自然的想到，直接将<code>a</code>转成字符串，输出到文件中不就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;output.json&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">output_file.write(<span class="built_in">str</span>(a))</span><br></pre></td></tr></table></figure><p>然而，当我们尝试打开<code>output.json</code>时，会发现其并非一个合法的<code>.json</code>文件，此时该文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span>&#x27;name&#x27;<span class="punctuation">:</span> &#x27;w&#x27;<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span>&#x27;name&#x27;<span class="punctuation">:</span> &#x27;t&#x27;<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>该文件具有几个问题：</p><ol><li>键不全是字符串。</li><li>文件中的字符串没有用双引号括起来。</li></ol><p>那么该怎么办呢？</p><h2 id="2-修改字典转化成的字符串"><a href="#2-修改字典转化成的字符串" class="headerlink" title="2. 修改字典转化成的字符串"></a>2. 修改字典转化成的字符串</h2><p>可能，我们可以先将字典转化为字符串，然后将全部的单引号改为双引号，然后检查键的值。</p><p>这个方法很麻烦，此外，当键值对中出现转义的双引号时，处理会更加复杂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;w&quot;</span>, <span class="number">1</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;This is \&quot;Q\&quot;&quot;</span>, <span class="number">3</span>:<span class="number">4</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="3-利用json库导出"><a href="#3-利用json库导出" class="headerlink" title="3. 利用json库导出"></a>3. 利用<code>json</code>库导出</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">a = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;w&quot;</span>, <span class="number">1</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;t&quot;</span>, <span class="number">3</span>:<span class="number">4</span>&#125;]</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;output.json&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">json.dump(a, output_file)</span><br></pre></td></tr></table></figure><p>这种方法简洁有效。</p><h1 id="3-导出字典为-jsonl格式"><a href="#3-导出字典为-jsonl格式" class="headerlink" title="3. 导出字典为.jsonl格式"></a>3. 导出字典为<code>.jsonl</code>格式</h1><p>既然我们已经会导出为<code>.json</code>格式了，那么导出为<code>.jsonl</code>格式，无非只需要增加一个遍历输出的操作。因为<code>.jsonl</code>是<strong>多个字典，按照一行一个的排列方式排列起来的格式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">a = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;w&quot;</span>, <span class="number">1</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;t&quot;</span>, <span class="number">3</span>:<span class="number">4</span>&#125;]</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;output.jsonl&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> a:</span><br><span class="line">    json.dump(block, output_file)</span><br><span class="line">    output_file.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样就可以了。</p><h1 id="4-中文问题"><a href="#4-中文问题" class="headerlink" title="4. 中文问题"></a>4. 中文问题</h1><p>应用如上代码导出中文内容时，文件会变成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\u8fd9\u4e2a\u673a\u957f\u4eca\u5929\u7684\u98de\u884c\u4efb\u52a1\u662f\u5f00\u4e00\u67b6\u5927\u7684\u98de\u673a\u3002\n&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;tgt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The captain&#x27;s mission today is to fly a large aircraft.\n&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;hyp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This sentence is already in English.&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个时候，我们只需要向<code>json.dump()</code>中，增加一个<code>ensure_ascii=False</code>参数，结果就会变成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这个机长今天的飞行任务是开一架大的飞机。\n&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;tgt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The captain&#x27;s mission today is to fly a large aircraft.\n&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;hyp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This sentence is already in English.&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="5-导入文件"><a href="#5-导入文件" class="headerlink" title="5. 导入文件"></a>5. 导入文件</h1><p>我们要利用的妙妙工具是：<code>eval()</code>函数。这个函数可以将一个字符串当作代码处理。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;print(\&quot;s\&quot;)&quot;</span>) <span class="comment"># Output: &quot;s&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;[1]&quot;</span>) <span class="comment"># Return [1] as List</span></span><br></pre></td></tr></table></figure><p>第一个例子会在命令行中打印一个s，第二个例子则会返回一个列表，其元素只有一个1。</p><h2 id="json格式-1"><a href="#json格式-1" class="headerlink" title=".json格式"></a><code>.json</code>格式</h2><p>调用<code>json</code>库中的<code>load</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_file = <span class="built_in">open</span>(<span class="string">&quot;input.json&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">dicts = json.load(input_file)</span><br></pre></td></tr></table></figure><h2 id="jsonl格式-1"><a href="#jsonl格式-1" class="headerlink" title=".jsonl格式"></a><code>.jsonl</code>格式</h2><p>由于<code>.jsonl</code>是一行一个字典，那么我们只需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actual_blocks = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input.jsonl&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    blocks = f.readlines()</span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">    actual_blocks.append(<span class="built_in">eval</span>(block))</span><br></pre></td></tr></table></figure><p>先获得所有行，然后通过<code>eval()</code>函数，将所有字符串转换成<code>dict</code>即可。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>当我们有迭代<code>.jsonl</code>文件中全部dict的需要时，可以应用如下的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SR_jsonl_iterator</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="keyword">assert</span> file_name.endswith(<span class="string">&quot;.jsonl&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            one_line = f.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> one_line:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr_dict = <span class="built_in">eval</span>(one_line)</span><br><span class="line">                <span class="keyword">yield</span> curr_dict</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 小问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>独白</title>
      <link href="/2024/07/03/%E7%8B%AC%E7%99%BD/"/>
      <url>/2024/07/03/%E7%8B%AC%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fd46a0f451ada08d53ef046e36fa267b0d3dad309f4103d8c3a42035e7a0ca41">a3c5b05b8048fa7e066238497f1a0ac068c59b4e34db8224b8542832a6f6d2c285e5235f42029639a507122d8798b160da2b3850394733b3f2ec476d111c52232019f978dc4ebcbab030797c3788428ab8cd45c4ebcb91dfd73092c775f471e90aff3566e4d529bbaa429f7ccd2b625ae17d5ba70cf6b498afcf447ec40024ef39a0306c5ed0f7d544c98c4dfb32ca764903d44367f285b7400b7e955363ac41cc6e2e9eceeeff0e867831f2d9c0db43293b7f33d23b143e2519c1d5d801558e1623c02dc5ff93b7aea38d7c6b9cde2fc4f02ace85edbe67e0a68c7d1ed2fd45727cdb66af10152ae69b9b33060b33c6b5a4b9142b532431f9773b59a7caa185386484efbdb0c87e0bf4c268abef97082daf1ddcde1fd7e8a22a2cd1f97de08a3670652f8c23537a78e7c957029e119c47f0782b86d122c1ea2b802484eb9f27dc70e7ccf1c509ae9108055a781f34f59b588151541081c59cb8b25b6ba7b196d7c840779a9d948185127b105b90bb9fc44ebca5b9c73c2d4052d1867e6f17558d9e6b56cd6159b06bd08ed3160088c4a4cbab8411be5a8bddb0f7ada0c938eae673bd871af0e8c6f551e2c13045fc75f64a869aee5867f5e0c6b80b6f3dabc24a2f6488db77095452ef30b5e0dbfeb8992293e0d9cf1a75d9d4217d022b4882bf786699001960482cbd9c0592e1b5d27d0a9145bbb943897eccff169be5c917e5551c7f713d73d11a7bb5c9c7b3410b294c2899d30bab4fa36eb1c3f54c71e7870c629eeb1c596ee73ae0a8a2ba3fa0d134f03e31906fc91fc0c8afe88d0d7173524cb0028741c2d09eef2cc2373d8a6c6e1dec39fc79625803ef932d15d731b7d6a01eb36a2787225569733c10aa2ab3cefaeba229354a0daaa92d120dce8c4f215fa0feaa9400325eb41d3873f9aac76072b27efefa64a524dd191ff57daa90715034a9e28041ef5aef80730bd5a0bb0bc9a3f30132b7f414139df3dbf483e4b1c36fe440b6741cc582bcae27308db26af9bcb5702555889ea1043efd186e75b369cba375dc8a093274d2f1293e2a030dcffc3591148c93c6580b36c752a05a85b615a8fa58e87a8658830c5784bf0b39abdbb121595dcf1f44d07a872be5eea1dd278636ac407444093264e03d2a3d216987baa15be442503ee42b0d2786e9358fb020e1eabd088beeeb109cb608322302b63d05cabe948f259bd1460108d3db4ba415fa423dd774dccb0ec0dfd05196d9285bc5e2390248fcbaf7ce0bb7adb7f74c3209b9e2043f1db785261b9e2997d4db13eeb8149f20bb11c79fb8c9636f5a6bf93cdbc0712c27845c22a94fe3be46e5e074d9999a3e3468ee46411474e6f17bc5bcc38f5cdf61a748deb6c1f9eb5cf7e9a159c84e038ee549273f86dbfd57acb436179bb9f6ebe8a561669eec41c78df7d88603a52e3ae11639c4bd9ff1947f1668ba3a3a1f0e81b95beaf67e32f865ca0e100d1675946ebd7de35aa6481d61e41ad8c5d5ddbea74822214983ca46c41af2c462e4e01edbdc1b9e328fed07056a827a3769034c4a92756344d951b8f6ac93223d82fdfd3718b545d08e5f8c8c178f10f70119880dad60d0305d1e33dce3a5171c6b6a318d7479164c954c74b2075a59ac34bf51e76abb7181d4dcb0086cdfd8d20693c638e81d824c133577dc71e8de01da633a7613ef14946b91b6dddf7f892378fe61eb868974eb09f45b0174de115dfd392f10546edc0b4ecde4386b957b45c4de66f217a5acbe7621391daabde32a299a0bb52f76fc448717e42da9d1ed60c41ca936298fbc921a03e70f4140ef3fa6ca3244d1ee1f401225b0ad8263cf01d58e76e3c87b7abfac27e466ad90eee55f018eec985590ee1a335d8516a63f83c81be53d899fa914bed262fa5b2f9f978fad4419d0d59dc89c6e3291a242ea5b739d344bde2a9ccfa8ffc221f952d9f114931b76319cfeee063aadc975bf9c2a84808f5511242a517671370b4b3bc64e4218cab039fd705980a28aff3cb0c2169642ee5e4f044f1f6461fcaec4af4e5d8e1d81285c9db3a1ed9d2332760227d85e2260fda515c899e25e5cb6888eb8464029fbf574d3492f8f10a77ca3f7eb986c252204809dbbc1a4667d843b955c52876cb6256076326471fde0b8f5f532e31d4b7d01a9948e8872c1e9325a019cbd6c527897cda4cbbea3672ad6023330bd1c7f2b26f14eb4a8238a62e828bc7b7f50495c827fd8ecb5f2533b3a4bdea96dde45695ab8aa9ec4fca9059391c528084272d0b411ab27dad64ba50c0fc38e21a5db3e13de10e1d1cde214f58b023b49686bbaa1f6264e3379583646dc2bc5ac3abb40cb26dcd0f039b0d23b2f50348146885e0b91cc1ff834934413dac8a4c3e4aa495d3dda31445c19cfc84aeb48acb7da34b676fff36aef83a5f3b55a74f549e23792bcd82d9d42f06f32880f024aef4926e91b4ec7745ebe39ee37efa92944b4d2d6336d65bc1618eb4619e079a1b610d54cdb9a6dfc7e8656bed59fc279c0fb636ab59ed30252974560efe49a94a635eac7f67f301652e089646bea8fa319cedf610ef1fc70a285ae03d8ab10d2346cf0b1e675f34bbcaea05b247f36b47a34ba43905afb4e5a611334d9fe7eb4a68d72f7156a9fd9b34550725b8619938d761d55efd32fc4aeae39ec4072e19404991ebc9cecc274511d83d48d52428d1f9c613eb363615447b895518fb90753584bc93437219e0092708843f3dfd24db9cc29b2f2b1a3aa43d3ec4cbe9c2bb23f4afaf8accbef6bfa6c1ce5d00f4f010e22c686a434c4efa43023bb4e1888491fb5caa6f9d1b4faaec63a3ee9c78d06e867b5bcfab125e7a2639026c3ade782b5e5482e950a2347b29b94404318d31dd85cc7b5ed17d3bf34054d84b5c9f17bc2454eb59b4cf6c5f0dd08670b92ca8eec4f149865f2f6c8b48f40e2cfb04a7ec5cb7b608b6a4b87a8bc29897d35bdd3f6cb282797ebd064a853c8d425824bcb6b6718efc5891e721727cf692fcab92cd20e0005dd50b8677335605b141c608b98b301e1fc135b39f0b83811a28789255c87bb02982e3c2c886cba4fc6ab9be25064398708340cbf1a9f61eccae3c1fb0a4be1b46e368de2af41c07f6ce7912a3ec2bfa8cf7f7a2717b0cac6b0ca888eaf45f23b8a5795a2e8de04fb1c3d691bd45e67e766c4f547612507740f99c1f252973446db5f53ba0868df2f13d4f0c547697a2bb18aed07cd6816053b456d79f666301ddb84cc1dd615397b1bd8300b41fb86a147473a9b3de75bf99ac00a6d78b5143b8181b1af2a5537fa5a4148d597c018cf83e3285b3fcfcab8ced83de816be6e2f01789924d893c82104524aeaa8b9b9cd1694b90b3ff09b674e353a90e97c721909a2e6653119c25e8fcf40573e12990c2b1d0c6c49b9523f9db6384a5dfc556fcaec47997892514da1073ae395b3a51745f0cb9bcaf1992c4be1dfc7a7e8cfe747ecc364677af231c325f893c62d11c2928b34129c37941ced88db149a8fb7e93e4379816d3a24dc57f4e0fe68c8c30e5b096a4ee0f0f09744b305672ddd01d289f5b04a2e9a3d54bf70c5629ca1dc98fc463ba0ad7a685c71f1b0ac1481a05ff921fa65f451cbda85cd8147dec7ca767a78565647ca0665176eedb4d11a202bdf59b2af81bcb4738b255ef9b378d329f09b9a7a397c741d8ef853b3409c4273b1bf6b504a870a04352c51878b6b92c06382431505a24eafaf9683418c963b78a625479ec6c2dc0df19bc870794a075ca3c4ed392a80331dee944e08ffed373a1656997f3d52c9c93cc17201c43fe4ea6e70a5bf83a88e40c163a01844421a4dc8042db0f2b4748519bf4fc1697dd7ec5d2c019cfc54413ed6c2ca1f0ab1e6b95c5757df9929279f6226e2f2ee9f1cd08c1331ea85c989565551be71c780fd69134420598ac722802798f4cc9c81bf09b533e4243fd2e1ba09015b82ff452e5bd2ca5961434bcf7313dd1279cfce2a8545f6a94e02efbafa6bda32918b1ffddfb3909a130fbe06afddcc33701f02b21f6b94f1ba89e2e78f7d1dfa3a7c586ef44f03b5c6e074f05069181d42f8274dd7da882a1cba180f91baa7a7aec99145faff7bf18fe29379c2eeae010451d71e328e96928344efc180ef7671ed3626b278f5deee6c0710536b253ff86786041c635f21bfcc2de53403d05dfc2cc6577b99f389e38b8a5f6c655198130393a0fbb2bb01ea693e94ea1339f47819128d95ba6d69ce8de3103516a00da0924476f36a2077fafb9c32a1e0c7f9dc33bc295a6b2742dce71c4dc1470be8fd1f335f4a1879da081bca11544ad708fe79576e1fb2b02988d462275e7e0b03c08eea48784fe662959d5888916b5b69976ac176e328dae92c8f131f27fa8cb986b3aa832332b8f8073392d57f656a1a814e41c4cf1f32764d8a794d53764eaec1201070f8e1ad51766bf1b7d0de0afb3c7fefd2dd23972e9c9b13d7f1ea4e41919b4c4c857d4071856e3a7f88dca4742e61c9a6035c5e243500f8b9dcc501e073bb0535574b3967906111b2243226cac2bcd2b0813cb28f085f2432c38b3665d574c3f5bd15c53b479136081f0155d90901f1ce94dec389c08c98ba44bed156d1550de425253ca60d8a538ca27faae2f6aadb6f4b25e2c8d52e32d375f12237ef7662e0d2d90a6e5bc82ced92f8f3050b8afb2c73a58d24fe5864881ba18b161d11fc525820a718501322bab0716dc9b674df47eec32c796616266fbb61718ec485c0b1daddd27c2122186b133f6b6c43be1deed0271372661a764c006e20e6772dee4804c1b56fd72dae598f6f7a9ef21d18cf833df51e14c4dedae34bf60dbb40d65fded27a70c78decc12c0060d22c23fcfd87a2c507517f81200ebf448aac2f83f7b33afd99017701ba1a7cc1cc4a26e59d65f1309cd81b483a53d62da5c8a257907acdc8f72ca7172e560c669735c6cbc20c33e7b918c9a13d16a57547b9d60bcea94b98c371c8964f1efd712f76fc1681aa39e0badb8e61ddf8450bf2c5bbd8b70a1bcdca538034220b0301127cc593b396392fc7b1763710e3892fa385765485068a5395dea916085fc83cd8c9a95278324526c44ab841467a1aa47330cdc6168d4d2eb7887ff234fd751f54cfb140a88399ced40e6eab273c602654614a50dc9f2709ca92c53384e91ed4809a8eed9d3e302de4d8861f30d1d7ce5f0b76244a3d5c06f0a327636d2c612c3bbc7579cf92844063a83d7af0891892e7dbc1ad7c24ff3c558f502fdae197c0a8089cdb17bf81383699e7b7de0e1b05e266de4d9f5c8b90416b04b076e0fd7f934cfe472547b1868e5230ac4f8d57874d03fb69aae8aba74f0223e5562dd13ea12709c679cc7b037171032d9a1ae2cbac1eaa0a08be1009d5d1e9691a7b22970e40ee76da2d8926546afb04a93ec6dbe3fae8158f88724b69b730802a18f1f7e6a1435b65994e2ed0e7fd993440856a53f217065dbdbe6870c7bd15d494f61c183495556332dade2ed7656cb2ec953db5ac18786db9cd7826c162acea231e2cc80e6c7793549ce40796d11acc3a8b2f61b7d7ecf41efa185943f417d9c64338011f0fbd8843e98ac41f9f9ffcfb62b9f81141c7235f492e775c0285f18a40b7cc1dd370976b8a5c8139defea7a3d721e5ef78be67813f92dd5a5b3d2df9397346aeeb0e90229fdc1047d7386c9b88a3b102409e0b452419ded0a0b3a4858cd7cc3f8a14fef8162cb7742052176fa59bd779e782c64cc069b8fe0fb9fad227a847eb852178d6ede8add21d89d83725966c0f521acb8cff5800d4aa63ef5a1f4b93c684c4076ad1e68de2b3f50b198d2d71d4300389719a14c9e40c852867ad7c18a26193c746e062939721c61b3af3a64623260c8e6bfb8ad403114dc367f9e387e3ad1ec59e3ce13a29c0a4c6c1541592ae4608cd021053ae439c41ebcb9ae5b5847cffcabd23f8693ea222b9cfce1edd1df22dcfa05f3a970366b5380da742c91926f5253098f121e33fbabf0a527a0e9d66a12862de1f02466f6cab340defa88c39ae30fad890db7eaa253c99d20bb02a146eeb87d76772ba5bef9fda778629c6d8370ffbb096483ce579c33f33e9822d2a52cc85d3b424bc496ecae0c211af2210d9d2df89d68f086de7a748f161ce392b63d6c08e28d5b0ea84b2505d5e7117e72d12ba3087815e46f56165b96e8caeaab7c6a59f09309dc9cbc8366f98cc299b7dfbc53542237a886325bd7af0ceef1bea6960630b5520e680b1b122c5c7862fecf7220d97d6fcb0906f013614754b1f76965679ccb77355afe468283e67ee34a15e01deebe21ebe8e68070ab26b67871d5cb52fdd35375cd19b1573c526e55530af366d67e3da7db228b8e9d9360a5219bec239f42bbc1d80d69a653270cdd9c0397112814219c020d8d79f7eb204870df3b9ea9a060047bbc1287ac1c3e78a01d0310f6b13601bef41492180e3f907a7d710c861795e89accda0fef8352ef50752a4cd73401146ec4c772d8cac8e7fa56fa76f3c4d7ac5927cd7827f8b16081c111dbfbf5f5c7260d11aecbcae1c1426ab6a0bf4ae9ac0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>病与痛</title>
      <link href="/2024/06/05/%E7%97%85%E4%B8%8E%E7%97%9B/"/>
      <url>/2024/06/05/%E7%97%85%E4%B8%8E%E7%97%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="感冒——难受！"><a href="#感冒——难受！" class="headerlink" title="感冒——难受！"></a>感冒——难受！</h2><p>昨天我开始发烧、鼻塞、咳嗽、打喷嚏，很显然是感冒了。我约莫十二点上床睡觉，起初被鼻塞折磨得睡不着觉，大概一点才昏昏睡去，然而，不到三点，我又因为肌肉疼痛而醒来，我的身体在控诉我的大脑。就这样，一直折腾到九点，中间断断续续地——醒来、翻身、睡去、醒来、翻身、睡去。</p><p>早上起床看手机，发现昨天晚上才睡了5小时左右。醒来之后，头昏昏沉沉，下肢肌肉剧痛无比。不知道今夜会如何。明天早上八点还要上课，希望神会眷顾我吧。</p><p>好在食欲没有减退，中午吃了点粥，晚上喝了羊肉汤。感觉身体在逐渐变好。</p><p>肉体就是这样弱小而麻烦的东西，我无比憎恨这具将我束缚起来的躯体，但是，我还要和它共处很久很久。宇宙的一瞬。</p><h2 id="保研——人生真有很多选择吗？"><a href="#保研——人生真有很多选择吗？" class="headerlink" title="保研——人生真有很多选择吗？"></a>保研——人生真有很多选择吗？</h2><p>我是个弱小的人。</p><p>我们学院的学生自打本科就有保研的资格，只要本科期间不挂科即可——挂科也只能挂一门，且补考必须通过。这是很好的事情——对我来说。</p><p>然而，很多课程我根本学不明白，也没有兴趣去学。很多课程都是刚刚擦过60分及格。</p><p>最近考了一门编译原理——这门课很没意思，我也没去听过几节，实验做得一塌糊涂，考试题又好难。这门课的分数组成是这样的——实验+MOOC+笔试，然而，我实验的报告分数很低。我并不确定这门课我会不会及格。</p><p>如果不及格——如果不及格——我那些保守的家人会给我施压，他们会在一瞬之间将爱变为厌恶。这样的事情我经历太多了。而我的精神已不足以支持我再去自我疗愈了。我的精神力，那种人人都有的、天生自我疗愈的强力，也要消磨殆尽了。最近生出的对生活的爱，我也找不到了。我好像又回到了过去。</p><p>好几次考试之后，我都会去想——“不及格就去自杀吧，反正也没人喜欢你”，似乎自打小学开始就是这样了。我曾在日记里写过——我的人格就是建立在“孤独和痛苦之上”的。</p><p>没有保研的资格，要工作嘛？要考研吗？工作的话，要去哪里？要干什么？考研的话，我有动力吗？我能坚持下来吗？我厌恶这样的自己，厌恶这样思考着的自己，厌恶这样扭曲而恶心的性格，厌恶这样偏安一隅的自己。</p><p>工作也好，考研也好，在我看来都是很痛苦的事情。其实一直以来，我都没有想过，未来的自己要做什么。我一直被人推着走。我懒得思考，一直被人推着走。“要我去这里，我就去这里吧！”我从来没有仔细思考过自己的未来。我什么都不想做。</p><p>真的吗？我想做的那些事情，都是现在没办法做的事情呢。我没有勇气，更没有钱。由于家庭原因，我没有什么犯错的余地，也没有什么尝试的余地。</p><p>其实，我一直知道——我是个废物，一事无成的人，干什么都干不好的人——我只是不愿意去相信。我始终欺骗着自己：我是个很厉害很厉害的人。哎呀！一无所成的人最喜欢欺骗自己了呢！</p><p>久而久之，我也不知道自己该做什么好了。习得性无助！</p><p>这样，人生并没有很多选择——尤其是你在被人推着走的时候——如果你做错了某个决定，就去死吧，你不符合那些推着你走的人的期待，那你就没有价值了，去死吧！活出自己的人生——是多么困难的一件事啊。</p><p>我觉得我自己的生命，就像是系在一根细小蛛丝上的蜘蛛，被风一吹，就要跌在地上，粉身碎骨了。</p><p>这阵风是一定要吹来的，究竟什么时候呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如此之人</title>
      <link href="/2024/05/16/%E5%A6%82%E6%AD%A4%E4%B9%8B%E4%BA%BA/"/>
      <url>/2024/05/16/%E5%A6%82%E6%AD%A4%E4%B9%8B%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>做过千百次的梦，</p><p>隐隐的寒意，深夜的冷。</p><p>向前，向后。</p><p>都是死路。熄灭的灯。</p><p>我是墙上生锈的钉子——</p><p>刮过无人之处的风。</p><p>往左，往右。</p><p>都无出口。将断的绳。</p><p>梦是无法实现的理想，</p><p>是将死者的提前死亡。</p><p>夏天要过去了，</p><p>秋天的万物，势必消亡。</p><p>我是被世界遗弃的孩子啊，</p><p>是要被冻死的流萤。</p><p>我是错误的开始，</p><p>却不是错误的终止。</p><p>做过千百次的梦，</p><p>隐隐的寒意，深夜的冷。</p><p>向前，向后。</p><p>都是死路。熄灭的灯。</p><p>往左，往右。</p><p>都无出口。将断的绳。</p><p>向前，向后。</p><p>都是死路。熄灭的灯。</p><p>往左，往右。</p><p>都无出口。将断的绳。</p><p>向前，向后。</p><p>都是死路。熄灭的灯。</p><p>往左，往右。</p><p>都无出口。将断的绳。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛夏将至</title>
      <link href="/2024/05/04/%E7%9B%9B%E5%A4%8F%E5%B0%86%E8%87%B3/"/>
      <url>/2024/05/04/%E7%9B%9B%E5%A4%8F%E5%B0%86%E8%87%B3/</url>
      
        <content type="html"><![CDATA[<p>夏天要来了。</p><h2 id="忧愁"><a href="#忧愁" class="headerlink" title="忧愁"></a>忧愁</h2><p>最近，我的朋友小L不是很开心。小L是一名医学生，在学校的成绩还不错，对未来也算有一个比较清楚的计划——至少他知道最近的目标是什么，未来要做什么样的工作，过怎么样的生活。</p><p>然而，他在经历了一段比较失败的恋情后，却突然像变了一个人一样。他时常胡思乱想，一味去讨好别人。他没办法接纳这样的自己。他欲求通过给女朋友花钱，来证明自己的重要性。有的时候，他甚至连课都不去上，只是去思考如何让他人快乐起来。</p><p>他是个完美主义者，想把一切事情都做到完美——感情、学业、兴趣爱好……他始终没办法接纳自己，他期望太高——落差太大。</p><p>我尽力去开导他，虽然我知道，他只是想和我倾诉一下，并不需要我的建议。至于我说的话，他一定是听不进去的。道理永远是道理，真正要领悟，还需要自己去历练。</p><p>他最近也在和我分享他对于生活的看法，一切都好。他正尝试接纳自己。</p><p>人没办法解决一切问题。</p><h2 id="爱与力量"><a href="#爱与力量" class="headerlink" title="爱与力量"></a>爱与力量</h2><p>我仔细回忆着我的过去，小L的过去，其他朋友的过去。</p><p>我们所接受的负面反馈要远多于正面的反馈——批评和责骂总是要多于表扬与夸奖的。这是一种基于拆毁的规训。</p><p>孩子，好比是一棵树。基于拆毁的规训，就像是预先设定好了一些模具，将那些不符合模具的枝桠剪掉、过粗的树干削细。基于建构的规训，就像是一个艺术家，根据树的自然生长状态，进行引导，修修补补，让这棵树成为一件独特的艺术品。</p><p>前者是简单快捷的，成本也不高——后者则需要艺术家倾尽大量的心血。其实，这二者并没有哪个好哪个坏一说，这两个方法通常是结合起来使用的。</p><p>您能懂这个意思就好……在一些欠发达的地区——比如我的故乡——教育往往是一味地拆毁。</p><p>直到现在，我也常常做关于初中、高中的噩梦——哪怕我知道，过去的那些问题，很多根本不是我的问题，而是误会、他人的恶意和先入为主的思想交织起来的产物。</p><p>直到现在，我也不敢做某些事情——我害怕被责骂。虽然没人会责骂我，但是那种恐惧依然植根在我心底。</p><p>……</p><p>我又有什么办法呢——唯有祈祷。</p><p>我尝试去爱别人，带给别人一点善意，希望带给他们力量。</p><p>如何去爱？如何带给别人力量？这是难题。</p><h2 id="自学的陷阱"><a href="#自学的陷阱" class="headerlink" title="自学的陷阱"></a>自学的陷阱</h2><p>我很喜欢自学，但是总结所有自学的经历，貌似都学得不怎么样。貌似自学最成功的还是Linux，至于哲学、音乐、画画，都是一塌糊涂。</p><p>自学是必定会走弯路的，究其原因……我想是缺乏实践、缺乏练习。</p><p>当学习一些抽象的事物时，比如哲学，不去用这些框架分析世界，是没办法学会的。理论进了脑子，不去运用，最终也只是死板的知识点而已，与其说是学习，不如说是背诵。</p><p>当学习一些具体的事物时，比如音乐、编程，这些教程往往从简单的东西入手，逐步变得复杂。而很多人——包括我，常常忽略了对于简单知识点的训练，不去思考何时应用这些知识点。随着问题变得复杂，就想不起来要去应用一些简单的理论了。</p><p>另外，自学的另一大问题是，很容易陷入“应用错误的方法进行大量训练”的漩涡中。比如学习吉他，明明左手手型就不正确，只是一味地去死命练习，这导致我现在弹琴没法上速度，甚至弹奏慢速的歌曲，也会弹出大量的杂音。</p><p>老师的任务，不仅仅是教授知识，更是指出问题，纠正误区。</p><p>……</p><p>然而自学就一无是处吗？不是的。</p><p>自学的好处就是——没有死板的框架。自学势必要阅读参考大量的资料，而不同资料的侧重点自然也会有一些不同。在这个参考的过程中，我们也能了解到对于不同知识点的不同理解方式。科班式的培训，往往会忽略对于大量资料的参考，只参考一本教材——是的，是的，教材里面也会有推荐的其他书目，但是真的会有人看吗？</p><p>此外，出于兴趣的自学，往往会迫使一个人往深处了解一个知识点的底层原理，了解相关的其他知识点。</p><h2 id="Bangumi"><a href="#Bangumi" class="headerlink" title="Bangumi"></a>Bangumi</h2><p>Girls Band Cry真好看，歌也好听。</p><p>四月新番是真的顶。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光与盐</title>
      <link href="/2024/04/27/%E5%85%89%E4%B8%8E%E7%9B%90/"/>
      <url>/2024/04/27/%E5%85%89%E4%B8%8E%E7%9B%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一点牢骚"><a href="#一点牢骚" class="headerlink" title="一点牢骚"></a>一点牢骚</h2><p>我也不知道我想要什么。</p><p>我现在能感觉到，自已越来越内向，越来越孤独了。而我又没有能力改变这一切。</p><p>我突然意识到，我的很多梦想都没办法实现，我也会搞砸很多事情。</p><p>……</p><p>我拆毁了过去的自己，我实在是与过去的自己和解了。</p><p>我爱我现在的一切——痛苦、快乐、悲哀……我喜欢我经历的一切。</p><p>我欣然接受这一切，我知道自己是个没办法凡事都做到完美的人，我接纳这样的自己。废物就废物吧，又怎么样呢？</p><p>我真的内向，真的孤独吗？实则不然，我只是缺少对于周围人的爱。我向来不懂得回馈别人给我的爱，不懂得给予爱。</p><p>爱人如己——这条诫命难上加难！</p><p>爱可以解决大部分问题。</p><h2 id="乐队"><a href="#乐队" class="headerlink" title="乐队"></a>乐队</h2><p>我初中的时候看了《轻音少女》——具体的时间点我都忘记了，我的记性很差——然后就想组乐队。我当时买了把木吉他。</p><p>我看着网上的教程自学，学来学去也就会点弹唱和一些简单的指弹。随着时间的不断流逝，我也逐渐忘却了组乐队这件事。</p><p>直到上大学——最近。我突然觉得弹琴是如此的有意思，音乐是如此的美妙。我喜欢那种亲手创造出音符的感觉。我也在努力学编曲，我希望用音乐带给别人一些力量。</p><p>那种老套的乐队番剧，不都是通过音乐给别人力量的过程吗？Bang Dream…等等。</p><p>不过我觉得近来倒是组不了乐队了。我的技术太菜了。练几年再说吧。</p><h2 id="生命万岁"><a href="#生命万岁" class="headerlink" title="生命万岁"></a>生命万岁</h2><p>人类的生命没办法持续一万年，我知道的。</p><p>我正尝试去接纳自己，接纳我所遇到的一切，并且感激我所拥有的一切。</p><p>快乐与幸福是向内求的，而非向外。</p><p>总之，愿你平安。</p><h2 id="高投入与慢回报"><a href="#高投入与慢回报" class="headerlink" title="高投入与慢回报"></a>高投入与慢回报</h2><p>练习吉他是一个高投入而慢回报的过程，平时需要努力啃下来复杂的乐句，不断练习，持续一段时间后才会看到一点点回报，不过，若是能长久坚持下去，最终就能流畅弹下来很多复杂的曲子。这个时间通常是按照年来定义的。</p><p>最近，我感觉我失掉了许多耐心，总想着低投入而快回报的事情。</p><p>不过，好在，我最初的梦想还在支撑着我练习下去。</p><h2 id="思考与哲学"><a href="#思考与哲学" class="headerlink" title="思考与哲学"></a>思考与哲学</h2><p>最近和朋友一直在讨论哲学和经济的话题。</p><p>我们一致认为，哲学没法解决人的问题。任意一种哲学框架都简化了世界，忽略了某些方面的复杂度。人本身就是很复杂的，没办法用一种框架进行彻底而正确的分析。将任意一种哲学框架视作真理的人，都会变得偏激而病态。</p><p>而且，当读过一些哲学后，那些理论就如同蛀虫，蛀烂了大脑那些纯净的部分，那些理论带来的影响将没法被移除。那种闪回式的、病态的、容易引发抑郁和崩溃的影响。</p><p>那么，哲学能解决社会的问题吗？也不然，不同的哲学理论像是不同的、逻辑自洽的理论。一种循环论证，或者通过未经证明的前提进行推导。同样的，这些理论随着社会的发展，逐渐过时。合理的理论应当是<strong>滚动更新</strong>的。不过，这些理论也一定会忽略社会的某些方面。</p><p>哲学没有答案，只有问题。</p><p>于是，我问他，那么什么能解决人的问题呢？他的答案是生活，拒斥那些抽象度极高的理论，关注具体的生活。我的答案则多一条——超越性的存在。</p><p>如果人要追求最终的道理，我觉得不论如何，最终都会为自己的生活引入一个“神”的存在，这个“神”不一定是宗教性的神，也有可能是其他类型的、概念性的神。这个神是世界或生活的根节点——耶和华、安拉或者宿命、使命和欲望。</p><p>如果人不想追求最终的道理，那么他终将会关注于自己的生活，在生活里达成生活。这是一种回溯性建构的过程，通过生活，建构生活。</p><p>哲学还有一个问题，就是忽略了具体的人，总是去关注那些抽象的人。我觉得坐在家里思考哲学，远不如参加志愿活动来的实在。前者没办法更进一步认知人的本性，后者则不然。此外，哲学认为人能解决一切问题，这是一种自大。</p><p>人的自由意志、自由精神就这样被束缚在框架之内。这种压抑，是人类欲求知识，所缴纳的Jizya。</p><p>总之，我的建议是：忽略那些框架，尝试去好好生活吧。真理在生活中，不在书本里。</p><h2 id="约束与自由：Dies-Irae"><a href="#约束与自由：Dies-Irae" class="headerlink" title="约束与自由：Dies Irae"></a>约束与自由：Dies Irae</h2><p>拆毁，总要建起——若不建起，地上就会遍满流寇。</p><p>最近，在和朋友的探讨中，我突然觉得一味追求自由也是不好的。当然，我所指的，并不是欲求回归奴隶制或者封建体系。</p><p>那些来自哲学和社会学的武器，拼命解构着一切传统，这是好事也是坏事。这的确让人们的思想变得自由，间接使科学创新成为可能。然而，这种解构所导致的纵欲和解构成瘾也不失为一种问题。</p><p>自由意味着没有约束，然而，没有约束则意味着礼崩乐坏。人们在这种自由中迷失了，他们不知道什么是对的，什么是错的，他们认为万事皆可为。</p><p>解构而无建构，拆毁而不考虑建起。这就是后现代的特征。这是一种嬉皮士运动。</p><p>人们果真获得自由了吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light And Salt</title>
      <link href="/2024/04/26/Light-And-Salt/"/>
      <url>/2024/04/26/Light-And-Salt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你们是世上的盐。如果盐失去咸味，怎能使它再变咸呢？它将毫无用处，只有被丢在外面任人践踏。 你们是世上的光，如同建在山上的城一样无法隐藏。——《马太福音》</p></blockquote><h2 id="最近在干什么？"><a href="#最近在干什么？" class="headerlink" title="最近在干什么？"></a>最近在干什么？</h2><p>我好久没更新了，最近的闲暇时间，大多用来练电吉他、学习乐理了。之前自学木吉他，光顾着练习曲目，忽略了基本功的练习，导致复杂的乐句弹不明白。练电吉他就一步一步练习了，苦练左右手的机能。之前也没怎么学乐理，只会照着谱子死命弹，这样不行，没有提升。</p><p>最近也尝试过学习画画，买了个数位板，安装了Krita和GIMP，结果发现，自己果然没有天赋，抓型抓不准，线条也画不明白，索性放弃。</p><p>还是音乐比较容易一点。音乐是如此美妙的东西！</p><p>早些时候也把《圣经》看了一遍，学习了基本的神学原理，感觉蛮有意思，不过由于练琴，最近搁置了。自己也没勇气去教会，去了也不知道该做些什么，索性自己研究文本了。自己也在尝试去“爱人如己”，这是最难做到的事情了。</p><h2 id="内心的亏空"><a href="#内心的亏空" class="headerlink" title="内心的亏空"></a>内心的亏空</h2><p>我最近时常在想，为什么之前的我会想要自杀。</p><p>回看过去，我发现自己总爱钻牛角尖，思维总是过于敏感，时常将一些事情错误归因到自己的身上——自耗。</p><p>我天生是个内向而抑郁的人，所经历的事情、阅读的那些哲学书籍更进一步加深了我的痛苦。于是我使用酒精。然而这些东西只会让你逃避，没办法解决问题。</p><p>解构哲学、酒精、自慰，这些东西没法解决问题，唯一能够解决问题的是一个支点。没有支点的人是抑郁的，因为他的内部是亏空的，他像无根之草，又如同浮萍漂浮在水上。</p><p>那些后现代的哲学家和那些社会机器，将一切支点都拆碎了，于是人们只有亏空——这种亏空通常被各种奇奇怪怪的东西掩盖着。然而，当人完全沉静下来，他会感受到这种亏空带来的抑郁。</p><p>反正，至少，我觉得我过去的病症，就是由亏空导致的。</p><p>人没办法解决一切问题，人连自身的问题都解决不了。</p><p>支点是什么？倒也不必完全是宗教，也可以是一种信条，一种与自身经历相符合的信念。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我又用回Windows了</title>
      <link href="/2024/04/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%88%E7%94%A8%E5%9B%9EWindows%E4%BA%86/"/>
      <url>/2024/04/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%88%E7%94%A8%E5%9B%9EWindows%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>路漫漫其修远兮！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我最近买了把电吉他，Epiphone的黑卡——波奇酱的电吉他的官方廉价替代品，四千大洋出头拿下。</p><blockquote><p>I am too depressed, friend. I need something more severe, like… ROCK MUSIC!</p></blockquote><p>我还买了一些效果器、耳机、声卡之类的东西。</p><p>练了两天，想尝试一下使用DAW录音，顺便学一学混音的相关知识。</p><p>我原以为在Linux下录音并不是很难的事情——有很多艺术家都在用Linux，只不过他们不那么出名而已。然而，正是这看似简单的事情，让我对日用Linux完全失望。</p><h2 id="Jack、ALSA、PulseAudio和Pipewire"><a href="#Jack、ALSA、PulseAudio和Pipewire" class="headerlink" title="Jack、ALSA、PulseAudio和Pipewire"></a>Jack、ALSA、PulseAudio和Pipewire</h2><p>我觉得我事先必须要厘清一些概念：</p><p>Jack，被GNU式定义为Jack Audio Connection Kit，是一个声音服务器的daemon，可以给相关应用程序提供实时、低延迟的连接。</p><p>ALSA又叫做Advanced Linux Sound Architecture，是Linux内核自带的一个音频驱动程序。</p><p>PulseAudio是一种通用的声音服务器，通过使用ALSA，作为应用和硬件之间的中间件运行。</p><blockquote><p>PipeWire 是一个新的底层多媒体框架。 它旨在以最低的延迟为音频和视频提供录制和播放功能，并支持基于 PulseAudio、JACK、ALSA 和 GStreamer 的应用程序。</p></blockquote><p>Pipewire相当于Jack、ALSA和Pulseaudio上面的一个封装层，用户不用去调试底层的PulseAudio之类的系统，直接用就好。理论上是这样的。</p><p>我的Arch Linux使用的就是Pipewire。</p><h2 id="Reaper-Literally-reaper"><a href="#Reaper-Literally-reaper" class="headerlink" title="Reaper? Literally reaper!"></a>Reaper? Literally reaper!</h2><p>我所使用的DAW(Digital Audio Workstation，数字工作站)是Reaper，所谓数字工作站，就是一类软件，用户可以在上面对输入的音频信号进行处理，比如切分、加效果、将不同的音轨叠放起来。</p><p>Reaper在一定程度上为Linux设计，也支持很多效果。</p><p>我的声卡是Focusrite的Scarlett Solo，在Linux上是免驱动的，通过USB插口怼到主板上，直接就可以进行输入输出。播放浏览器的声音，完全没问题。</p><p>然而，当我想用Reaper录音的时候，我发现Reaper的选项里不包括Pipewire和设备选项，只包括JACK、ALSA和PulseAudio。如果选择JACK和ALSA，Reaper会默认读取我的板载声卡输入，如果选择PulseAudio，Reaper能读取我的电吉他输入，但是又没法从我的外置声卡输出。</p><p>我翻遍了全网，找遍了各个热门的或者冷门的论坛，然而一个有用的解决方案都没有。</p><h2 id="一寸光阴一寸金"><a href="#一寸光阴一寸金" class="headerlink" title="一寸光阴一寸金"></a>一寸光阴一寸金</h2><p>一瞬间，我觉得我在Linux上折腾太久了，我太挫败了。我浪费了太多时间在寻找替代品、查找解决方案、阅读Wiki、折腾Wine、折腾Proton、写各种各样的配置文件上了。我不愿意再折腾了。</p><p>于是我换回了Windows，真香。Windows的Reaper直接有声卡的设备选项，直接将输入输出调为声卡即可。</p><p>我又可以拥有桌面歌词；拥有无需配置的开箱即玩的Steam的体验了。</p><p>约莫两年，我踩了无数的坑，经历了无数的挫败，终于还是放弃日常使用Linux了。</p><h2 id="双刃剑"><a href="#双刃剑" class="headerlink" title="双刃剑"></a>双刃剑</h2><p>不过，通过这个过程，我也学会了很多东西，比如部署各种Linux的服务、尝试写一些使用Linux API的软件、简单Hack一下内核……</p><p>Whatever.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pater Noster</title>
      <link href="/2024/03/20/Pater-Noster/"/>
      <url>/2024/03/20/Pater-Noster/</url>
      
        <content type="html"><![CDATA[<p>将近两个月没有更新了。我一直不知道写些什么比较好。我觉得我的生活没有什么可以讲述给别人听的，所经历的事都再平常不过了。</p><h2 id="Jesus-Christ"><a href="#Jesus-Christ" class="headerlink" title="Jesus Christ"></a>Jesus Christ</h2><p>我上初中和高中的时候蛮抑郁的，从那时起，我开始读哲学的书和一些神秘学的书。然而这些书并没有解决我的问题，反倒让我更加迷茫。哲学书本里那些似懂非懂的专有名词，让我产生了各种各样的错误认知。</p><p>我一直感觉，我的问题是缺少一个支撑我的东西，像是一个信条，一个信仰。这让我联系到了宗教。</p><p>我之前时常听人讲，宗教是多么多么不好的一个东西，讲它是一种思想上的锁链；我也听说过中国的一些宗教人士是多么多么极端。然而，我又知道，哲学里，有一个分支，叫做经院哲学，是一种将基督教和哲学结合起来的学问。那么，这说明宗教一定是有一些可取之处的。我就来看看，宗教的信条到底是什么样的，是否真有那样不堪呢？</p><p>于是，这一阵我大致读了一遍《圣经》。与我之前的印象相悖，新约中所要求的信条，最重要的一点是——“爱人如己”。</p><p>我缺少的东西，或许就是这样的“爱”——一种正面的感情。我所接受的教育，幼时所经历的事情，都在告诉我要做一个“自私”、“高防备性”的人。我是在负面情绪上被建立起来的。打小又有谁教过我如何去爱，如何去用正面的情感接受他人呢？所谓的教导，无非都是——“要提防陌生人”、“除了爸爸妈妈谁都不要相信”——之类的话。似乎一直以来，我都没有去爱过别人——甚至没有爱过自己。</p><p>于是我尝试去爱人，尝试去根据《圣经》中那些信条去做，去回想、悔过过去所做过的事情，去“Deny Yourself, Take Up Your Cross, And Follow Me.”。我感受到了从未有过的平静和快乐。原来帮助别人、爱别人是如此美好的一件事。教别人一些东西、帮助他们解决一些问题、为他们出谋划策、宽容那些恨我者，这都让我无比幸福。</p><p>现在，我们需要的难道不正是爱吗？现在的哲学和流行理念，都认为人是无所不能的，过于强调人的重要性——这导致人们陷入了一种自满中去。这种自满让个体去肆意攻击他人。</p><p>我实在不愿去教会听那些人布道——文字间的含义，努力读一读就可理解。然而，我所认识的宗教徒们，很少有真正完整读过经书的，他们只会曲解某几个句子的含义，给当下的自己一个做事(通常是行恶)的动机而已。或许大部分所谓“教徒”，都是如此吧——这也是为什么，我选择做一个“独修者”、一个另类的Protestant。</p><p>以前听过人传教——“不信耶稣就要下地狱”、“只要信就可以”——这些说辞统统是与真正的教义相背离的。真正的教义，只有爱。</p><h2 id="接个支线看看？"><a href="#接个支线看看？" class="headerlink" title="接个支线看看？"></a>接个支线看看？</h2><p>最近一直在忙实验室的事情，争取上半年发第一篇Paper。全凭师兄带飞。</p><p>这一阵基本上就是在一个个“交流idea-调研-读paper-做实验-作汇报”的循环中度过的。产生的idea很多，但是真正有效的却寥寥无几。这就像是在玩一个3A大作，接了一堆支线，完成之后才发现，大部分任务压根没有报酬。</p><p>支线也不好做，天天调代码，看效果，准确率死活上不去，太痛苦了。</p><h2 id="热爱生活"><a href="#热爱生活" class="headerlink" title="热爱生活"></a>热爱生活</h2><p>我觉得过去的自己实在乏善可陈。过去的自己像是一个负能量的集合体。在去年下半年，我一度想要自尽，我想要跳楼，想要服药，想要用刀子割开自己的咽喉。可我没有，我开始接着学习神秘学，企图通过一些神秘学的方法让我活下去——但它们也帮不了我什么，通灵之术、占卜原理，什么用也没有。直到我开始学习基督教的教义，学习如何去爱人。</p><p>现在，我尝试忘记过去的自己，拥抱全新的生活。我尝试怀着感激之心看待身边的人和事，看待自己。</p><p>这很难，真的很难。我的心底经常涌出莫名的攻击欲和恶意，想要挑他人的刺、揭他人的短——我知道，这是过去的我，留下来的遗产，过去的我的“死因”。我学着约束自己，尝试让自己变得阳光、正能量。这是一场消耗战。</p><p>我继续学习音乐，开始学习画画，我想要重新开始。</p><p>虽然死亡终究要将我带去——呃，在审判日那天，我会复活——但我想，我应当至少在活着的这一段时间里，做一些有意义的事情吧。</p><p>“签放在怀里，定事由耶和华。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【神秘学】恶魔学笔记</title>
      <link href="/2024/01/25/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E6%81%B6%E9%AD%94%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/25/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E6%81%B6%E9%AD%94%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>恶魔一词——demon，最开始的意义是“超自然的灵体”，无所谓是善良的灵体还是邪恶的灵体。随着时间推移，恶魔这一词逐渐偏向于指代邪恶的灵体。</p><p>古美索不达米亚的神话中曾记载着一种邪恶的灵体——Udug，其形态常常被描述为一种黑影，一种笼罩在黑暗中的影子，伴随着巨大的、震耳欲聋的噪声和毒气出现。它们常被认为会传播疾病。</p><h1 id="基督教的恶魔"><a href="#基督教的恶魔" class="headerlink" title="基督教的恶魔"></a>基督教的恶魔</h1><p>基督教中的恶魔常常被认为是堕落的天使。既然是天使，那么在基督教的观点里，就是神创造的事物。那么为何又会堕落呢？无非是因为违抗了神的旨意。所以恶魔是<strong>罪人</strong>而非<strong>恶人</strong>。《圣经》往往关注于那些邪恶的恶魔，这也影响了后世对于恶魔的看法。此外，古早时期的基督教常常认定那些异教徒的神为恶魔——因为它们尝试引诱人们远离那个唯一的真神。</p><p>对于恶魔存在的意义——钦定版圣经中认为——是为了测试人类对于神的虔诚程度：</p><blockquote><p>有一天，神的众子来侍立在耶和华面前，撒旦也来在其中。</p><p>耶和华问撒旦说：“你从哪里来？”撒旦回答说：“我从地上走来走去，往返而来。”</p><p>耶和华问撒旦说：“你曾用心察看我的仆人约伯没有？地上再没有人像他完全、正直，敬畏神，远离恶事。”</p><p>撒旦回答耶和华说：“约伯敬畏神，岂是无故呢？</p><p>你岂不是四面圈上篱笆，围护他和他的家并他一切所有的吗？他手所做的都蒙你赐福，他的家产也在地上增多。</p><p>你且伸手毁他一切所有的，他必当面弃掉你。”</p><p>耶和华对撒旦说：“凡他所有的都在你手中，只是不可伸手加害于他。”于是撒旦从耶和华面前退去。</p><p>——《约伯记》1:6~12</p></blockquote><h1 id="恶魔的形体"><a href="#恶魔的形体" class="headerlink" title="恶魔的形体"></a>恶魔的形体</h1><p>恶魔可以寄生于动物、人类和一些雕像上面。这一思想直接导致了公元13~17世纪的西方对于巫术的崇拜。当他们寄生时，它们的形体就表现为寄生物的形体。然而，圣经中说恶魔常常是没有形体的，这也意味着它们可以变成各种各样的形态，可以幻化成天使的形态：</p><blockquote><p>那等人是假使徒，行事诡诈，装作基督使徒的模样。</p><p>这也不足为怪，因为连撒旦也装作光明的天使。</p><p>所以，他的差役若装作仁义的差役，也不算稀奇。他们的结局必然照着他们的行为。</p><p>——《哥林多后书》11:13~15</p></blockquote><p>也可以幻化成龙：</p><blockquote><p>大龙就是那古蛇，名叫魔鬼，又叫撒但，是迷惑普天下的。牠被摔在地上，牠的使者也一同被摔下去。——《启示录》12:9</p></blockquote><p>在但丁的神曲中，引诱亚当夏娃吃苹果的那条蛇，也被认为是撒旦的化身。</p><p>此外，男魅魔(Incubus)和魅魔(Succubus)的形体常常是有强烈性吸引力的人类；在女巫大审判时期，也记载着恶魔常以婴孩的形体出现——然而这些婴孩特别沉，且长不大，同一时期，也认为恶魔常常是冰冷的。我个人倒是不怎么相信女巫大审判时期的记载，因为这些记载往往有逼供的可能。</p><h1 id="恶魔的分类"><a href="#恶魔的分类" class="headerlink" title="恶魔的分类"></a>恶魔的分类</h1><p>貌似没有特别准确的分类。这里列举根据七宗罪进行分类的方法——Lantern of Light：</p><ol><li>路西法: 傲慢</li><li>玛门: 贪婪</li><li>阿斯摩太: 色欲</li><li>利维坦: 嫉妒</li><li>巴力西卜: 暴食</li><li>撒但: 愤怒</li><li>贝尔菲格: 懒惰</li></ol><h1 id="驱魔"><a href="#驱魔" class="headerlink" title="驱魔"></a>驱魔</h1><p>恶魔能附身、影响人们的正常生活，解除这种影响的方式称为驱魔。</p><p>驱魔在圣经中也是有很多记载的：</p><blockquote><p>耶稣叫了十二个门徒来，给他们权柄，能赶逐污鬼，并医治各样的病症。——《马太福音》10：1</p><p>医治病人，叫死人复活，叫长大麻风的洁净，把鬼赶出去。你们白白地得来，也要白白地舍去。——《马太福音》10：8</p><p>耶稣叫了十二个门徒来，差遣他们两个两个地出去，也赐给他们权柄，制伏污鬼；——《马可福音》6：7</p></blockquote><p>在天主教驱魔仪式为教会订立的圣仪之一，需要遵照教会的罗马礼书，只能由任命的司铎（或者更高级的圣职人员），需要经过当地主教的明确许可，并且只能在确定在仔细的药物治疗之后排除精神病的可能。</p><p>对于驱魔的具体方法，在圣经中是这样描述的：</p><blockquote><p>他们回到山下众人聚集的地方。有一个人过来跪在耶稣跟前，说：</p><p>“主啊！救救我的儿子吧！他患了癫痫症，痛苦极了，曾经几次跌进火中，掉进水里。</p><p>我带他去见你的门徒，但他们却不能治好他。”</p><p>耶稣说：“唉！这世代又不信又败坏的人啊，我要跟你们在一起待多久？我要容忍你们多久呢？把他带来吧。”</p><p>耶稣斥责附在孩子身上的鬼，鬼就离开了那孩子，从此他就好了。</p><p>事后，门徒私下问耶稣：“我们为什么赶不走那鬼呢？”</p><p>耶稣说：“你们的信心太小了。我实在告诉你们，你们若有像芥菜种那样大的信心，就算叫这座山从这里移到那里，它也会移开，你们将没有办不到的事。</p><p>至于这一类的鬼，你们必须祷告和禁食才能把它赶走。”</p><p>——《马太福音》17:14~21</p></blockquote><p>根据文本，驱魔所要求的，首先就是对于神的虔诚。</p><p>现代教会常常会有类似的文档来规范化驱魔的流程。</p><p>具体的驱魔实例可以参考<a href="https://www.washingtonpost.com/archive/local/2000/10/21/front-page-1949-boy-freed-of-possession-by-the-devil/e3567d03-f076-400a-9fa4-af77f9791da2/">约翰·霍夫曼的案例</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 神秘学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【神秘学】天使学笔记</title>
      <link href="/2024/01/25/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%A4%A9%E4%BD%BF%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/25/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%A4%A9%E4%BD%BF%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文讨论的天使——正如之前所讨论的神秘学一样——皆为基督教的观点。从这种角度来说，天使是为了侍奉耶和华(YHWH)而创造的。</p><h1 id="天使的三级九等分类法"><a href="#天使的三级九等分类法" class="headerlink" title="天使的三级九等分类法"></a>天使的三级九等分类法</h1><p>这种分类法在公元4世纪被提出，在公元5世纪被完善(De Coelesti Hierarchia)，不同的基督教派皆认可三级九等的分类法，然而对不同等级的天使种类，有着不同的称呼方式，尤以东正教和天主教之间的差异为甚。</p><p>这种分类方法的依据是<strong>天使和耶和华之间的距离</strong>。</p><h2 id="第一级"><a href="#第一级" class="headerlink" title="第一级"></a>第一级</h2><h3 id="一等：Seraphim-六翼天使"><a href="#一等：Seraphim-六翼天使" class="headerlink" title="一等：Seraphim-六翼天使"></a>一等：Seraphim-六翼天使</h3><blockquote><p>其上有撒拉弗侍立。各有六个翅膀。用两个翅膀遮脸，两个翅膀遮脚，两个翅膀飞翔。——《以赛亚书》6:2</p><p>那四个活物，各个都有六个翅膀，遍体内外都布满了眼睛。他们日夜不停地说：</p><p>“圣哉！圣哉！圣哉！<br>主、神、全能者，<br>昔在、今在、将要来临的那一位！”</p><p>——《启示录》4:8</p></blockquote><p>这一等的天使离耶和华最近，日夜不停地在歌唱颂歌。Seraphim在希伯来文中意味着“燃烧者”，所以也会被翻译成炽天使。</p><h3 id="二等：Cherubim-基路伯"><a href="#二等：Cherubim-基路伯" class="headerlink" title="二等：Cherubim-基路伯"></a>二等：Cherubim-基路伯</h3><blockquote><p>于是把他赶出去了；又在伊甸园的东边安设基路伯和四面转动发火焰的剑，要把守生命树的道路。——《创世纪》3:24</p><p>这四个基路伯天使的全身，包括他们的手、背、翅膀和轮子都布满了眼睛。——《以西结书》10:12</p><p>每一个基路伯天使都有四张脸：第一张是基路伯天使的脸，第二张是人的脸，第三张是狮子的脸，第四张是鹰的脸。——《以西结书》10:14</p></blockquote><p>Cherubim在希伯来文中意味着“充满着智慧”，所以也会被翻译为智天使。在《以西结书》中，基路伯更像是驾驶员，在《创世纪》中，则更像是看守。</p><p>此外，基路伯也用于装饰约柜上的施恩座：</p><blockquote><p>要用金子锤出两个基路伯来，安在施恩座的两头。——《出埃及记》25:18</p></blockquote><h3 id="三等：Ophanim-座天使"><a href="#三等：Ophanim-座天使" class="headerlink" title="三等：Ophanim-座天使"></a>三等：Ophanim-座天使</h3><blockquote><p>轮的形状和颜色（原文是作法）好像水苍玉。四轮都是一个样式，形状和作法好像轮中套轮。</p><p>轮行走的时候，向四方都能直行，并不掉转。</p><p>至于轮辋，高而可畏；四个轮辋周围满有眼睛。</p><p>——《以西结书》1:16~18</p></blockquote><p>轮中套轮的形象，轮子上面还有眼睛。</p><p>在《以西结书》中，这些天使像是被基路伯们操纵着的：</p><blockquote><p>基路伯天使移动，轮子也随之移动；基路伯天使展翅飞离地面，轮子也随之离开地面</p><p>基路伯天使停住，轮子也随之停住；基路伯天使上升，轮子也随之上升。因为活物的灵在轮子中。</p><p>——《以西结书》10:16～17</p></blockquote><h2 id="第二级"><a href="#第二级" class="headerlink" title="第二级"></a>第二级</h2><p>这一级的天使都有“保护”的职责，即保护天国免受恶魔入侵。</p><h3 id="四等：Dominions-主天使"><a href="#四等：Dominions-主天使" class="headerlink" title="四等：Dominions-主天使"></a>四等：Dominions-主天使</h3><p>他们的工作是将命令传递给下等的天使。</p><h3 id="五等：Virtues-力天使"><a href="#五等：Virtues-力天使" class="headerlink" title="五等：Virtues-力天使"></a>五等：Virtues-力天使</h3><p>他们的工作是掌管四季的变化，是神迹的执行者。</p><h3 id="六等：Powers-能天使"><a href="#六等：Powers-能天使" class="headerlink" title="六等：Powers-能天使"></a>六等：Powers-能天使</h3><p>有的时候也被称为“毁灭天使”，象征着他们的职责是同恶魔做斗争，也执行对人类的审判。甚至耶和华有时也认为他们的毁灭力量过于强大：</p><blockquote><p>于是耶和华降瘟疫在以色列地，从早晨直到所定的时间；从但到别是巴，众民中死了七万人。</p><p>当天使向耶路撒冷伸手，要毁灭耶路撒冷的时候，耶和华就后悔降这灾祸，就对那毁灭众民的天使说：“够了，现在住手吧！”那时，耶和华的天使在耶布斯人亚劳拿的打禾场那里。</p><p>——《撒母耳记下》24:15~16</p></blockquote><p>此外，也有这样的描述：</p><blockquote><p>当夜，耶和华的使者出去，在亚述营中杀了十八万五千人。清早有人起来，一看，都是死尸了。——《列王纪下》19:35</p><p>马口中喷出的这三样灾害杀死了世上三分之一的人口。——《启示录》9:18</p></blockquote><p>超高战力。</p><h2 id="第三级"><a href="#第三级" class="headerlink" title="第三级"></a>第三级</h2><p>这一等级的天使和人类的接触更多一些。</p><h3 id="七等：Principalities-权天使"><a href="#七等：Principalities-权天使" class="headerlink" title="七等：Principalities-权天使"></a>七等：Principalities-权天使</h3><p>他们的职责是保护国家、属地，也掌管领导人的更替等等。</p><h3 id="八等：Archangel-大天使"><a href="#八等：Archangel-大天使" class="headerlink" title="八等：Archangel-大天使"></a>八等：Archangel-大天使</h3><p>也称作天使长。圣经中明确提到的天使长只有米迦勒(Michael)。在希伯来文中，米迦勒可以翻译为“谁和神同等？”</p><p>有趣的是，米迦勒和撒旦有过一次交锋：</p><blockquote><p>就是天使长米迦勒为了摩西的尸体与魔鬼争论的时候，尚且不敢用毁谤的话定他的罪，只说：“主责备你！”。——《犹大书》1:9</p></blockquote><p>撒旦是一个堕落天使——属于基路伯等级。</p><h3 id="九等：Angel-天使"><a href="#九等：Angel-天使" class="headerlink" title="九等：Angel-天使"></a>九等：Angel-天使</h3><p>可以理解为守护天使，圣经中似乎认为，只有虔诚的信徒会有守护天使。然而，来自天使的保护并不会经常出现。似乎有一段时间，对圣经的解释从耶和华上挪移到了天使上，出现了短暂的天使崇拜。然而这忽视了基督教的一个预设：天使是耶和华的使者，他们不会违抗耶和华的命令来擅自帮助人类。</p><p>甚至圣子本人——耶稣，也最终被钉在十字架上。天使是否保护人类，在基督教看来，要遵循耶和华的旨意。</p><h1 id="七位？大天使"><a href="#七位？大天使" class="headerlink" title="七位？大天使"></a>七位？大天使</h1><h2 id="圣经的观点"><a href="#圣经的观点" class="headerlink" title="圣经的观点"></a>圣经的观点</h2><p>上面提到了。</p><h2 id="《以诺书》的观点"><a href="#《以诺书》的观点" class="headerlink" title="《以诺书》的观点"></a>《以诺书》的观点</h2><p>在《以诺书》——这一本书常被视为伪经——的第二十章提到了：</p><blockquote><ol><li>聖潔的天使警醒守望，他們的名字記在下面</li><li>烏利爾(Uriel)是個聖潔的天使，他屬於永恆和戰慄。</li><li>拉斐爾是個聖潔的天使， 他有人的霝。</li><li>拉古爾(Raguel) 是個聖潔的天使，他替世界和光體復仇。</li><li>米迦勒是個聖潔的天使，他順服亞呼威的旨意，對世人和國家施慈愛。</li><li>沙拉卡爾(Saraqa’el) 是個聖潔的天使，他受託管理罪人的心霝。</li><li>加百列是個聖潔的天使，他管理伊甸園、蛇和基路伯。</li></ol></blockquote><h2 id="《多俾亚传》的观点"><a href="#《多俾亚传》的观点" class="headerlink" title="《多俾亚传》的观点"></a>《多俾亚传》的观点</h2><p>这本书也被有些教派认为是伪经：</p><blockquote><p>多俾亚便出去寻找一个能与他同去玛待，并且熟识路途的人。他一出门，遇见辣法耳天使站在他面前；但是他不知道他是天主的使者。——《多俾亚传》5:4</p></blockquote><h2 id="仪式学的观点"><a href="#仪式学的观点" class="headerlink" title="仪式学的观点"></a>仪式学的观点</h2><p>在实际的仪式魔法操作中，比如小五芒星驱逐LBRP，常常只会用到四个、相对认可度比较大的天使：Michael、Raphael、Gabriel和Uriel。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 神秘学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Linux终端播放Bad Apple</title>
      <link href="/2024/01/24/%E7%94%A8Linux%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BEBad-Apple/"/>
      <url>/2024/01/24/%E7%94%A8Linux%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BEBad-Apple/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Bad Apple常常指一部影绘PV：<a href="https://www.bilibili.com/video/BV1xx411c79H">【東方】Bad Apple!! ＰＶ【影絵】</a>。在各大网站，您可以看到很多在不同设备上播放这个PV的视频，包括但不限于单片机液晶屏、国际象棋棋盘等。</p><p>本文主要讲述如何借助<code>libpng</code>、<code>ncurses</code>和<code>ffmpeg</code>，编写C语言程序，在<code>uxterm</code>上播放该视频。</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>基本思想是：我们需要将视频流转换为一张张图片，然后通过计算图片每个像素的灰度，输出白色&#x2F;黑色的色块，达到播放的效果。</p><p>首先，视频流转换为图片，可以使用<code>ffmpeg</code>工具，只需要在命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i VIDEO_NAME %04d.png</span><br></pre></td></tr></table></figure><p>这个意思是，将VIDEO_NAME这个视频流转化为一张张图片，图片是png格式，名称是一个补零四位数整数，比如<code>0001.png</code>、<code>0887.png</code>或<code>1145.png</code>。</p><p>为了查看图片的颜色属性，比如RGB、RGBA，可以使用<code>file</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 0001.png</span><br></pre></td></tr></table></figure><p>我这里输出的是RGB。</p><h1 id="图片的加载"><a href="#图片的加载" class="headerlink" title="图片的加载"></a>图片的加载</h1><h2 id="单个图片的加载"><a href="#单个图片的加载" class="headerlink" title="单个图片的加载"></a>单个图片的加载</h2><p>png图片的加载需要用到<code>libpng</code>这个库，读取的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">png_bytepp <span class="title function_">ReadPNG</span><span class="params">(<span class="type">char</span>* file_name, <span class="type">int</span>* height, <span class="type">int</span>* width)</span> &#123;</span><br><span class="line">  <span class="comment">// Read file</span></span><br><span class="line">  FILE* fp = fopen(file_name, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unable to read!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Initialize</span></span><br><span class="line">  png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  png_infop info_ptr = png_create_info_struct(png_ptr);</span><br><span class="line">  png_init_io(png_ptr, fp);</span><br><span class="line">  <span class="comment">// Read Info of a picture</span></span><br><span class="line">  png_read_png(png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, <span class="literal">NULL</span>);</span><br><span class="line">  png_bytepp row_pointers = png_get_rows(png_ptr, info_ptr);</span><br><span class="line">  <span class="comment">// Get height and width of a png picture</span></span><br><span class="line">  *height = png_get_image_height(png_ptr, info_ptr);</span><br><span class="line">  *width = png_get_image_width(png_ptr, info_ptr);</span><br><span class="line">  png_destroy_read_struct(&amp;png_ptr, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// Deinitalize</span></span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> row_pointers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的思路是这样的，首先读取png文件，接着创建读取png的相关结构体，接着读取图片，将像素输入到一个指定结构体里，获取图片的长和宽。</p><h2 id="多个图片的加载"><a href="#多个图片的加载" class="headerlink" title="多个图片的加载"></a>多个图片的加载</h2><p>首先，我们要获取图片的总数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetPNGNums</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span> &#123;</span><br><span class="line">    DIR* directory = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((directory = opendir(path)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(directory)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;d_type != DT_DIR) &#123;</span><br><span class="line">  ++total_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(directory);</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了<code>dirent</code>库，遍历文件夹，获取所有非文件夹的文件总数即可。</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>首先，要初始化窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitWindow</span><span class="params">()</span> &#123;</span><br><span class="line">  window = initscr();</span><br><span class="line">  refresh();</span><br><span class="line">  getmaxyx(window, *&amp;window_height, *&amp;window_width);</span><br><span class="line">  start_color();</span><br><span class="line">  <span class="comment">// Hide cursor</span></span><br><span class="line">  curs_set(<span class="number">0</span>);</span><br><span class="line">  refresh();</span><br><span class="line">  init_pair(<span class="number">1</span>, COLOR_WHITE, COLOR_BLACK);</span><br><span class="line">  init_pair(<span class="number">2</span>, COLOR_WHITE, COLOR_WHITE);</span><br><span class="line">  init_pair(<span class="number">3</span>, COLOR_BLACK, COLOR_BLACK);</span><br><span class="line">  wbkgd(window, COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">  attron(A_BOLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先初始化窗口，然后获取窗口的长和宽，这一步的目的是便于之后的图片缩放，接着初始化颜色色对，按照<em>编号，前景色，背景色</em>的顺序初始化即可，接着使用<code>wbkgd</code>设置窗口背景颜色。</p><p>接着，将每张图片的像素输出到窗口上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span>; h &lt; height; h+=HEIGHT_RATIO) &#123;</span><br><span class="line">     curr_col = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; width; w+=WIDTH_RATIO) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r = row_pointers[h][w*<span class="number">3</span>+<span class="number">0</span>],</span><br><span class="line">  g = row_pointers[h][w*<span class="number">3</span>+<span class="number">1</span>],</span><br><span class="line">  b = row_pointers[h][w*<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> gray = RGB2Gray(r, g, b);</span><br><span class="line"><span class="keyword">if</span>(gray &gt;= THRESHOLD) &#123;</span><br><span class="line">  attron(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">  mvaddch(curr_row, curr_col, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  attroff(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  attron(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">  mvaddch(curr_row, curr_col, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  attroff(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">curr_col++;</span><br><span class="line">     &#125;</span><br><span class="line">     curr_row++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里，<code>HEIGHT_RATIO</code>和<code>WIDTH_RATIO</code>分别代表图片长宽的缩放比例，比如<code>HEIGHT_RATIO</code>为2，就代表在图片长的遍历上，要跳过一个像素，这样图片的长就变为了原来的1&#x2F;2。</p><p>对于灰度的计算，我采用了一个近似的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">RGB2Gray</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> R, <span class="type">unsigned</span> <span class="type">int</span> G, <span class="type">unsigned</span> <span class="type">int</span> B)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (R+G+B)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着设置一个灰度阈值<code>THRESHOLD</code>，根据灰度与阈值的关系决定输出黑块&#x2F;白块即可。</p><p>在每次输出之后，需要应用<code>usleep()</code>睡眠一段时间，这个时间可以根据采样率等计算。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【神秘学】塔罗基础</title>
      <link href="/2024/01/18/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%A1%94%E7%BD%97%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/01/18/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%A1%94%E7%BD%97%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>塔罗最开始是一种卡牌游戏，后来才被用于占卜和神秘学目的。</p><p>已知最早的塔罗牌，出现于1430～1450之间的意大利，当时是用作游戏使用。塔罗牌应用于神秘学，最早记载于1540年，最开始没有牌阵一类的说法。知道1735～1750年，才出现了牌阵、牌意之类的说法。1791年，第一副用于占卜的塔罗牌被发行。</p><p>本节参见<a href="http://www.imslr.com/thread-33334-1-1.html">【历史向】告诉你一个真实的塔罗~！</a>。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="维特塔罗"><a href="#维特塔罗" class="headerlink" title="维特塔罗"></a>维特塔罗</h2><p>塔罗牌最常见的类型是维特(Waite)塔罗牌。</p><blockquote><p>该体系改善了原本小阿尔克那缺乏图像和故事的缺点，加上了丰富的象征和显而易懂的图像，初学者也不难从牌面猜测牌义，成为近代最受欢迎的塔罗牌。韦特牌的图案内藏不少暗示，其中有占星学、数字学、颜色学，且牌中内容更与神话或圣经故事结合，如“6．恋人”里的亚当和夏娃、“20．审判”里上帝的审判与死人之复活。由于牌面已充满了意义，解牌时会令牌师能更流畅及更易引发联想，故出版后即为不少牌师所选用。</p></blockquote><h2 id="马赛体系"><a href="#马赛体系" class="headerlink" title="马赛体系"></a>马赛体系</h2><p>流行于法国南部，常用作游戏牌使用。传承自最古老的塔罗牌体系。</p><h1 id="几种操作"><a href="#几种操作" class="headerlink" title="几种操作"></a>几种操作</h1><h2 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h2><p>洗牌的作用是将牌打乱，个人认为，只要是能将牌通过个人意志打乱的方法，都算是合理的洗牌方法。</p><h3 id="Riffle-Shuffle"><a href="#Riffle-Shuffle" class="headerlink" title="Riffle Shuffle"></a>Riffle Shuffle</h3><p>该方法演示参见：<a href="https://www.youtube.com/watch?v=CNkhBtOx2ug">How to Riffle and Bridge Shuffle</a>。</p><p>这种方法会使牌弯曲。</p><h3 id="穿插洗牌"><a href="#穿插洗牌" class="headerlink" title="穿插洗牌"></a>穿插洗牌</h3><p>抓一摞牌，塞到剩下一摞的里面，反复。</p><p>这种方法高效，但是没法产生逆位牌。</p><h3 id="Scrambling-Method"><a href="#Scrambling-Method" class="headerlink" title="Scrambling Method"></a>Scrambling Method</h3><p>把牌放在桌面上，然后摊开。用洗麻将的方式来洗牌。我个人很喜欢这个方式，因为这个方法不仅能在不损伤纸牌的情况下，将纸牌充分打乱；也可以产生足够数量的逆位牌。还有一个比较关键的原因：我的手比较笨。</p><h2 id="切牌"><a href="#切牌" class="headerlink" title="切牌"></a>切牌</h2><h3 id="指一种行为"><a href="#指一种行为" class="headerlink" title="指一种行为"></a>指一种行为</h3><p>切牌，即cut the cards，将一摞牌分成多摞的这个行为。</p><h3 id="指特定的一张牌"><a href="#指特定的一张牌" class="headerlink" title="指特定的一张牌"></a>指特定的一张牌</h3><p>这个意义上的切牌，也可以被称作惊喜牌，指将一摞牌分成多摞，然后让问卜者任意选一摞，这一摞最底下的那张牌。</p><p>这张牌的作用是<strong>查看问卜者的心态</strong>，也可以<strong>辅助解释牌阵的含义</strong>。</p><h2 id="底牌"><a href="#底牌" class="headerlink" title="底牌"></a>底牌</h2><p>底牌，即Shadow Card。即当组好牌阵之后，觉得牌阵的意义需要进一步解释，可以查看未选择牌堆的最下面一张牌，这张牌就称作底牌。</p><p>有的占卜师会将底牌用作进一步解释，有的占卜师也会将底牌作为事情的发展趋势，也有的占卜师，当给其他人占卜时，会将底牌当作一个解释牌阵含义的上下文。</p><h2 id="跳牌"><a href="#跳牌" class="headerlink" title="跳牌"></a>跳牌</h2><p>跳牌，即Jumper，即在洗牌时不小心掉落的少数(1～3)几张牌。这些牌可以当作<strong>来自异界的信号</strong>，或一种指示牌。</p><h2 id="指引牌"><a href="#指引牌" class="headerlink" title="指引牌"></a>指引牌</h2><p>偷个懒：</p><blockquote><p> 从定义上讲，<br> 一般来说（主流）：指示牌是指从16张宫廷牌里选出来一张牌，一般不会随机抽，代表当事人，即求问者。<br> 选取标准可以根据问卜者的星座、外貌、性别、年龄、职业、性格；但这些做法都有局限性。<br> 也有一种说法，如果求问的主体是人，那么从宫廷牌抽；如果主体不是人，用数字牌或者大牌（源自韦特）。<br> （存在一种说法，女性问卜者都用女祭司作为指示牌，男性都用魔术师）（我觉得这个可以划掉）</p><p> 从使用上说，<br> 有一种说法是，指示牌不需要解读，解读牌阵时也不需要参考它：<br> 指示牌的作用只是：让问卜者出现在牌阵里。<br> 比如，指示牌是星币国王，如果牌阵里出现星币王后，则这张王后可以代表问卜者的妻子，或0者代表他表现出女性化的一面。</p><p> 而另一种说法则认为，指示牌代表问卜者是以什么心态提问的，并且在解读牌阵时要考虑其与指示牌的相性如何：<br> 比如宝剑七，对于宝剑王后和星币国王，是不一样的。</p><p> 另外，同一个人在不同时间、不同问题，不需要固定用同一张指示牌。</p><p>——<a href="http://www.imslr.com/thread-48565-1-1.html">关于切牌，底牌，补牌，跳牌和指示牌</a></p></blockquote><h1 id="牌意的解释"><a href="#牌意的解释" class="headerlink" title="牌意的解释"></a>牌意的解释</h1><p>基本上，维特塔罗牌的牌意解释是<strong>看图说话</strong>。在参考材料的基础上，能够对牌意进行解释即可。</p><p>然而，为了避免过度的联想，也需要背诵和记忆。</p><h1 id="逆位牌的解释"><a href="#逆位牌的解释" class="headerlink" title="逆位牌的解释"></a>逆位牌的解释</h1><ol><li>逆位是正位的误用。</li><li>逆位是正位的过度或不足。</li><li>逆位是正位的削弱。</li><li>逆位要求避免正位带来的建议。</li><li>逆位单纯表明正位的反面。</li><li>逆位代表正位的不足。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 神秘学 </tag>
            
            <tag> 塔罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【神秘学】相位学与实例</title>
      <link href="/2024/01/16/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E7%9B%B8%E4%BD%8D%E5%AD%A6%E4%B8%8E%E5%AE%9E%E4%BE%8B/"/>
      <url>/2024/01/16/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E7%9B%B8%E4%BD%8D%E5%AD%A6%E4%B8%8E%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>所谓相位学，就是研究星球之间夹角的学科。</p><p>本文以一张随机星盘举例子：</p><p><img src="/2024/01/16/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E7%9B%B8%E4%BD%8D%E5%AD%A6%E4%B8%8E%E5%AE%9E%E4%BE%8B/example.png"></p><p>和一张表：</p><p><img src="/./example_chart.png"></p><p>这两张图是使用Astrolog制作的。</p><h1 id="理论性内容"><a href="#理论性内容" class="headerlink" title="理论性内容"></a>理论性内容</h1><p>星座和宫位一块运作，星座是身份，而宫位是身份运行的场所，代表心识觉察到的内容，而行星代表心识的真正结构。更加具体地来说：</p><blockquote><p>就现在来说,只需要记住行星告诉我们自己正在看哪个部份的心识(什么),星座告诉我们那些需要和策略在驱动这颗行星(为什么和怎样),而宫位则准确地告诉我们这个行星-星座组合会在生活的哪些领域发展出来(哪里)。——《内在的天空》</p></blockquote><h2 id="行星的逆行"><a href="#行星的逆行" class="headerlink" title="行星的逆行"></a>行星的逆行</h2><p>当一颗行星<strong>看起来</strong>是沿着反方向运行的时候，就称这颗行星是在逆行。只有太阳和月亮不会逆行。</p><h2 id="宫位的成功通过"><a href="#宫位的成功通过" class="headerlink" title="宫位的成功通过"></a>宫位的成功通过</h2><blockquote><p>个人理解：1、发挥出落在这个宫位的行星的正面特质算成功通过。这是从个人意志和修行的角度来说。<br>                  2、落在这个宫位的行星是和谐相位。因为和谐相位相对容易发挥出行星的正面特质。那么反之如果<br>                        落入的行星为克相，需要个人发挥更多的意识去矫正它。<br>                  3、行运行星路过时，无论和本命行星产生何种相位，皆保持清醒的意识去观察它，扬长避短。<br>以上都算一种成功通过吧。</p><p>——<a href="https://book.douban.com/subject/10546850/discussion/615744317/">讲到宫位时书中提到的“成功通过此宫”是什么意思？</a></p></blockquote><p>此外，空宫也算是成功通过。</p><h1 id="星盘组成内容解释"><a href="#星盘组成内容解释" class="headerlink" title="星盘组成内容解释"></a>星盘组成内容解释</h1><p>星盘左为东。</p><h2 id="十二宫"><a href="#十二宫" class="headerlink" title="十二宫"></a>十二宫</h2><p>十二宫在图上用数字标注，第一宫开始为Asc，上升星座，对位为第七宫起始，是为Dec，下降星座。第十宫起始为MC，中天，对位为第四宫起始，天底IC。</p><h2 id="实线与虚线"><a href="#实线与虚线" class="headerlink" title="实线与虚线"></a>实线与虚线</h2><p>实现表示相位比较正，影响力比较大；虚线表示相位不正，但是在容许度范围内，影响已经比较小了。此外线的颜色也代表不同多个相位关系：</p><table><thead><tr><th>角度</th><th>颜色</th></tr></thead><tbody><tr><td>合相</td><td>黄</td></tr><tr><td>六合相</td><td>浅蓝</td></tr><tr><td>四分相</td><td>红</td></tr><tr><td>三合相</td><td>绿</td></tr><tr><td>对相</td><td>蓝&#x2F;紫</td></tr></tbody></table><h2 id="House"><a href="#House" class="headerlink" title="House"></a>House</h2><p>表示宫位，1st House就是第一宫的意思，以此类推。</p><h2 id="行星与星座的位置"><a href="#行星与星座的位置" class="headerlink" title="行星与星座的位置"></a>行星与星座的位置</h2><p>Sun: 20Lib28，表示太阳落在天秤座(Lib)的20度28分。全部的缩写如下：</p><p>Ari-白羊，Tau-金牛，Gem-双子，Can-巨蟹，Leo-狮子，Vir-处女，Lib-天秤，Sco-天蝎，Sag-射手，Cap-摩羯，Aqu-水瓶，Pis-双鱼。</p><h2 id="逆行"><a href="#逆行" class="headerlink" title="逆行"></a>逆行</h2><p>在某些星体后面，会标注一个字母R，这表示该星体在逆行，在Retrograde。</p><h1 id="星球的含义"><a href="#星球的含义" class="headerlink" title="星球的含义"></a>星球的含义</h1><p>在分析星座的时候，也要考虑守护星体的影响。这一点还是要依靠神话和象征意义来解释。我极其厌恶不说原因，只说象征的占星教程。</p><p>太阳：太阳神是赫里俄斯，与天中奔腾，用光普照万物。同时太阳是至阳的。所以太阳象征着意志、生命力、自我的创造。太阳也会导致自私、自大。</p><p>月亮：月神是塞勒涅，月亮象征着阴性，而在古时候，月亮又象征着神秘。所以月亮象征直觉、习惯、灵魂的发展。月亮也会导致抑郁、忧愁、敏感。</p><p>水星：水星之神是赫尔墨斯，是商业、旅者、小偷与畜牧之神，也是万神的传信使者。所以水星象征思考、交流、信息的传达。水星也有轻浮、多动的色彩。</p><p>金星：金星之神是爱情与美丽的女神阿佛洛狄忒，阿佛洛狄忒美好，也有一段风流的往事。所以金星象征情感、美好，也有纵欲、虚荣、懒惰的色彩。</p><p>火星：火星之神是战争之神阿瑞斯，象征力量、权力，做事却不加思考。所以首先，负面层面，火星有易怒、好战、残忍的色彩。接着，正面考虑，火星有意志力、勇气方面的能量。</p><p>木星：木星之神为万神之神宙斯(很抱歉我将古希腊神话和罗马神话混为一谈，不过这些不影响我们理解)。木星象征生命的基本哲学、信念，也有过度扩张、虚伪的色彩。</p><p>土星：土星之神为萨图耳努斯，农业之神。在希腊神话中，土星之神是克洛诺斯，推翻了自己父亲残暴的统治，自己则被宙斯推翻撕碎。我个人觉得土星是很无聊的一个星体。土星象征孤独、遵从的法则。</p><p>天王星：天王星象征个性、质疑权威，也有特立独行、故意捣乱的色彩。我没法从神话故事中推出这些含义，唯一的理解是，天王星打破了原有占星学的体系。</p><p>海王星：海王星主精神、神秘体验，也有敏感、白日梦的体现。</p><p>冥王星：主天命、分辨真理的能力、性，死亡，重生，极端，也有夸大、暴力的色彩。</p><h1 id="相位学"><a href="#相位学" class="headerlink" title="相位学"></a>相位学</h1><p>具体的相位含义需要结合星球的类型来判断，一般来说：</p><h2 id="合相"><a href="#合相" class="headerlink" title="合相"></a>合相</h2><p>合相表示两个星球的能量融合在一起。然而具体的结果需要观察两个星球具体的性质是什么样子的。</p><blockquote><p>假如一个星盘里的火星和水星相合。一般来说,侵略性(火星)和智力(水星)在心识中各自有自己的疆域。其中的一个线路被发动时,不会激发另一个。当两颗行星是相合的时候就不是这样了。当其中的一个被启动时,另一个也会被启动。结果就是一个很锋利、尖锐的心智,它很有力,总是以长处和短处、胜利者和失败者的角度来考虑问题。所有的水星功能都会带有火星的竞争性色彩。那火星会受到什么影响呢?天生的侵略性会被智性化。这个人不太会在酒吧打斗中出现——但是他或者她可能会在政治或者宗教的讨论中展现杀手本能。头脑和舌头代替了挥舞的拳头。</p><p>——《内在的天空》</p></blockquote><h2 id="四分相"><a href="#四分相" class="headerlink" title="四分相"></a>四分相</h2><p>四分相表示两个星球之间的关系紧张。某些性质会在两个星球所代表的性质之间震荡。四分也叫做刑。相刑的两个星座没有任何相互理解的基础。</p><blockquote><p>相刑也有一样的目的: 这个相位所制造的摩擦会给行星带来无情的进化压力。想要生存,它们必须进化。只要滑倒一下,自我放纵一下,它们就会被践踏。不要妄图去解决一个相刑相位。你不会找到方法的。相刑是无法被解决的。即使在最好的情况下,它们也是性格中无法停止的焦躁的来源。而理想的情况是,这种焦虑是一种疗愈力量,不是走向宁静,而是走向成长和成就。</p><p>相刑的恐怖之处不在于说它们制造了这种二十二条军规般的两难境况。那只是这个相位所在的地带的状况。通过这个地带肯定不会很舒服,但是它总是让我们变得更加强大,让我们去掉任何软弱的反应。其实恐怖的地方是相刑的两端中有一端可能会赢。它可能会成功地粉碎另一个,让那一个变得被动和失去作用。然后我们就成了残废。组成我们的人性的十个基本“心理电路”中的一个被毁灭了。我们很重要一个部份缺失了。从此开始,我们与之对应的那一部分生活就成了灾难片,充满了不断重复的开始和失败。</p><p>——《内在的天空》</p></blockquote><h2 id="对分相"><a href="#对分相" class="headerlink" title="对分相"></a>对分相</h2><p>对分表示星球之间能量对冲。</p><blockquote><p>……传统的占星师称相冲相位为坏的……我们无需被这样浅陋的思考模式所限制。</p><p>如果一个出生星盘里有这个相冲相位的人能够同时将这两极都放进意识,让它们达成相互妥协,那么他或者她的生活将变丰富得多。她会常常放松,但是也会去拜访几个有趣心理学家。这就是相冲的意义所在——扩展我们的意识让我们能够看到问题的两面。如果我们成功了,我们就获得了弹性、变化、和适应性。</p><p>但是如果我们无法跟这个相冲的相位达成和谐呢?那会发生什么?那就会有可怕的后果。心识会在两极之间震荡。当其中一面占主导时,另一面就从意识中被挤出去了。我们可能会得到一种简单,但是失去了比它远为珍贵的东西:心智健康。在极端的情况下,相冲会造成两面的性格。两极中的一极抓住了我们的注意力,我们会基于它的需要来做决定。我们将后路上的桥都烧掉了。然后,一套完全相反的需要会驱动我们,将我们开始启动的所有东西都破坏掉。我们会这样反反复复很多年,成为自己最大的敌人,一事无成。</p><p>——《内在的天空》</p></blockquote><h2 id="三分相与六分相"><a href="#三分相与六分相" class="headerlink" title="三分相与六分相"></a>三分相与六分相</h2><p>这两个相位表示和谐。</p><blockquote><p>对三合来说,重要的是要看到它们代表了生命中那些拥有无尽成长潜能的领域。在心识之中形成了一对盟友,两颗行星准备为了一个共同目标而共同努力,相互之间不会有任何的摩擦。但是因为缺乏摩擦也让它们陷入睡眠。我们必须唤醒它们。我们必须想象有什么力量沉睡在这相位之中,然后以意识和自律的行动来释放它们。</p><p>……</p><p>比如说一颗在狮子座的行星和一颗在双子座的行星之间有一个六合相位。驱动第一颗行星的“为什么”是自我表达,驱动第二颗行星的是信息收集。狮子座会发射,双子座会接收和要求更多。而这让狮子座很高兴,它会发射更多的东西。于是这个过程会加速,两颗行星都被激发而进入了运作状态。这就是六合。</p><p>——《内在的天空》</p></blockquote><h2 id="大T相位"><a href="#大T相位" class="headerlink" title="大T相位"></a>大T相位</h2><p>两个行星对冲，另一个行星和其中的行星四分。这个相位也叫做三刑会冲。</p><h2 id="劫夺"><a href="#劫夺" class="headerlink" title="劫夺"></a>劫夺</h2><p>若一个宫位将整个星座都包起来，星座没有触碰宫位的宫头，则表示该星座被劫夺。</p><h1 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h1><h2 id="宫位学的解读"><a href="#宫位学的解读" class="headerlink" title="宫位学的解读"></a>宫位学的解读</h2><p>第一步：看行星。我们所考虑的什么心识功能?我们在说心识的哪个部份?是太阳的自我形成?还是土星的纪律建立?</p><p>第二步：看星座。它是在驱动这颗行星的东西。那个行星功能在寻求什么?它的行动之下是“为什么”?它隐藏的动机是什么?</p><p>第三步：想一想,这个“行星-星座”组合怎样完成它的目标?星座提供了哪些相关的资源?行星呢?你可能会需要去查书。如果你是这个人,你拥有这些长处和责任,你会如何去得到幸福呢?</p><p>第四步：想一想,这个“行星-星座”组合可能会被怎样地扭曲?哪种行为会跟这个碎片的意义一致但是跟它的进化目的不一致?如果你不确定,可以查看星座章节里的阴影以及行星章节里</p><p>可能发展出的缺点。<strong>请记住,以一种警告的方式来呈现这些可能缺点,而不是以预言的方式。</strong></p><p>第五步：看宫位。这个“行星-星座”的事务会在哪里发展?它们会创造出什么样的行为?如果对这个“行星-星座”进行一个强的反应的话,在这个人生活的哪个部份会产生一些境遇的改进？</p><p>而一个弱的反应会在哪里造成紧张和不安?宫位会回答这些。</p><h2 id="相位学的解读"><a href="#相位学的解读" class="headerlink" title="相位学的解读"></a>相位学的解读</h2><p>总的来说，相合、相冲、相刑、三合、六合,这五个是主要相位。它们代表了行星之间的五种基本互动方式: 融合、拉扯、摩擦、和谐、激发。</p><p>接着，要查看月亮南北交点的意义：</p><ol><li>南交点：南交点象征了我们的祖先对我们的影响，是与生俱来的一种能量，一种本能，一种自动做出的选择或者行为。</li><li>北交点：北交点则象征成长的前沿，一种趋势。</li></ol><h2 id="结合起来"><a href="#结合起来" class="headerlink" title="结合起来"></a>结合起来</h2><p>按照如下的原则操作。</p><h3 id="第一原则：日月和上升原则"><a href="#第一原则：日月和上升原则" class="headerlink" title="第一原则：日月和上升原则"></a>第一原则：日月和上升原则</h3><p>在你能够完全透彻地理解了太阳、月亮和上升之前，忽略所有其它信息。这一步的分析主要是：</p><ol><li>看太阳。太阳所在的星座表示这个人为什么而活，然后观察其宫位。</li><li>看月亮。月亮表示主观、情绪特质的形成，然后观察其宫位。</li><li>看上升星座。</li><li>结合三种星体带来的启示，如果有，分析日月、上升点三者的相位关系。</li><li>得到最终的结果：他是一个(太阳带来的身份标签)，有着(月亮带来的内在标签)一样的灵魂，戴着(上升星座带来的启示)的面具。</li></ol><h3 id="第二原则：分布原则"><a href="#第二原则：分布原则" class="headerlink" title="第二原则：分布原则"></a>第二原则：分布原则</h3><blockquote><p>地平线将星盘分为上下两个半球。上半球代表客观,下半球代表主观。……东边象征着自由和个人选择,而西边则代表命运或者宿命。——《内在的天空》</p></blockquote><p>侧重于某个半球所描述的是生活的样子,而不是这个人的个性。它所揭示的是游戏的规则,而不是游戏者的个性。这主要影响解释的方面，比如星球大多出现在左边(东边)，可能要更多解释有关个人责任感的事情。</p><h3 id="第三原则：重点星体原则"><a href="#第三原则：重点星体原则" class="headerlink" title="第三原则：重点星体原则"></a>第三原则：重点星体原则</h3><ol><li><p>看上升星座的守护星。这里可以将天王星、海王星和冥王星也当作某些星座的守护星来看。</p></li><li><p>看入庙的行星，即那些落在自己守护星座内的行星。其次，对于宫位，也要用类似的方法查看。</p></li><li><p>看和太阳相合的行星。然后，如果一个星座&#x2F;宫位里出现了多颗星体，就先独立分析，然后将各种涵义做妥协。</p></li><li><p>看四条轴线：MC、IC、Asc和Dec，和这些轴线做合相的星体也很重要。宫位学角度，第一宫、第四宫、第七宫、第十宫,这些宫位是本位宫位(angular houses),落在这些宫位里的行星地位也都会得到提升。它也会变成一个焦点行星。</p></li><li><p>看单独出现在四个半球中其中一个的星体&#x2F;月亮交点，是为孤星。这样的一个格局给这颗行星很大的负担。那个半球的重点——客观、主观、自由、或者宿命——完全有赖于它。为了补偿这种不平衡,心识会增加这颗行星的影响。这颗行星的特质会扩散到整个星盘,远远超过我们通常会期待一颗行星、星座、宫位、或者相位会做的。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 神秘学 </tag>
            
            <tag> 占星学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【密码学】各类密码小记</title>
      <link href="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要罗列一些比较冷门的、不常用的密码。</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>参考了<a href="http://www.imslr.com/thread-24995-1-1.html">指引社：20090704讲义《神秘学文字》</a>的内容。该文章内也提到了很多其它文字，但是用的人并不多，这里略去一部分。</p><h1 id="替换加密"><a href="#替换加密" class="headerlink" title="替换加密"></a>替换加密</h1><p>所谓替换加密，拿英语举例子，就是把A-Z字母替换成其它的符号。这种方法可以通过字母频率法来破解。</p><h2 id="女巫字母表"><a href="#女巫字母表" class="headerlink" title="女巫字母表"></a>女巫字母表</h2><p>女巫字母表(Witches’ alphabet)，也称作Theban字母表(Theban Alphabet)，由阿格里帕·冯·内特斯海姆(Agrippa von Nettesheim, 1486-1535)设计。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/theban.png"></p><h2 id="Malachim字母表"><a href="#Malachim字母表" class="headerlink" title="Malachim字母表"></a>Malachim字母表</h2><p>同样由阿格里帕设计。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/malachim.png"></p><h2 id="天使文字"><a href="#天使文字" class="headerlink" title="天使文字"></a>天使文字</h2><p>由阿格里帕设计。其声称该文字是上帝给予的，用来和天使交流。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/celestial.jpg"></p><h2 id="Transitus-Fluvii字母表"><a href="#Transitus-Fluvii字母表" class="headerlink" title="Transitus Fluvii字母表"></a>Transitus Fluvii字母表</h2><p>也称作渡河字母表，由阿格里帕设计，脱胎于希伯来文。和天使文字、Malachim文字类似。</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/fluvii.png"></p><h2 id="爱诺克文字"><a href="#爱诺克文字" class="headerlink" title="爱诺克文字"></a>爱诺克文字</h2><p>据信，该文字由Edward Kelly从“天使那里学来”。广泛用于现由金色黎明组织传承的以诺魔法体系中：</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/ainuoke.png"></p><h2 id="苏州码"><a href="#苏州码" class="headerlink" title="苏州码"></a>苏州码</h2><p>苏州码用于对数字的加密，脱胎于算筹：</p><p><img src="/2024/01/15/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%90%84%E7%B1%BB%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/soochow.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【神秘学】占星学基础</title>
      <link href="/2024/01/15/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%8D%A0%E6%98%9F%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/01/15/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%8D%A0%E6%98%9F%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>占星学，astro-logy，在拉丁语中，astron-表示星星，-logia，代表一种理论。占星学就是一门星星的学问。</p><p>根据研究的主题，占星学可以被分类为自然占星学(气候、地震等)、世运占星学(政治、股市等)、个人占星学(心理、健康等)和事件占星学(选择、占卜)。</p><p>本篇讨论占星学的基础概念和星座的概念。</p><h1 id="古典占星学与现代占星学"><a href="#古典占星学与现代占星学" class="headerlink" title="古典占星学与现代占星学"></a>古典占星学与现代占星学</h1><p>古典的占星学常常将卜卦占星作为重点，而现代的占星学常常将解读星盘作为重点。星盘，是一种图，记述着星座和星体的位置、彼此之间的夹角等。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="天球与天极"><a href="#天球与天极" class="headerlink" title="天球与天极"></a>天球与天极</h2><p>天球(Celestial sphere)是与地球共球心，共自转轴，半径无限大的球体。</p><p>天极(Celestial pole)则是地球自转轴延长线与天球的焦点。</p><h2 id="天赤道、黄道、黄纬与黄经"><a href="#天赤道、黄道、黄纬与黄经" class="headerlink" title="天赤道、黄道、黄纬与黄经"></a>天赤道、黄道、黄纬与黄经</h2><p>天赤道(Celestial equator)则是赤道平面与天球的焦点。</p><p>黄道(Ecliptic)是太阳在天球上运行轨迹线。根据相对运动的对等性，也可以理解为地球公转在天球上的运行轨迹。黄道面和天赤道面的交角就是所谓的黄赤交角。</p><p>天球上，与黄道平行的线称为黄纬(Ecliptic latitude)，垂直的线称为黄经(Ecliptic longitude)。黄纬从黄道开始算，而黄经则要从春分点开始计算，春分点为太阳在黄道上运行时，由南往北穿越赤道时的交点。</p><h2 id="黄道带-Zodiac"><a href="#黄道带-Zodiac" class="headerlink" title="黄道带(Zodiac)"></a>黄道带(Zodiac)</h2><p>来自指引社的教程：黄道带是以黄道为中心，左右各扩展9度，总宽18度的一条带。也有说扩展8.5度，共17度宽的一条带。</p><p>在天文学中，黄道带展开的角度略有不同。</p><p>在地球上看，不同星星的运动轨迹都很贴近黄道，为了准确确定这些位置，人们找出了最大的行星偏移角度，用一条带确定位置。</p><h2 id="岁差与章动"><a href="#岁差与章动" class="headerlink" title="岁差与章动"></a>岁差与章动</h2><p>岁差，即为地轴进动(Axial precession)，指地球的自转轴在空间中的变化，其表现为赤道岁差和黄道岁差。赤道岁差的表现为春分点每年向西行进，黄道岁差的表现为春分点每年向东行进。二者的合变化称为总岁差，春分点总的变化。</p><p>章动(Nutation)，是一种很有意思的现象：在行星或陀螺仪的自转运动中，轴在进动中的一种轻微不规则运动，使自转轴在方向的改变中出现如“点头”般的摇晃现象。</p><h2 id="占星学的星座分割法"><a href="#占星学的星座分割法" class="headerlink" title="占星学的星座分割法"></a>占星学的星座分割法</h2><p>在天文学钟，星座分割是不均的。然而在占星学中，人们将黄道带等分为12份，每份30度黄经交角。</p><h2 id="星体的符号表示法"><a href="#星体的符号表示法" class="headerlink" title="星体的符号表示法"></a>星体的符号表示法</h2><p>如下表：</p><p><img src="/2024/01/15/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%8D%A0%E6%98%9F%E5%AD%A6%E5%9F%BA%E7%A1%80/star_repre.png"></p><h1 id="相位基础"><a href="#相位基础" class="headerlink" title="相位基础"></a>相位基础</h1><p>占星学中，有几个比较重要的角度：0°，30°，60°，90°，120°，150°以及180°</p><p>其中60°，90°，120°，180°被称作“托勒密相位”。30°，150°是后期加入的现代相位。0°确切点说不能叫相位。90°和180°并不和谐，而150°与健康相关，30°为中立相位。剩下的通常被认作是和谐相位。</p><p>不同的角度，有不同的称呼方法：</p><table><thead><tr><th>角度</th><th>称呼</th><th>容许度</th></tr></thead><tbody><tr><td>0°</td><td>合相</td><td>10°</td></tr><tr><td>60°</td><td>六分相&#x2F;六合相</td><td>4°</td></tr><tr><td>90°</td><td>四分相</td><td>5°～10°</td></tr><tr><td>120°</td><td>三分相&#x2F;三合相</td><td>5°～10°</td></tr><tr><td>180°</td><td>对分相</td><td>5°～10°</td></tr></tbody></table><p>容许度表示，在这个偏差范围内，都可以算是这个相。不同行星的不同角度有不同的容许度，上面的容许度只是一个参考值而已。</p><h2 id="托勒密主宰体系"><a href="#托勒密主宰体系" class="headerlink" title="托勒密主宰体系"></a>托勒密主宰体系</h2><p>参考上一章<a href="https://coder109.github.io/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/">【神秘学】基础理论</a>。</p><p>图示如下：</p><p><img src="/2024/01/15/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%8D%A0%E6%98%9F%E5%AD%A6%E5%9F%BA%E7%A1%80/stars.png"></p><p>我们将0°设为狮子座与巨蟹座的交点，二者的守护星体为太阳和月亮，分别为太阳和太阴。</p><p>从交点出发，两端运行30°，到达双子座、处女座，称为“水星相位”，因为这两个星座由水星主宰。水星的吉凶为“无”，所以是中立相位。</p><p>运行60°，和谐，因为金星为“小吉”。</p><p>如此如此，可以推出不同相位的吉凶关系：90°不和谐，120°大和谐。此外，150°常与健康联系起来，180°为太阳和太阴的正反结合。</p><h2 id="经纬度的单位"><a href="#经纬度的单位" class="headerlink" title="经纬度的单位"></a>经纬度的单位</h2><p>经度可以用“度”衡量，也可以用“时秒分”衡量，而维度只能用“度”衡量。</p><p>以黄道坐标系来衡量，黄纬常常以“度”衡量，而黄经则常为“双鱼座25°”的格式。</p><h1 id="星座学基础"><a href="#星座学基础" class="headerlink" title="星座学基础"></a>星座学基础</h1><h2 id="基础的星座分类"><a href="#基础的星座分类" class="headerlink" title="基础的星座分类"></a>基础的星座分类</h2><p>根据星座的阴阳性，可以分为：</p><ol><li>阳性星座，也称为主动星座。<ol><li>火象星座：白羊、双子、射手。</li><li>风象星座：双子、天秤、水瓶。</li></ol></li><li>阴性星座，也称为被动星座。<ol><li>地象星座：金牛、处女、摩羯。</li><li>水象星座：巨蟹、天蝎、双鱼。</li></ol></li></ol><h2 id="星座的含义"><a href="#星座的含义" class="headerlink" title="星座的含义"></a>星座的含义</h2><p>占星学来自神话和象征，那么星座的含义也就要参考神话和象征。部分参考<a href="http://www.imslr.com/thread-5304-1-1.html">【方杖】用最通俗的角度去看12星座的性质</a>系列，有修改。</p><p>白羊座：火星+火象。火星来自希腊神话的战神阿瑞斯，火象又是一个极其阳性的象。象征能量、暴怒、专制等。</p><p>金牛座：金星+土象。金星为古希腊神话的爱情与美丽的女神阿佛洛狄忒。土与生育，一种有关金钱的印象。</p><p>双子座：水星+风象。水星为古希腊神话的赫尔墨斯，是商业、旅者、小偷与畜牧之神，风是不确定而变动的。双子座则多变动而机智伶俐。</p><p>巨蟹座：月亮+水象。月亮之神为塞勒涅或露娜。巨蟹座是一个阴性的星座，所以主要和母性、敏感等相关。巨蟹座同时也是家庭宫。</p><p>狮子座：太阳+火象。太阳之神为阿波罗。太阳至阳，佐以火。帖子中说，太阳+火，能量太多没处发泄，导致狮子座主爱情……倒也有一点道理。</p><p>处女座：水星+土象。象征知性和工作。大概可以理解为赫尔墨斯安定下来了吧。</p><p>天秤座：金星+风象。将美丽与爱情传播开来，故善于交际。而也有解释为浮于表面的美丽，追求一种平衡，故也主夫妻关系等。</p><p>天蝎座：冥王星+水象。冥王即哈迪斯。主死亡、性、遗产。个人并不清楚水相的影响。</p><p>射手座：木星+火象。木星之神为朱庇特，对标宙斯。所以更偏向侵略性、无耐心。也有解释为对问题的长期考虑。</p><p>摩羯座：土星+土象。土星之神为萨图尔努斯，农业之神，佐以土，像极了一个老农夫的样子。故保守、勤奋而严肃，又专横理智。</p><p>水瓶座：天王星+风象。天王即乌拉诺斯。主社交。我不清楚原因。</p><p>双鱼座：海王星+水相。海神为尼普顿&#x2F;波塞冬。主精神。也不清楚原因。</p><h2 id="行星位置与星座的关系"><a href="#行星位置与星座的关系" class="headerlink" title="行星位置与星座的关系"></a>行星位置与星座的关系</h2><p>入庙：简称为“庙”，是指行星位于守护星座。</p><p>失势：简称为“弱”，是指行星位于守护星座的相反星座。</p><p>旺相：简称为“旺”，是指行星不位于守护星座，而是位于所守护星座之外的一个有亲和力的星座。</p><p>落陷：简称为“陷”，是指行星处于亲和力星座的相反星座。</p><h2 id="后天十二宫"><a href="#后天十二宫" class="headerlink" title="后天十二宫"></a>后天十二宫</h2><p>后天十二宫的含义分别为，我、我的事物、当前环境、我的私生活、我付出的爱、我的身体状况、另一个人、他人所有物、远处住所、我的社会生活、我所获得的爱和我的心理状况。也可以概括为个人宫、财帛宫、兄弟宫、田宅宫、子女宫、奴仆宫、夫妻宫、疾厄宫、迁移宫、官禄宫、福德宫和相貌宫。</p><p>推导方法如下：</p><ol><li>上升星座(Asc)为命宫或第一宫。上升星座为出生时东方地平线上上升的星座，在星盘软件上常常会标记出来。</li><li>下降星座为第七宫(Dec)。位于地平线西端，常为Asc的对位。</li><li>中天为天顶、第十宫(MC)。在星盘顶端或南端。</li><li>相反的点称为天底、第四宫(IC)。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 神秘学 </tag>
            
            <tag> 占星学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【神秘学】基础理论</title>
      <link href="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>大多参考《当神秘学来敲门》这本书，也结合了<a href="www.imslr.com">指引社</a>的一些好文章。</p><p>依稀记得以前读《周易》时，序文中写道“观物取象，象以尽义”。这一点上，东西方神秘学基本相同。</p><h1 id="神秘学的基本范畴"><a href="#神秘学的基本范畴" class="headerlink" title="神秘学的基本范畴"></a>神秘学的基本范畴</h1><p>神秘学的范畴分为四个部分：</p><ol><li>宇宙论：了解万事万物的原理，主要研究<strong>宇宙演化</strong>和<strong>万事万物的分类体系</strong>。</li><li>秘传心理：了解人类本身的状态。</li><li>预测学。根据预测基准的不同，预测学大致分为三种：依靠外部秩序的预测（占星学、手相学）、依靠工具的预测（塔罗牌、灵摆）和依靠人体感官（灵视、梦境）。</li><li>魔法学：想办法改变世界。诸如芳香疗法、矿物疗法等。</li></ol><p>前两点算是认识的范畴，后两者则是实践的范畴。</p><h1 id="占星学"><a href="#占星学" class="headerlink" title="占星学"></a>占星学</h1><p>占星学，原意是星星的学问，根据天体的位置、运行变化等获得信息。占星学也是传承最为久远的一门体系。根据研究的主题，占星学可以被分类为自然占星学(气候、地震等)、世运占星学(政治、股市等)、个人占星学(心理、健康等)和事件占星学(选择、占卜)。</p><h2 id="中古天体秩序"><a href="#中古天体秩序" class="headerlink" title="中古天体秩序"></a>中古天体秩序</h2><p>比如Chaldean秩序，传统上来说，可视行星的顺序以他们运行的速度来排列，也就是：土星，木星，火星，太阳，金星，水星，最后是月亮。</p><p>以地球为中心，运行越慢的星体越靠近地球，则得出了一个天体体系图：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/astro.png"></p><h2 id="象征学意义"><a href="#象征学意义" class="headerlink" title="象征学意义"></a>象征学意义</h2><p>占星学来自于神话和象征符号。</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/planet.png"></p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/conste.png"></p><p>有的行星遇到某些星座，会得到力量加强的关系，称为守护，除了太阳和月亮，每个星体守护两个星座。</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/protect.png"></p><h1 id="手相学"><a href="#手相学" class="headerlink" title="手相学"></a>手相学</h1><blockquote><p>西方也看这玩意啊，属实没想到。——幻</p></blockquote><p>惯用手是外显&#x2F;后天(因为其容易改变)的部分，非惯用手就是内敛&#x2F;先天的部分。对手相的分析可以分为几个步骤：掌形分析、手指分析、掌丘分析、掌纹分析。</p><p>这部分不怎么感兴趣，略过。</p><h1 id="灵数学"><a href="#灵数学" class="headerlink" title="灵数学"></a>灵数学</h1><blockquote><p>这个方法有些太简单了，感觉灵活性不强。——幻</p></blockquote><p>古老的灵数学大多来自于毕达哥拉斯，现在的灵数学则多来自于犹太密契主义的卡巴拉学派。</p><h2 id="对灵数学的不同认识方法"><a href="#对灵数学的不同认识方法" class="headerlink" title="对灵数学的不同认识方法"></a>对灵数学的不同认识方法</h2><p>毕达哥拉斯对于灵数学的认识：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/Pyta.png"></p><p>卡巴拉对于数字的认识：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/Qab1.png"></p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/Qab2.png"></p><p>现代灵数学基本以九个数字为基础：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/mod_num.png"></p><h2 id="不同的灵数"><a href="#不同的灵数" class="headerlink" title="不同的灵数"></a>不同的灵数</h2><p>姓名也有对应的数字，分为三类，灵魂数字(姓名中元音数字相加)、个性数字(辅音数字相加)、天命数字(所有字母数字相加)。计算若出现两位数字，则将十位数字与个位相加，直至成为一位数字。</p><p>生日也有对应的生日灵数，生日、生月、生年数字，生命灵数的计算方法为前三个数字相加。</p><p>若要计算某人某年的运势，则将当年的年度数字加上本人的生日灵数和生月灵数。</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/yrnum.png"></p><h1 id="塔罗学"><a href="#塔罗学" class="headerlink" title="塔罗学"></a>塔罗学</h1><p>塔罗牌起源于中世纪的南部欧洲。现在的塔罗牌不仅限于占卜，也可用于仪式和护身符。</p><h2 id="塔罗牌分类"><a href="#塔罗牌分类" class="headerlink" title="塔罗牌分类"></a>塔罗牌分类</h2><p>塔罗牌共有七十八张，有二十二张代表抽象原理，称为大阿尔卡纳(Major Arcana)。这二十二张按照如下排列方式，可看作三阶段愚者的旅程：预备期、成熟期、完成期。</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/MajArcana.png"></p><p>根据所代表事物分类，分为宫廷牌、数字牌。数字牌共四十张，分为四组，一组十张，分别为圣杯、权杖、钱币(依稀记得以前学的时候，称之为星币)、宝剑。</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/palace.png" alt="宫廷牌人物角色表"></p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/num_card.png" alt="数字牌含义表"></p><h2 id="问题与牌阵"><a href="#问题与牌阵" class="headerlink" title="问题与牌阵"></a>问题与牌阵</h2><p>塔罗牌一般处理事件，可以通过问问题设定范围或者通过选择排阵作为引导。</p><p>牌阵分为四类：时序类、状况类、选择类和综合类。不同的牌阵有不同的应用场景。</p><h2 id="占卜过程"><a href="#占卜过程" class="headerlink" title="占卜过程"></a>占卜过程</h2><p>洗牌-&gt;切牌-&gt;选牌-&gt;开牌-&gt;解释-&gt;建议。</p><h1 id="灵摆"><a href="#灵摆" class="headerlink" title="灵摆"></a>灵摆</h1><blockquote><p>穷b专属！——幻</p></blockquote><p>灵摆分为棍杖法(Dowsing Rod)和摆垂法(Pendulum Dowsing)。应使用自然材质做成。</p><h2 id="棍杖法"><a href="#棍杖法" class="headerlink" title="棍杖法"></a>棍杖法</h2><p>古代的卜杖常用Y形树枝制成，现代为L形。</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/DowsingRod.png"></p><p>影视作品中常见的寻龙摆就是一个棍杖法的实例。</p><h2 id="摆垂法"><a href="#摆垂法" class="headerlink" title="摆垂法"></a>摆垂法</h2><p>顺时针转为有好处，逆时针转有害处，不转说明不放松。</p><blockquote><p>实际上，也可以内心默念不同转动方向所代表的意义，这个方法有的时候准确率高得惊人。——幻</p></blockquote><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/Pendulum1.png"></p><h1 id="梦境与出体体验"><a href="#梦境与出体体验" class="headerlink" title="梦境与出体体验"></a>梦境与出体体验</h1><blockquote><p>清明梦之类。我从来没有做过可控的清明梦。——幻</p></blockquote><h1 id="灵视"><a href="#灵视" class="headerlink" title="灵视"></a>灵视</h1><p>灵视并非仅仅指穿墙看东西之类(没人能做到罢了)，而是指通过眼睛观察事物，判断事物的属性或查看灵体(鬼魂等)。</p><p><strong>灵视不同于视觉化。</strong></p><h2 id="气场观察"><a href="#气场观察" class="headerlink" title="气场观察"></a>气场观察</h2><p>灵视也可以用来观察人体的气场，判断人体的健康状况等。一种练习方法如下：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/vision_training.png"></p><p>气场的不同颜色也代表着不同的功能：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/blahblahblah.png"></p><h1 id="召唤术与降术"><a href="#召唤术与降术" class="headerlink" title="召唤术与降术"></a>召唤术与降术</h1><blockquote><p>略去一部分。——幻</p></blockquote><h2 id="天使学"><a href="#天使学" class="headerlink" title="天使学"></a>天使学</h2><p>依据基督教的神学系统，天使可以分为三层九类：</p><ul><li>第一层：最接近上帝，以纯粹的光和思想存在。包括炽天使(Seraphim)、智天使(Cherubim)、座天使(Ofanim)。</li><li>第二层：负责调和人世间对立。包括主天使(Dominions)、力天使(Virtues)、能天使(Powers)。</li><li>第三层：比较多出现在人间，包括权天使(Principalities)、大天使(Archangels)、天使(Angels)。</li></ul><p>比较著名的是大天使的等级，被称为天使长，比较共识的四大天使为：米迦勒(Michael)、拉斐尔(Rapheal)、加百列(Gabriel)和乌列(Uriel)。象征如下：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/arch_symbol.png"></p><h2 id="恶魔学"><a href="#恶魔学" class="headerlink" title="恶魔学"></a>恶魔学</h2><p>恶魔学是比较晚的事情，早期欧洲将邪恶势力称为撒旦(Satan)或恶魔(Devil)，并没有做太多区分。</p><h2 id="四要素精灵"><a href="#四要素精灵" class="headerlink" title="四要素精灵"></a>四要素精灵</h2><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/Elem.png"></p><h1 id="仪式魔法"><a href="#仪式魔法" class="headerlink" title="仪式魔法"></a>仪式魔法</h1><p>对近代仪式魔法影响最大的人是法国魔法师列维，参见<a href="https://www.imslr.com/thread-65039-1-1.html">埃利法斯莱维——伟大的社会主义魔法师 - 新手討論區 - Aeons隱知_神秘學網站（指引社）</a>。接着随着黄金黎明的结社的传播，仪式学也逐渐广泛开来。</p><p>仪式流程为：开启、召唤、施法、散开、结束。</p><h1 id="符咒"><a href="#符咒" class="headerlink" title="符咒"></a>符咒</h1><blockquote><p>我等穷b整不起。——幻</p></blockquote><p>和护身符相比，符咒是“主动的道具”。符咒大多由金属、羊皮纸制作而成，通过特定的仪式启动。不同的象征需要不同的金属。</p><h1 id="水晶疗法"><a href="#水晶疗法" class="headerlink" title="水晶疗法"></a>水晶疗法</h1><p>水晶和星座的对应关系由来已久：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/cry_con.png"></p><p>刚买来的水晶需要净化，可能是能量场相关的原因。一般可以使用：</p><ol><li>海盐净化法：用足够多的海盐埋藏7～24小时。</li><li>晶洞法：将水晶放在晶洞里长达12～24小时。</li><li>土埋法：将水晶埋入土中，长达7～28<strong>天</strong>。</li></ol><h1 id="芳香疗法"><a href="#芳香疗法" class="headerlink" title="芳香疗法"></a>芳香疗法</h1><p>芳香疗法来自于法国化学家盖特·佛赛。</p><p>常依靠薰香、按摩、泡澡、使用等方法。</p><h1 id="色彩疗法"><a href="#色彩疗法" class="headerlink" title="色彩疗法"></a>色彩疗法</h1><p>色彩疗法来自大名鼎鼎的脉轮学说(Chakras，音近查克拉)。该理论认为色彩是有性质的。比如四种基本的元素可以形成一种关系：</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/four_color.png"></p><p>与脉轮的关系对应如下:</p><p><img src="/2024/01/14/%E3%80%90%E7%A5%9E%E7%A7%98%E5%AD%A6%E3%80%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/cha_colour.png"></p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>这里所指的神秘学为西方神秘学。我个人对于东方的神秘学不是很感兴趣：周易、中医等等。但是无论哪个神秘学，很多理论都是相通或者类似的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 神秘学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【乐理】和弦种类</title>
      <link href="/2024/01/11/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%BC%A6%E7%A7%8D%E7%B1%BB/"/>
      <url>/2024/01/11/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%BC%A6%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="挂留和弦"><a href="#挂留和弦" class="headerlink" title="挂留和弦"></a>挂留和弦</h1><p>在学习吉他的过程中，常常会看到诸如Gsus4和Gsus2之类的和弦。所谓sus，即suspend，中文常常翻译成挂留和弦。</p><p>挂留和弦常指用二度音或者纯四度音代替三度音(针对根音)所形成的和弦。比如，组成C和弦的音为CEG(135)，将E换成D(针对根音为二度)，组成CDG，就是挂二，将E换成F，针对根音为纯四度，就是挂四。</p><p>挂留和弦常用于间奏过渡(张远《嘉宾》)或渲染某些情感(《同桌的你》)。</p><h1 id="转位和弦"><a href="#转位和弦" class="headerlink" title="转位和弦"></a>转位和弦</h1><p>以根音为最低音，就是原位和弦，若将根音高一个八度，就是转位和弦。</p><p>比如，按照音高排列，CEG，就是C和弦，EGC，就是C&#x2F;E和弦，根音为C，但是最低音不是C了，而是E。</p><p>对于根音的解释，可以在细化一些，按照调式的八度关系排列，最低的就是根音，比如C大调，CDEFGAB，不论如何转位，C始终是最低的，所以C&#x2F;E和弦的根音仍然是C不是E。</p><h1 id="三和弦、七和弦等"><a href="#三和弦、七和弦等" class="headerlink" title="三和弦、七和弦等"></a>三和弦、七和弦等</h1><p>三和弦是三个音以三度关系叠置结合的和弦。</p><p>七和弦是四个音以三度关系叠加的和弦，因为四个音分别为根音、三度音、五度音、七度音。</p><p>大小七和弦，也叫做属七和弦，是指，先找一个大三和弦，然后结合一个针对根音构成小七度关系的音。大大七、小大七、小小七一个道理。</p><h1 id="五和弦"><a href="#五和弦" class="headerlink" title="五和弦"></a>五和弦</h1><p>也叫做强力和弦，通常是根音+纯五度音。一般金属和摇滚乐比较常用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【乐理】和弦进行和简单的指弹编配</title>
      <link href="/2024/01/09/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%BC%A6%E8%BF%9B%E8%A1%8C%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%BC%B9%E7%BC%96%E9%85%8D/"/>
      <url>/2024/01/09/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%BC%A6%E8%BF%9B%E8%A1%8C%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%BC%B9%E7%BC%96%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="和弦进行"><a href="#和弦进行" class="headerlink" title="和弦进行"></a>和弦进行</h1><p>所谓和弦，就是具有一定音程关系的几个音的组合。</p><h2 id="音程"><a href="#音程" class="headerlink" title="音程"></a>音程</h2><p>我们来看一下钢琴的琴键：</p><p><img src="/2024/01/09/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%BC%A6%E8%BF%9B%E8%A1%8C%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%BC%B9%E7%BC%96%E9%85%8D/piano.jpg"></p><p>这里CDEFGAB是1234567(Do,Re,…)的另一种记法，前者叫做<strong>音名</strong>，后者叫做<strong>唱名</strong>。CDEFGAB为七个<strong>基本音</strong>，两个音之间包含的基本音个数称作<strong>音级</strong>，用“度”来衡量，比如C-C之间只包含C一个基本音，故为1度。你会发现除了EF和BC之间，都有黑键。这表明CDEFGAB之间的距离是不相等的，需要一种更加精细衡量方式——<strong>音程</strong>。</p><p>音程可以大致理解为两个音之间的键的数量，相邻的键之间的距离是一个<strong>半音</strong>。于是，人们规定出了下表：</p><p><img src="/./interval.png"></p><p>C-E之间就是大三度关系，C-D是大二度关系，等等。</p><h2 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h2><p>和弦是纵向的音符组合——将三个或三个以上的音按照一定的关系叠加起来的产物。比如常见的吉他上的C和弦，就是CEG三个音，大三度关系。</p><p>我依稀记得，我的小学音乐老师给和弦的定义是：三个或者三个以上的音以<strong>三度关系</strong>叠加起来的组合。然而，现在也可以按照非三度关系叠加，也可以用两个音叠加，比如摇滚乐中常用的五和弦，就是C和G两个音叠加起来的。</p><p>和弦的命名通常为<strong>根音+和弦种类</strong>，比如Cmaj7等。根音一般是和弦的最低音(转位和弦不是)。</p><p>和弦也有级数：</p><blockquote><p>以1为根音构成的大三和弦为该大调的一级和弦，也就是135。</p><p>以2为根音构成的小三和弦为该大调的二级和弦，也就是246。</p><p>以3为根音构成的小三和弦是三级，也就是357</p><p>以4为根音构成的大三和弦是四级，也就是461</p><p>以5为根音构成的大三和弦是五级，也就是572</p><p>以6为根音构成的小三和弦是六级，也就是613</p><p>以7为根音构成的减三和弦是七级，也就是724</p><p>——<a href="https://zhuanlan.zhihu.com/p/237325127">必学：和弦级数</a></p></blockquote><p>这样，1234567级和弦分别为：</p><p>C调和弦：C Dm Em F G Am Bdim</p><p>G调和弦：G Am Bm C D Em Fdim</p><p>所谓4536251之类的万能和弦，也是上面几个和弦的组合。</p><h2 id="和弦进行-1"><a href="#和弦进行-1" class="headerlink" title="和弦进行"></a>和弦进行</h2><p>和弦进行是一组和弦的排列组合。</p><h2 id="自然大调小调"><a href="#自然大调小调" class="headerlink" title="自然大调小调"></a>自然大调小调</h2><p>自然大调的音程满足“全全半全全全半”，<strong>全音</strong>就是两个半音的意思。自然大调听起来像CDEFGAB。</p><p>自然大调的音程满足“全半全全半全全”。</p><h2 id="关系大调小调"><a href="#关系大调小调" class="headerlink" title="关系大调小调"></a>关系大调小调</h2><p>若一个大调和一个小调用的音都是相同的，但是起始(主音)不同，则互为关系调。</p><p>比如C大调：CDEFGAB和A小调：ABCDEFG就为关系调。一组关系调的主音会相差小三度。</p><h2 id="并行大调小调"><a href="#并行大调小调" class="headerlink" title="并行大调小调"></a>并行大调小调</h2><p>主音相同，用的音不一样，比如C大调和C小调。</p><h2 id="音乐动机和旋律"><a href="#音乐动机和旋律" class="headerlink" title="音乐动机和旋律"></a>音乐动机和旋律</h2><p>音乐动机就是一小段旋律，几个音符组成的片段。旋律是大范围的，是一长串音的序列。</p><p>比如肖斯塔科维奇常用的DSCH动机，在肖氏的第八弦乐四重奏第二乐章，就用了一连串DSCH动机来渲染紧张感。小动机组成大旋律。</p><p>先想好一点动机，再来编曲，是一种常用的方法。此外，也可以引用合适的一段旋律，同样是肖氏的第八弦乐四重奏，引用了肖氏的第十一交响曲和苏联歌曲《光荣牺牲》等。</p><h1 id="简单的指弹编排"><a href="#简单的指弹编排" class="headerlink" title="简单的指弹编排"></a>简单的指弹编排</h1><p>常有如下几步：</p><h2 id="写出主旋律"><a href="#写出主旋律" class="headerlink" title="写出主旋律"></a>写出主旋律</h2><p>对于弹唱曲，歌词要唱的音就是主旋律。比如：</p><p><img src="/2024/01/09/%E3%80%90%E4%B9%90%E7%90%86%E3%80%91%E5%92%8C%E5%BC%A6%E8%BF%9B%E8%A1%8C%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%BC%B9%E7%BC%96%E9%85%8D/qqqg.png"></p><p>歌词上面的一系列唱名就是主旋律。</p><h2 id="写出伴奏"><a href="#写出伴奏" class="headerlink" title="写出伴奏"></a>写出伴奏</h2><p>唱名上面的就是伴奏。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>将二者合并，然后检查，主旋律的音应该为最高音。</p><h2 id="指法的妥协"><a href="#指法的妥协" class="headerlink" title="指法的妥协"></a>指法的妥协</h2><p>如果指法变换比较困难，则可以考虑删除&#x2F;修改非主旋律的音，或换成高把位&#x2F;低把位的类似和弦。</p><h2 id="加花"><a href="#加花" class="headerlink" title="加花"></a>加花</h2><p>比如：</p><ol><li><p>使用琶音结束。</p></li><li><p>在某些地方加入扫弦&#x2F;弗拉门戈轮扫等技巧。</p></li><li><p>加入滑音、击勾弦技巧、pm、am等。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自新大陆</title>
      <link href="/2024/01/03/%E8%87%AA%E6%96%B0%E5%A4%A7%E9%99%86/"/>
      <url>/2024/01/03/%E8%87%AA%E6%96%B0%E5%A4%A7%E9%99%86/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>2024。</p><p>我一直生活在一种绝望的平静中。我的父母曾同我讲，我小时候很乖很听话，不像其他小孩一样玩耍——只是坐在花坛旁边。我总是在压抑着情感，久而久之，那些情感就化作利剑刺向我。我小时候很乖，但是我的父母偶尔也会打我——具体的缘由我都忘了，我只记得我明明并不难过，却掉下眼泪来。最近，我没经历什么开心的事情，也没什么让我难过的事情。这种平静快要吞没我了，我喜欢孤独、寒冷，它们在折磨我的同时，也逼迫我思考，逼迫我更认真地工作。</p><p>我怎么也开心不起来，我觉得自己可能是病了。</p><p>新年对我来说，无非就是这种平静的延续而已——轮回。时间和生命的不同之处在于——一年结束人们会庆祝，而生命结束人们会哀悼。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>2023年10月份，我进入了实验室工作，主攻知识图谱辅助的大模型推理。我的实验室比较大，硕博比较多，没有空闲的硬件资源，我的导师于是给我提供科研资金，让我租赁服务器跑训练，独立研究。我也从一个没什么经验的AI小白，变成了一个可以做一些简单工作的、不那么小白的小白。对于PyTorch和CUDA的理解更加深刻了。</p><p>租赁平台的算力比较抢手，我只有一张4090。尽管如此，只要做好优化工作，一切都好办，勉强能跑7B参数量的模型。先在7B参数量的模型上做出点成就，再和那些硕博抢硬件去:)</p><p>除去研究，我也读了五十多篇论文，大多都很水，都是一个套路，都没办法用于工业——全是设定特别的超参数跑出来的好结果。这些模型解决不了什么问题，只能提供好的思路。学长和导师的看法也类似。但是，不用这个方法，又怎么发论文呢？唉，AI这领域趋势就是这样，革命性的工作(深度学习)-&gt;灌水-&gt;革命性的工作(Transformer)-&gt;灌水-&gt;…</p><h1 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h1><p>2023年没怎么读书，一共就读了六本书。</p><p>上半年读了《定西孤儿院纪事》，这本书很压抑，我几乎是咬紧牙关读完的。为了生存，人类毫无下限。</p><p>下半年主要在读德勒兹相关的书——《差异与重复》《千高原》和《导读德勒兹&lt;差异与重复&gt;》。德勒兹的“结域-解域-再结域”是我目前最喜欢的理论——一个事物（具象或抽象的事物）首先有一个辖域、一个界限，接着它会打破这个辖域，形成新的辖域。这个理论其实是来自柏格森的——时间不断膨胀，时间不断流逝，人们所经历的一切就会充实时间本身，让时间有更多的意义。此外，未来的事物有无限的可能性。德勒兹也说，事物不可能再现——每次“再现”，重复出现的事情有不同的内涵。对于我的问题，德勒兹给了很好的答案，这就足够了。记得当时阅读哲学的契机就是自己实在是太痛苦太孤独了。我的使命就是去解域——感受和经历更多事物，仅此而已，其他问题，我不去想了。</p><p>此外也读了《无政府主义人类学碎片》、《烧纸》，印象不太深。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="法语"><a href="#法语" class="headerlink" title="法语"></a>法语</h2><p>2023年，我尝试用多邻国和Lingvist软件学习法语。现在只会说简单的句子，比如“这是我的房间”啦，“请来一杯红酒”啦。</p><p>学法语的契机主要还是为了读哲学书，翻译过来的术语读起来总是怪怪的、难以理解。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>2023年，我貌似没怎么系统学英语，读文章读到不会的词，就查一下，常用的词查多了也就记住了。</p><p>上YouTube看视频明显更多，Linux、AI相关的视频，油管的质量要高一些。尝试了三个月关掉字幕看视频，听不懂的地方反复听，听力有点进步。</p><p>以后还是希望去国外发展。</p><h2 id="乐理"><a href="#乐理" class="headerlink" title="乐理"></a>乐理</h2><p>大概10月份，受某个好友的影响，开始听古典音乐，最常听的还是肖斯塔科维奇的《列宁格勒》和德沃夏克的《自新大陆》。</p><p>逐渐对音乐感兴趣，复习了一遍之前学过的乐理知识。</p><p>尝试在LMMS编了曲，好难。</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p>Steam的Proton实在是非常厉害的工具，能够在Linux下畅玩Windows平台的游戏。</p><p>2023年末，阿里云和腾讯云促销，买了两台服务器，一台当游戏服务器，2核5G，带宽5M，每个月500G，租赁3年才500多，和朋友AA之后，花不了多少。于是和朋友畅玩饥荒联机版、求生之路2、泰拉瑞亚和我的世界。剩下一台服务器，2核2G，带宽3M，不限流量，一年99块，没想好干什么，可能会用frp做个穿透或者开个ddns？</p><p>目前在学着做求生之路2的地图，但是2002年的起源引擎有点难用，对Linux的支持也不好，只得开Windows虚拟机，很麻烦。</p><p>MC的一些模组也很有意思，比如沉浸工程、机械动力等等。依靠这些模组能够做出自动种植收割机、自动挖矿机等等。但是我和我的小伙伴们都不会用:(</p><p>此外，2023年我也发现了很多优秀的好游戏，Unpacking、整蛊白云、吸血鬼幸存者。寒假打算玩一玩这些游戏。此外，也想二刷我认为最优秀的游戏——Seabed。</p><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>在实验室工作写的代码和刷的算法题不算数。虽然这两个方面，代码写得最多。</p><p>2023年单纯出于兴趣……用C++写了模拟Enigma机的程序和基于OpenGL的谢尔宾斯基三角形生成器，此外学了学Rust、OCaml，用这两种语言刷了刷算法题。也尝试过学前端开发，但是React之类的工具还是不会用，前端开发的逻辑还是搞不明白！目前看来，自己用得比较熟练的语言只有C、C++和Python。前两种语言是大一学的，Python则是以后用来吃饭的家伙。也尝试使用Codeium工具帮我写代码，AI生成的代码质量参差不齐，生成Python代码的质量明显好于生成C++的质量。没办法，人家爹就是Python。</p><p>此外也学了LaTeX，因为Linux对Office的支持不是很好，用LaTeX明显要方便一些——安个TexStudio，打字就行，还是跨平台的。</p><p>也学了学Linux的一些进阶知识——awk、sed之类的工具，systemd的原理等等。十二月份把笔记本删库了，原因是一个环境变量是空，结果直接把根目录删掉了。于是重新安装了一波Arch Linux。</p><p>珍惜生命，远离<code>-f</code>。</p><h1 id="上课"><a href="#上课" class="headerlink" title="上课"></a>上课</h1><p>上课没意思，真没意思。期末看看PPT就行了。</p><p>早八真不乐意去，不如睡饱饱地快乐上早十。</p><p>2024继续践行早八投降主义。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>2023年酒喝得有些多，胖了十来斤。开春跑步减减肥。说到跑步，2023年爱上了慢跑，跑完之后压腿，会带来非常明显的满足感。</p><p>2023年，我明显偏爱素食，对肉类的需求不如以前大了，究其原因——食堂做素菜更好吃，做肉菜一般。虽然但是，哈工大的食堂还是不错滴。年末哈工大的暖廊突然火了，有些莫名其妙，可能是招生办又在造势吧。</p><p>2023年没怎么生病，大概是经常运动的原因吧。虽说没怎么生病，但是心情大多时候都是比较低落的，无聊、虚无。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】pytorch一些错误的解决办法</title>
      <link href="/2024/01/03/%E3%80%90AI%E3%80%91pytorch%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2024/01/03/%E3%80%90AI%E3%80%91pytorch%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文讨论一些难以调试的错误。</p></blockquote><h2 id="Assertion-srcIndex-lt-srcSelectDimSize-failed"><a href="#Assertion-srcIndex-lt-srcSelectDimSize-failed" class="headerlink" title="Assertion srcIndex &lt; srcSelectDimSize failed."></a>Assertion <code>srcIndex &lt; srcSelectDimSize</code> failed.</h2><p>这个错误表明CUDA上的张量出现了索引越界问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>阅读代码，找出可能出现的索引越界代码段。</p></li><li><p>如果第一步比较困难，您要知道，在CUDA上调试程序比较困难，所以可以考虑在CPU上运行代码，能获得更加具体的报错信息。</p></li><li><p>另外，对于使用huggingface相关库的代码，查看加载数据集是否正确，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = load_dataset(<span class="string">&quot;json&quot;</span>)</span><br></pre></td></tr></table></figure><p>就可能引发错误，因为这样写会导入默认的数据集，考虑改写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = load_dataset(<span class="string">&quot;json&quot;</span>, data_files=data_path)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Error-while-deserializing-header-InvalidHeaderDeserialization"><a href="#Error-while-deserializing-header-InvalidHeaderDeserialization" class="headerlink" title="Error while deserializing header: InvalidHeaderDeserialization"></a>Error while deserializing header: InvalidHeaderDeserialization</h2><p>这个错误表明导入的预训练模型有问题。我遇到这个问题的情况是，同时使用了<code>transformers.Trainer</code>和<code>torch.compile()</code>。将预训练模型输出，发现<code>state_dict</code>为空。此外，貌似PyTorch和PEFT的兼容性问题也是导致这个问题的一个原因。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>重新训练预训练模型。</li><li>若您和我的情况一样，请移除<code>torch.compile()</code>方法。详见<a href="https://github.com/huggingface/transformers/issues/27397">SafetensorError: Error while deserializing header: InvalidHeaderDeserialization when open .safetensor model</a>。</li><li>如果是在微调LLM时遇到这个问题，请将<code>torch.float16</code>数据类型改为<code>torch.float32</code>。</li></ol><h2 id="RuntimeError-CUDA-error-out-of-memory"><a href="#RuntimeError-CUDA-error-out-of-memory" class="headerlink" title="RuntimeError: CUDA error: out of memory"></a>RuntimeError: CUDA error: out of memory</h2><p>两种可能：</p><ol><li>显卡总算力不足。</li><li>没有用全部的显卡训练。</li></ol><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>第一种情况，优化模型或者换更强力&#x2F;数量更多的显卡。第二种情况，利用多卡并行运算策略，考虑使用：</p><ol><li><p>Pytorch下的<code>nn.DataParallel(model)</code>。</p></li><li><p>transformers的<code>device_map=&quot;auto&quot;</code>策略，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> PeftModel</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> GenerationConfig, LlamaForCausalLM, LlamaTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    device_map = <span class="string">&quot;auto&quot;</span></span><br><span class="line">   model = LlamaForCausalLM.from_pretrained(</span><br><span class="line">        base_path,</span><br><span class="line">        torch_dtype=torch.float32,</span><br><span class="line">        device_map=device_map,</span><br><span class="line">    )</span><br><span class="line">    model = PeftModel.from_pretrained(</span><br><span class="line">        model,</span><br><span class="line">        lora_weights,</span><br><span class="line">        device_map=device_map,</span><br><span class="line">        torch_dtype=torch.float32,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Milk inside a bag</title>
      <link href="/2023/12/16/Milk-inside-a-bag/"/>
      <url>/2023/12/16/Milk-inside-a-bag/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Even though I won’t die, my body is filled with dread.<br>How mysterious.<br>No matter what I do, it seems potentially scary. It’s this record inserted into my genes, isn’t it?<br>Even though I was useless before.<br>The limitation of this parasitic plant.</p></blockquote><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我有好多话想要说，但是坐到电脑前，我的那些想法又消散了，如同它们未曾存在过一样。</p><p>寒冷、孤独。我只能想到这两个词来描述我现在的境况——我和他人交流得越多，我便越孤独；我不同他人交流，依旧越来越孤独。我一无所有，我也终将一无所有——这让我感觉寒冷，由内而外的寒冷。</p><h2 id="控制论"><a href="#控制论" class="headerlink" title="控制论"></a>控制论</h2><p>我抗拒对现状的思考，因为我觉得这什么意义也没有。任何设施、步骤、我经历的事情都不过是一些机器——接收输入，吐出输出，这些机器被精细调校过。这些机器的输出，完全符合大多数人的预期。一个机器套着一个机器，包含、并列。除此之外，什么也不剩。</p><p>捕获装置！新的来，老的去，周而复始。</p><p>机器永远存在，机器永远不朽。</p><p>所以人们的目标从<strong>实现自己</strong>变成了<strong>适应机器</strong>。</p><p>……</p><p>人也是机器，不是么？有机器，就有漏洞；有漏洞，就有黑入的方法。如果万物都可以视作机器，那么一切都有黑入、利用的方法。</p><p>C’est la vie.</p><h2 id="Wired-World"><a href="#Wired-World" class="headerlink" title="Wired World"></a>Wired World</h2><p>我一直觉得那些古早的网页有一种神奇的吸引力——刺眼的gif图像、现在看来粗劣的CSS样式表……</p><p>我喜欢在那些早已空无一人的在线3D聊天室里闲逛，我惊异于古早时期的程序员们的能力。</p><p>那时候的网页有一种奇怪的厚重感和梦幻感。</p><p>人们彼此相连。</p><h2 id="埃里希·弗罗姆"><a href="#埃里希·弗罗姆" class="headerlink" title="埃里希·弗罗姆"></a>埃里希·弗罗姆</h2><p>我如今已到达毁灭的边缘——愚者。</p><p>人的超越性只有两种方法来实现——创造和毁灭。当创造的欲望得不到满足时，人就要去毁灭。创造和毁灭的结果是不同的，前者产生幸福，而后者只会产生痛苦。</p><p>我循其原因——我什么也不相信，权威我也不信，逻辑我也不信，我在怀疑论的深坑里待太久了。逐渐，我连自己也不相信了。我丧失了创造的欲望，因为它除了带给我一段时间的满足感之外，什么也做不了。创造没办法生成创造的欲望。我没有信仰。而毁灭似乎是写在DNA底部的一串代码，不论如何，毁灭都可以生成毁灭的欲望，这个生成过程中，人会产生快感。其实这一切不过是对于当前体系、当前系统的逃逸罢了。</p><p>创造没法让你逃出这个体系，创造的一切东西都会被现有的体系同化，强迫你赋予它们一些意义。而毁灭毫无意义可言，那只是单纯的“爽”，单纯的快乐。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>明暗辩证法</title>
      <link href="/2023/11/30/Ode-To-Darkness/"/>
      <url>/2023/11/30/Ode-To-Darkness/</url>
      
        <content type="html"><![CDATA[<blockquote><p>黑暗会告诉你一切，向黑暗与寒冷寻求答案。它们是你永远的朋友，至于光明和温暖，不过是瞬间的假象罢了。</p></blockquote><p>我不该饮用如此烈的酒。它灼烧着我的胃、我的食道，让我浑身出汗。我的眼睛有些模糊，头有些晕，大脑的运转逐渐迟缓。</p><p>是的，黑暗。我知道很少有人喜欢黑暗——光明让人觉得安心、温暖，而黑暗会让人恐惧，这是写在人类遗传信息里的代码，从远古一路流传至今日。然而，今日已和往昔不同，有的时候，黑暗要比光明安全得多。</p><p>黑暗是一，是缺失。寒冷也是。光明是光子的存在所带来的产物，而黑暗，则是缺失的产物。同样，温暖是能量的产物，而寒冷，则是缺失的产物。光明和温暖有千千万万种——霓虹灯的光明、白炽灯的光明；火焰带来的温暖、电热毯带来的温暖等等。而黑暗和寒冷则是单一的。温暖和光明，是多样化的哲学；而黑暗和寒冷，则是“一”的哲学——这里什么都没有，只有“缺失”。缺失是恒常的。任何事物都将归于黑暗与寒冷中去。</p><p>关于黑暗和光明，要说一下：黑暗和光明本质上其实没什么不同，只是黑暗会将事物拉进同质化的深渊中，而光明，则会将事物拉进异质化的深渊里。黑暗中的事物大多没什么不同，而光明中的事物各有各的色彩。</p><hr><p>这是一个实验性的作品，他们说。然而他们自己也不明白这是什么意思。</p><p>“实验性？”玻璃问道。“实验性就是胡乱扯些什么，对吧？”</p><p>“不一定吧，实验性是作者知道自己想要表达一些东西，但是通过罕见的手段来达到这个目的。”太阳回答道。太阳是一个温暖而明亮的实体。“比如音乐，使用噪音来表达内心的慌乱，而不使用压抑的和弦。”太阳喜欢音乐，音乐从它出生起就在宇宙中回荡着。</p><p>阳光从玻璃体内穿过。玻璃觉得太阳说得有道理，又没有道理，它没办法反驳。玻璃不明白音乐是什么意思，玻璃只感受得到光——反射、折射、穿透它的身体。“就像绘画吗？抽象派艺术？”</p><p>太阳觉得玻璃说得有道理。“是的。”</p><p>玻璃看着房间里的画，它看不懂，它看见一团扭曲的肢体。玻璃觉得那幅画很好看，又很恶心。玻璃觉得这种表现手法很罕见，它平时看到的人不是这样子的——他们五官端正。</p><p>太阳伸了个懒腰，太阳不想谈论什么抽象派艺术——实验性艺术。它只想睡觉。</p><p>于是，月亮升上天空。</p><p>“太阳哪里去了？”玻璃问道。</p><p>“太阳睡觉去了。”月亮回答道，它看了看太阳，后者一动不动。</p><p>“睡觉是什么意思？”玻璃问着。</p><p>月亮没有回答，它觉得玻璃太吵了，撕碎了黑夜静谧的氛围。</p><p>玻璃在思考。月亮落下升起太阳，太阳落下升起月亮。</p><p>玻璃在墙上写下自己的答案，“睡觉就是太阳落下”。玻璃看着房间里的画，它觉得好好看哦，它觉得那一团扭曲的东西像极了自己求取的答案，它觉得自己是一个实验艺术家。</p><hr><p>我昨天晚上大致睡了四五个小时，我想这大概是茶叶里咖啡因的原因——我以前喝茶也没有那样辗转反侧过。我原以为早晨起来会很困倦，结果却清醒得不行……我在教室里听着无聊的课，脑子里却是黑暗与光明的问题。</p><p>昨天梦里，我梦见我站在镜子面前：镜子里的我是一个硬汉形象——浑身肌肉，眼露凶光；然而，在我的旁边，却站着一个穿着裙子的男性——浓妆艳抹，向镜子中的自己抛着媚眼。然而，我认为我和旁边的这个人没什么不同。</p><p>我在梦里看着拉康的性化公式投射在天空中——左半部分，象征男性的那部分。这个公式的意义很清楚——男性始终以“理想男性”（大他者）为榜样完成自身，这个“理想男性”象征着世俗意义上的男性角色——有男人味，强壮且有责任感，而对于女性，则没有这样一个榜样，却又有一条指向男性的箭头，这表示——没有一个女性不受大他者的影响，然而却又没有一个大他者来定义女性应该是什么。实际上，父权是同时压迫两方的。一个是黑暗的压迫——同质化；一个是光明的压迫——异质化。</p><p>我觉得那个穿着裙子的男性并没有打破束缚——他努力去背离大他者，尝试做它的反面。梦里的我也没有打破束缚——那个我努力去迎合大他者，尝试去实现这个没法实现的大他者。</p><p>我醒来之后细细思考，发现那个穿着裙子的男人，要比我更明白大他者究竟是什么。</p><hr><p>玻璃觉得自己太脆弱了，远没有太阳和月亮来得光彩动人。它一生一世活在别人的光芒之下。玻璃明白自己是毫无意义的。于是它问太阳。</p><p>“为什么我是毫无意义的呢？”</p><p>这个故事太俗套了，就是个寓言故事，我想你会知道后面会发生什么：太阳告诉玻璃，玻璃的折射为光增加了新的可能性，所以它是有意义的。</p><p>Actually, no! 我懒得这么写了。太阳觉得玻璃太聒噪了，没有回答它。</p><p>玻璃看着屋子里那张扭曲的画，怔怔出神。玻璃觉得那种扭曲越来越美好了。它觉得太阳和月亮没什么了不起的，自己也没什么了不起，那幅画也是。一切都是扭曲的幻觉罢了。它觉得任何东西都是一样的，扭曲。</p><p>在一个伸手不见五指的晚上，下着大雨。玻璃此刻觉得一切都是那么和谐，黑暗里一切都是相同的。</p><p>随着一声巨响，玻璃被打碎了，或许是恶作剧小孩做的，它不知道。它感觉自己的身体碎裂开来，却又没有什么疼痛感。它此刻觉得自己就是那幅画——扭曲。</p><hr><p>老实说，我也不知道玻璃、太阳和月亮都是什么，我只是遵从着自己意识，写下这些文字而已。现在我觉得有些困倦了，我突然觉得白天是这么漫长。</p><p>哈尔滨如今被雪覆盖着，我喜欢洁白的雪、室外冰冷的空气。我喜欢寒冷，讨厌炎热——冷天可以多穿一些，然而炎热的天气里，哪怕脱到全身赤裸也会热得不行，家家户户都得开空调——没什么其他好办法了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hope Left Me</title>
      <link href="/2023/11/09/Hope-Left-Me/"/>
      <url>/2023/11/09/Hope-Left-Me/</url>
      
        <content type="html"><![CDATA[<h2 id="冬天"><a href="#冬天" class="headerlink" title="冬天"></a>冬天</h2><p>天空是橙红色的，大雪落下。雪反射着光，吸收着声波。四周明亮又安静。雪花直往我的衣服里钻，冰冰凉凉，寒风吹在我的脸上。</p><p>我抓起一把松散的雪花，用力一捏，这堆雪花变成了一个略微坚硬的冰球，我用手修整着这个冰球，直到它足够圆、足够坚硬。两脚叉开，大臂带动小臂，内旋。</p><p>“梆！”</p><p>小冰球砸在塑料展板上，发出一声闷响。</p><p>我的手被冰得生疼。</p><p>我又抓起一把雪，按照之前的手法操作——两脚叉开，大臂带动小臂，内旋。</p><p>……</p><p>小冰球从展板上沿擦过，坠入雪地。一阵大风吹过，地面上扬起一阵雪白的浪。留下我呆滞伫立在原地，雪水顺着我被冻红的手指滴落，结成冰。</p><p>体育场除了我，再无其他人了。我在这里一个人感受冷风，感受冰冷而洁白的雪，感受投掷雪球的快感。</p><h2 id="寒冷"><a href="#寒冷" class="headerlink" title="寒冷"></a>寒冷</h2><p>深吸一口冰冷而干净的空气，我迟钝的大脑开始轰隆运转。呼出的白气消散在寒冷的夜里。</p><p>我喜欢一切冰冷而干净的事物，那让我安心——雪、冰块、<del>白骨</del>和凌晨的梦。我觉得我压抑着的热烈的情感，快要将我炙烤至死，唯有那些寒冷的事物——能中和那些烦躁与痛苦。</p><p>我太严肃了，太拘谨了——如同我一直以来所处的环境——压抑、沉闷、毫无生机。我的脑子里是一团乱麻，一些说不清道不明的句子和想法。实际上，我不知道自己想要什么，也不知道自己是怎么想的。我没有信仰、没有目标……这样也行、那样也行……无所谓……随便……怎样都好……</p><p>当我站在楼梯顶，我经常会有纵身一跃的冲动；当我拿着螺丝刀，会想要捅死自己；当我拿着壁纸刀开快递，我会幻想划破皮肤的感觉……“死亡驱力”。</p><p>寒冷，塔纳托斯。</p><h2 id="生命"><a href="#生命" class="headerlink" title="生命"></a>生命</h2><p>能够感受雪的寒冷，我就足够快乐了。生命不就是这样吗？“再现”是永不可能出现的，哪怕每一天都经历同样的事情，也终究会有新的感受出现。</p><p>我无拘无束，体验各种事情就是我最大的乐趣。我是生活的艺术家——艺术是对感觉的创造——这样就好。</p><p>就这样吧。我不愿再去纠结那些意义不意义的事情了。</p><p>我生存着，我呼吸着冰冷的空气，我看着从橙红色天空掉下来的、六角形的白色雪花，我躺在雪地里，任凭冰冷渗入我的衣服。我对生命没有什么想法，一丁点也没有。我的肉体是个终端，接收大自然的输入，输出不同的感受给我的灵魂。我是一台虚拟机里的一个进程——或者是个线程，我不好说。</p><p>希望本身就是希望，它不在我手中，也从未离开过我。</p><p>……</p><p>我感受到一股不连续的虚无感正在袭击我，当我将这种感觉投射到荧屏上时，它又悄然消失了。那是一种令人上瘾却又令人害怕的感觉，它令我不断地问自己，“我究竟为何而活？什么是存在？什么是意义？”，我知道语言没办法帮我解决这个问题。是的，那种感觉消失得无影无踪，只有我独自站在雪里，怔怔出神。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&#39;est la vie, la belle vie.</title>
      <link href="/2023/10/21/C-est-la-vie/"/>
      <url>/2023/10/21/C-est-la-vie/</url>
      
        <content type="html"><![CDATA[<p>我处于极乐之中，我很快乐。这一切什么时候才是个头啊？</p><hr><p>五点半下课，我背好书包，从七楼往下走。走廊里的灯很昏暗，不足以照亮我脚下的台阶。我很困，老师无聊的语句带走了我的精气神，现在的我，只是一具躯壳。但是，我不能睡。</p><p>到达二楼，灯明亮许多，我顺着暖廊走到食堂，这里人头攒动。我走到熟悉的摊位前，排着队——我是第六个。我每天、每顿都吃这家的饭，这里的蔬菜给得最多，肉做得最好，营养很全面，给饭也很快——我不希望我的肠胃对大脑抗议。然而，晚上卖的似乎是中午没有吃完的菜，蔬菜早已被氧化得发黄，也不脆，溜肉段颜色也变得不好看——由金黄变成深棕色。我点了常吃的几道菜，汤汁在盘子里混合，棕色的酱油上面有一层厚厚的油脂。</p><p>“这里没有人坐吧？”</p><p>“没有。”</p><p>“谢谢，同学。”</p><p>我随便找一个位置坐下。让那又油又咸的饭菜，通过我的食道，滑入胃中。</p><p>我看坐在我旁边一桌的三个人，快乐的交谈着，谈论着游戏，谈论着考试，谈论着金钱。</p><p>有小孩在大嚷，请求父母给他买玩具，他们用筷子敲击着凳子，啪啪作响。他们的家长在一旁笑着，丝毫不以为耻，反而夸奖自己孩子的音乐天分。不少人对那对父母投去不满的眼神，他们却好像没看见一样。</p><hr><p>我太忙了。计算机网络、操作系统、数据库、机器学习、网络设计——五门课周周有实验，周周要交报告；实验室那边，两周交一次工作报告，最近还要写一个实验方案。</p><p>课内的东西要弄好——我不希望我的保研资格被取消，这玩意要是没了，我或许真就要<del>服毒自尽</del>了。实验室那边的东西也得弄好——那是我真正热爱的事情，我喜欢当前研究的方向，累一点倒也无所谓。况且，我还打算通过学术出国呢。</p><p>课内的东西真的没意思。计算机网络采取“翻转课堂”的方式——老师不讲课，学生下课去MOOC网站自学，上课的时候作汇报——我真没学会什么东西，反倒是网络设计这门选修课给我搭建起了一个关于网络的框架。操作系统和数据库讲得蛮好，尤其是数据库，这门课的老师颇有些Geek风范，用LaTeX写PPT，技术也很厉害。</p><p>机器学习这门课，老师上课讲着讲着就会打哈欠，没意思——实验要求写一个SVM和Logistic二分类，不允许调库。手搓线性规划？服了。</p><p>我是个没什么生活、没什么娱乐的人，仅有的乐趣就是喝喝酒，跑跑步，偶尔打打游戏、自己出校转一转而已。除了学习&#x2F;工作，我也没什么其他的事情可以干。我承认，我是个很无趣、孤独、淡漠、有点自恃清高的人，但这也没什么不好的。</p><p>我时常觉得自己是个疯子——虽然我觉得，很多人病得更重一点——在清ddl-获得ddl这个循环中，竟觅出了一点乐趣来。一天天不挪地方，好像显示屏就是我的伴侣似的——倒也是，和人打交道太累了。</p><p>我能轻而易举地觉察到别人是怎么想的，我能体会到他们隐藏起来的情绪，我静静看着他们拙劣表演。和机器打交道就很舒服，输出和预期不符，那只因为我是个蠢货，连代码都写不好的蠢货。机器不会隐藏任何东西。</p><hr><p>我很难说，我现在是什么感觉。我感觉自己好像每天都在经历这些事。我既麻木，又敏感。不知不觉中，我已经成为那些无趣的人了。不，我很聪明，我还在思考。我……</p><p>我的文字像是深海的气泡，逐渐上浮。</p><hr><p>我需要咖啡因。它是我的命。它让我高效地完成任务，从而腾出来时间——去<del>忧郁，难以排解的忧郁</del>做一些令我快乐的事。咖啡因，我的天哪，我可太爱它了。多么神奇的物质，让你忘记疲惫，尽管去工作。这东西多么符合主流的文化呀！</p><p>可我没办法反驳这些东西，我臣服于主流，我依靠咖啡因去工作。</p><p>我，在我的键盘上敲出那些废话——我知道那些老师不会看的。那些废话像是血液，在我们每个人的身体里流淌着。我他妈可太喜欢写废话了，不需要动脑子，尽管敲就是了。</p><p>科研和上课又不一样……我努力去写，写得东西还是好烂。一步一步来吧，开肝。我要在咖啡因被代谢完毕之前，把它改出来。</p><p>上课、做课设、写报告、读论文、写方案。我很充实，我很喜欢这样的生活。</p><hr><p>我要酒精——我喜欢那种飘飘然的感觉，它让我感觉，我是世界之王。</p><p>胃里暖乎乎的，脚底轻飘飘的……放个肖斯塔科维奇第八交响曲的第三乐章……太爽啦！我怎么在天上飞呀！</p><p>我背靠着死亡和虚无，面对着光怪陆离的世界。我做过这样的梦，在梦里我不敢回头看，却在放声大笑。</p><p>趁着眩晕去床上躺着，我感觉我好快乐，浑身的肌肉都放松下来了。</p><p>晚安。</p><p>不要思考。</p><hr><p>我打一开始，就知道这故事的结局是怎么样了。真没意思，睡觉了。</p><p>我早就把自己拆得七零八落了。</p><p>这就是生活，美好的生活。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】计算机网络相关知识</title>
      <link href="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>三要素：语法(数据格式)、语义(控制信息)、时序(事件顺序)</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>频分多路复用(FDM): 各用户占据不同频率的带宽发送数据。</p><p>时分多路复用(TDM): 将时间分片，周期性为不同用户发送数据。</p><p>波分多路复用(WDM): 光的FDM。</p><p>码分多路复用(CDM): 特点如下：应用于<strong>无线网络</strong>，各用户使用相同频率带宽，利用各自码片序列编码数据。各用户编码相互正交。</p><p>CDM的步骤为：</p><ol><li>每个设备先被分配一个码片序列。</li><li>实际传输的数据中，0用-1表示，1用+1表示，将之与码片序列相乘，得到该用户的编码值。多个用户的编码值相加，传输数据。</li><li>解码时，码片序列与实际接收到的数据做内积，即可获得码片序列对应用户的信息。</li></ol><h2 id="数据交换方式与计算"><a href="#数据交换方式与计算" class="headerlink" title="数据交换方式与计算"></a>数据交换方式与计算</h2><p>电路交换：独占资源，按照“呼叫建立-通信-拆除呼叫”步骤运作。</p><p>报文交换：一次发送信息整体。采用“存储转发”方式。</p><p>分组交换：将信息拆分，分组多次发送。采用“存储转发”方式。</p><p>假设AB主机之间有唯一一条通讯链路，带宽为$R$bps，报文为$M$bits，分组大小为$L$bits，链路上有$n$个路由器(需要走$n+1$段小链路，即$n+1$跳)，则：</p><ul><li><p>报文交换耗时为$T&#x3D;\frac{(n+1)M}{R}$。</p></li><li><p>分组交换耗时为$T&#x3D;\frac{M}{R}+n\frac{L}{R}$。</p></li></ul><h2 id="几个重要参数"><a href="#几个重要参数" class="headerlink" title="几个重要参数"></a>几个重要参数</h2><ul><li>速率(数据率、数据传输速率、比特率)：常指额定速率、标称速率。</li><li>带宽：链路的最高速率。</li><li>节点处理延迟：路由器存储-转发数据包所消耗的时间。</li><li>排队延迟：由于数据包过多，路由器没法一次性将所有数据包传输出去。等待传输链路可用的时间称作排队延迟。</li><li>传输延迟与传播延迟：传输延迟为数据包长度除以链路带宽；传播延迟为链路长度除以信号传播速度。</li><li>流量强度：设链路带宽为$R$，分组长度为$L$，平均分组到达速率为$a$，则流量强度为$\frac{La}{R}$。</li><li>时延带宽积：传播延迟和带宽之积。</li><li>丢包率：丢失的数据包个数占已发送的数据包个数的比例。</li><li>吞吐量：整条链路能够达到的最大带宽，对于一条多段链路来说，其吞吐量为其各段链路带宽的最小值，这段链路也被称为瓶颈链路。</li></ul><h2 id="OSI与TCP参考模型"><a href="#OSI与TCP参考模型" class="headerlink" title="OSI与TCP参考模型"></a>OSI与TCP参考模型</h2><p>OSI参考模型有七层：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><p>前四层为端到端层，即他们不考虑底层的逻辑，建立主机-目标机之间的传输抽象。</p><p>TCP参考模型中，删去了表示层和会话层。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层通过<strong>socket</strong>发送&#x2F;接收消息，每个进程通过“IP+端口号”方式标识。</p><h2 id="HTTP协议的计算"><a href="#HTTP协议的计算" class="headerlink" title="HTTP协议的计算"></a>HTTP协议的计算</h2><p>HTTP1.0使用非持久性连接，每个TCP连接最多允许传输一个对象。</p><p>HTTP1.1使用持久性连接，每个TCP连接允许传输多个对象。</p><p>非持久性连接：传输N个对象，则该协议需要$2+2N$个RTT，TCP连接的建立和HTTP的请求需要2个RTT，每个对象各自需要一个请求文件RTT和发送文件RTT。</p><p>非流水线的持久性连接：传输N个对象，则该协议需要$2+N$个RTT，TCP连接的建立和HTTP的请求需要2个RTT，每个对象只需要一个发送文件RTT。</p><p>流水线的持久性连接：传输N个对象，则该协议需要$3$个RTT，TCP连接的建立和HTTP的请求需要2个RTT，每个对象并行发送，只需要一个RTT。</p><h2 id="HTTP协议的消息格式"><a href="#HTTP协议的消息格式" class="headerlink" title="HTTP协议的消息格式"></a>HTTP协议的消息格式</h2><p>请求消息包括四部分：请求行、请求头部、空行和请求数据。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP.png"></p><p>响应消息包括四部分：状态行、消息报头、空行和响应正文。</p><h2 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h2><p>HTTP是无状态的，有时为了保存一些状态(登录状态等)，需要用到Cookie，其包括四个部分：</p><ul><li>HTTP响应消息的Cookie头部行。</li><li>HTTP请求消息的Cookie头部行。</li><li>保存在客户端的Cookie文件。</li><li>Web服务器端的后端数据库。</li></ul><h2 id="E-mail应用"><a href="#E-mail应用" class="headerlink" title="E-mail应用"></a>E-mail应用</h2><p>邮件服务器之间传递消息使用<strong>SMTP协议</strong>，按照“握手-传输-关闭”的方式工作，其消息包含：头部、空行、消息体三部分。通过MIME(多媒体扩展)，可以令E-mail消息支持不同的文件格式。</p><p>从服务器获取邮件可以用如下三个协议：<strong>POP协议</strong>、<strong>HTTP协议</strong>、<strong>IMAP协议</strong>。</p><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>DNS服务采用<strong>分布式层次服务器</strong>架构，使用<font color="red">UDP</font>协议。解析服务器分为：</p><ul><li>顶级域名服务器：负责解析<code>.com</code>、<code>.org</code>等顶级域名和国家顶级域名。</li><li>权威域名服务器：负责组织内部服务器的解析。</li><li>本地域名服务器：每个ISP都有一个本地域名服务器，当主机发起解析请求时，首先在本地域名服务器中查询。</li></ul><p>DNS记录常为资源记录(RR)，其为一个四元组（name, value, type, ttl），对于type：</p><ul><li>若为A，则表示value是name的主机域名。</li><li>为NS，则value表示name域权威域名服务器的主机域名。</li><li>为CNAME，则表示value为name的真实域名。</li><li>为MX，则表示value是name的对应邮件服务器。</li></ul><h2 id="文件分发速度的计算"><a href="#文件分发速度的计算" class="headerlink" title="文件分发速度的计算"></a>文件分发速度的计算</h2><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP2.png"></p><p>C&#x2F;S架构：$max(\frac{NF}{u_s},\frac{F}{min(d_i)})$</p><p>P2P架构：$max(\frac{F}{u_s},\frac{F}{min(d_i)}，\frac{NF}{u_s+\sum u_i})$</p><p>对于C&#x2F;S架构来说，这里进行了一个非常粗糙的建模，相当于一个大水管和很多小水管相连。</p><p>对于P2P架构来说，建模同样粗糙，认为上传下载是同时发生的。此时服务器必须上传一份文件副本就好，之后交给P2P网络传来传去，客户机下载需要下载N份，而默认上传速率就是$u_s+\sum u_i$。</p><h2 id="P2P索引"><a href="#P2P索引" class="headerlink" title="P2P索引"></a>P2P索引</h2><p>P2P需要和其他主机建立连接，就必须有一个服务器(tracker)记录其他服务器的信息。</p><p>如果服务器是中心化的，就是<strong>集中式索引</strong>，每个主机和该中心化的服务器建立连接。</p><p>如果服务器是完全分布式的，每个主机都存储一些信息，就是<strong>洪泛式索引</strong>。</p><p>也可以设立一些局部中心化的节点，这些局部中心化的节点之间洪泛式查询，而主机和这些节点采用中心化的查询方式，这就是<strong>层次式覆盖网络</strong>。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层负责两个主机进程间的通讯。</p><h2 id="复用和解复用"><a href="#复用和解复用" class="headerlink" title="复用和解复用"></a>复用和解复用</h2><p>复用：从多个socket获取数据，封装给网络层。</p><p>分用：收到数据包时，拆分数据包，发送给对应的socket。对于UDP协议，以二元组标识（目的IP，目的端口号）；对于TCP协议，以四元组标识（源IP，源端口号，目的IP，目的端口号）</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>“能到就到，到不了拉倒”。值得一提的是其校验和机制，将段的内容视作16位整数，相加，进位置于和的后面，按位求反即得校验值。</p><h2 id="可靠性传输原理-RDT"><a href="#可靠性传输原理-RDT" class="headerlink" title="可靠性传输原理(RDT)"></a>可靠性传输原理(RDT)</h2><p>RDT模型是抽象的建模。</p><p>RDT1.0：可靠信道上的可靠传输。压根不会发生错误。</p><p>RDT2.0：产生位翻转的传输。应用确认机制，接收方接收到消息时，先验证，然后显式发送ACK告知成功接收，否则发送NAK。</p><p>RDT2.1：重复分组的处理。添加分组序号。</p><p>RDT2.2：ACK&#x2F;NAK消息失真。舍弃NAK机制，成功就发送NAK，否则不发送消息。</p><p>RDT3.0：引入定时器机制和停等机制。</p><h2 id="GBN协议-后退N帧协议"><a href="#GBN协议-后退N帧协议" class="headerlink" title="GBN协议(后退N帧协议)"></a>GBN协议(后退N帧协议)</h2><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP3.png"></p><p>发送方和接收方各设定一个滑窗。当接收方受到消息后，会向发送方发送一个ACK(n)信号，表示n和n之前的所有数据包被正确成功接收，乱序到达的分组被丢弃，当数据包超时，则发送序列号大于等于n的所有数据包。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP4.png"></p><h2 id="SR协议-选择性重复协议"><a href="#SR协议-选择性重复协议" class="headerlink" title="SR协议(选择性重复协议)"></a>SR协议(选择性重复协议)</h2><p>GBN重传的数据包太多，SR协议优化了一些。</p><p>SR协议只重传那些没有受到ACK的分组。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/HTTP5.png"></p><p>但是，要满足$N_s+N_r\leq 2^k$，其中$N_s,N_r$为发送方、接收方窗口大小，$2^k$为序列号的最大值。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>其为一个点对点的、全双工的、面向连接的可靠传输协议。</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/TCP.png"></p><p>其中，ACK(n)表示到n-1包都完全接收了，序列号为segment中第一个字节的编号。</p><h2 id="TCP超时时间的确定"><a href="#TCP超时时间的确定" class="headerlink" title="TCP超时时间的确定"></a>TCP超时时间的确定</h2><p>$$<br>TimeoutInterval &#x3D; EstimatedRTT + 4DevRTT<br>$$</p><p>$$<br>EstimatedRTT&#x3D;(1-\alpha)EstimatedRTT+\alpha\times SampleRTT<br>$$</p><p>$$<br>DevRTT&#x3D;(1-\beta)DevRTT+\beta\times |SampleRTT-EstimatedRTT|<br>$$</p><h2 id="TCP快速重传机制"><a href="#TCP快速重传机制" class="headerlink" title="TCP快速重传机制"></a>TCP快速重传机制</h2><p>如果发送方3次收到了同一数据的ACK，就断定这之后的数据全丢失了，于是重传后面的包。</p><h2 id="TCP流量控制机制"><a href="#TCP流量控制机制" class="headerlink" title="TCP流量控制机制"></a>TCP流量控制机制</h2><p>接收方在发送给发送方的数据头部，声明可用空间，从而使发送方调整发送速度。</p><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p>三次握手：</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/TCP2.png"></p><p>四次挥手：</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/TCP3.png"></p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>AIMD(加性增-乘性减)：逐渐增加传输速率，拥塞窗口每个RTT增大一个MSS(Maximum Segment Size)探测可用带宽，直到loss，发生loss时，拥塞窗口减半。</p><p>慢启动：TCP连接建立时，拥塞窗口大小为1，随后指数型增长，直到loss或者达到threshold。</p><p>拥塞避免：达到loss时，其拥塞窗口的半值会被设定为threshold，未达到threshold，按慢启动运行；当达到threshold时，线性增长。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层的核心功能为：<strong>转发</strong>和<strong>路由</strong>。</p><h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>其提供网络层的<strong>有连接服务</strong>，这种网络可以抽象成：两台主机之间搭建起了一条通讯电路。其按照“呼叫建立-通讯-呼叫拆除”的方式运行。</p><p>路径上的每一段小链路都有一个VCID(虚电路ID)，路径上的数据分组，不携带目标地址，只标识VCID。</p><h2 id="数据包网络"><a href="#数据包网络" class="headerlink" title="数据包网络"></a>数据包网络</h2><p>其提供网络层的<strong>无连接服务</strong>，每个分组携带目的地址，路由器根据分组的目的地址转发分组。</p><p>路由算法采取<strong>最长前缀匹配优先算法</strong>，根据目的地址确定链路接口。</p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>结构如下：</p><p><img src="/2023/10/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/IP.png"></p><p>其中：</p><ul><li>版本号：4&#x2F;6，标识IPv4&#x2F;IPv6协议。</li><li>首部长度：标识IP数据包首部的长度，以4字节为单位。比如，如果首部长度为4，就表明头部长16字节。</li><li>总长度：标识IP数据包的总字节数。</li><li>生存时间(TTL)：IP分组在网络中最多可以经过的Hop数，路由器转发一次分组，TTL就减去一。</li><li>协议：6为TCP，17为UDP。</li><li>首部校验和：和UDP的checksum计算方法一致。</li></ul><h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><p>网络链路中存在MTU(最大传输单元)，一段大MTU链路向小MTU链路传递信息时，数据可以被分片，分片到达目的主机后，进行重组操作。</p><p>利用数据报中的<strong>总长度、标识、标志位和位偏移</strong>标识分片和相对顺序：</p><ul><li>每产生一个分组，标识位就加一。</li><li>标志位有三位，分别为Reserved、DF(Don’t fragment)和MF(More Fragment)，DF为1表示未分片，为0表示分片了，MF为1表示该数据片不是最后一片，为0则表示该片为最后一片。</li><li>位偏移标识该分片对于原数据IP的偏移量。</li></ul><p>分片时，每个分片都要复制原IP的报头。</p><p>设原IP数据报长度为$L$，待转发链路的MTU为$M$，则一个最大分片所能承载的数据量为：<br>$$<br>d&#x3D;\lfloor{\frac{M-20}{8}}\rfloor\times8<br>$$<br>20为IP数据报头长度。</p><p>需要的总片数为：<br>$$<br>n&#x3D;\lceil\frac{L-20}{d} \rceil<br>$$<br>片偏移为：<br>$$<br>F_i&#x3D;\frac{d}{8}\times (i-1), 1\leq i\leq n<br>$$</p><h2 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h2><p>网络号-主机号</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Midnight Soda</title>
      <link href="/2023/10/06/Midnight-Soda/"/>
      <url>/2023/10/06/Midnight-Soda/</url>
      
        <content type="html"><![CDATA[<p>酒精，带着灵魂上升，</p><p>上升到乌托邦，上升到天堂。</p><p>与先贤谈哲理，与另一个自己谈渴望。</p><p>你说着儿时的梦想，</p><p>你说你要挺直胸膛，如同战士，扛着钢枪。</p><p>杯中的气泡旋转浮上，</p><p>脸上沾染晚风的凉，</p><p>你说你——</p><p>心里满是，蛀虫留下的空洞。</p><p>你说你——</p><p>日复一日，在异乡寻找故乡。</p><p>你说你——</p><p>徒然度日，为丢失的自我焚香。</p><p>白日带来的创伤，</p><p>在夜晚将灵魂捆绑。</p><p>于是，你饮用着酒精带来的快乐，</p><p>有些事，暂不去想。</p><p>是进是退，都是一场空。</p><p>墙角落灰的吉他，玻璃上的霜，</p><p>似是儿时放学归来后，饭菜的香。</p><p>似是昔日武侠小说中，楼宇回廊。</p><p>似是往年桌上白灯下，日记三两。</p><p>过去已然将你遗忘。</p><p>杯中旋转的气泡，心底起的浪，</p><p>似是几颗石子坠深潭，了无回响。</p><p>似是一捧骨灰洒长江，漂往何方？</p><p>似是二十余年的年华，将你埋葬。</p><p>现在，未来，如同过往。</p><hr><p>我是生命女神和死亡女神的孩子，我走在生存和死亡之间的那条界限上，其实，死亡是一片广阔的黑暗的原野，生存是原野中间的一条微薄的亮线。我们都走在这条亮线上。两位女神静静注视着这一切。一旦死掉，我们的身躯会化作这亮线上的一条光点，指引后来者，随后逐渐黯淡下去，当黯淡到与原野的黑暗同色时，我们的身躯便会在亮线上重新生成，继续向前走去，如此反复。我是一个“轮回论者”。“结域-解域-再结域”。</p><p>我不为死亡感到悲哀，因为我觉得，人与人之间的恶意带给我的恐怖，远远大于死亡带给我的恐怖——我宁愿在寒冷的雪地里战栗，也不愿意因见证血腥的场面而瑟瑟发抖。不畏惧死亡的人，大概也不会惧怕孤独。孤独是死亡的孩子，是生命的底色，是大多数时候我们都要经历的事情。</p><p>我的噩梦始终困扰着我——那是过去留给我的创伤。过去遗忘了我，可我还没有忘记过去的那些事情。我不得不认清这样的现实：比起死亡，我更害怕生命。创伤是生命的产物——死人怎么会感知到创伤呢？我带着创伤挨过一日又一日，直至余生结束。</p><p>爱……春天……生命女神在折磨着我；平静……冬天……死亡女神在引诱着我。我很想知道自己到底是怎么想的，但我没办法给自己做精神分析——给自己做精神分析的结果是迟滞的，所以我乐意写诗，我可以当作客体分析过去的我。Mess! </p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】Boyer-Moore投票算法</title>
      <link href="/2023/10/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Boyer-Moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Boyer-Moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>该算法用于<strong>寻找数组中出现最多次元素</strong>的问题。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><ol><li>初始化两个变量<strong>出现最多次元素的值val</strong>和<strong>这个元素出现的次数time</strong>。</li><li>遍历数组：<ol><li>若time为0，则将遍历到的当前元素赋值给val。</li><li>若数组中当前元素与val相同，则让time自增，否则让time自减。</li></ol></li><li>(可选)检查。</li></ol><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BM</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>, time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>) &#123;</span><br><span class="line">            val = i;</span><br><span class="line">            time = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == val) &#123;</span><br><span class="line">            ++time;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的直观理解是这样的，一些人在为一个政治问题投票，如果投票最多的选项是A，那么投其他选项的人都是反对A的人。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p><a href="https://leetcode.com/problems/majority-element/">Leetcode169. Majority Element</a>题解为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> elem = <span class="number">0</span>, times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(times == <span class="number">0</span>) &#123;</span><br><span class="line">                elem = i;</span><br><span class="line">                ++times;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == elem) &#123;</span><br><span class="line">                ++times;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --times;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/majority-element-ii/">Leetcode229. Majority Element II</a>题解为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate1 = <span class="number">0</span>, candidate2 = <span class="number">0</span>, count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Search</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate1 == num) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidate2 == num) count2++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate1 = num;</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate2 = num; </span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Verification</span></span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate2) count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) ans.<span class="built_in">push_back</span>(candidate1);</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) ans.<span class="built_in">push_back</span>(candidate2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文总结】知识图谱增强大模型的几种方法</title>
      <link href="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/"/>
      <url>/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>大模型，比如ChatGPT，在各大领域嘎嘎乱杀，目前感觉各个专业的各个研究方向都有许多项目和大模型有关。大模型大多采用Transformer架构，大概分为三种，BERT类(主要结构为Transformer的encoder)、GLM类(主要结构包括encoder和decoder)和GPT类(主要结构为decoder)。大模型具有普适性，即能输出各个领域的知识。但是，其也存在很多问题，比如胡乱推理(hallucination，幻觉现象)、黑盒性(这导致人类很难具体解释大模型内部是怎么运作的)。</p><p>知识图谱内部存储具体的、实际的信息，其一般以三元组方式存储知识，结构为：(实体A，实体A与实体B的关系，实体B)。在无噪声的知识图谱内搜索，不会出现“胡乱推理”的行为，但是，知识图谱也存在一系列问题：难以构造、没法获取新知识等。</p><p>可以通过知识图谱增强大模型的推理能力。本文总结幻读过的一些论文，做个关于二者结合的小小总结。</p><p>参考《Unifying Large Language Models and Knowledge Graphs: A Roadmap》这篇论文，通过知识图谱增强大模型的方法大概有两种：</p><ol><li><p>Dynamic Knowledge Fusion(动态的知识融合)。该方法的架构为如下的双塔型：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/model1.png"></p><p>将整个KG、问题分别编码，接着送入联合推理层进行推理。</p></li><li><p>Retrieval-Augmented Knowledge Fusion(检索增强的知识融合)。该方法的架构为，先从KG选取和问题有关的子图，接着进行处理。</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/model2.png"></p></li></ol><h1 id="动态知识融合的实例"><a href="#动态知识融合的实例" class="headerlink" title="动态知识融合的实例"></a>动态知识融合的实例</h1><h2 id="QA-GNN"><a href="#QA-GNN" class="headerlink" title="QA-GNN"></a>QA-GNN</h2><p>该方法主要处理选择题。</p><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN.png"></p><p>该方法步骤如下：</p><ol><li><p>将问题编码，搜寻涉及到的问题节点和答案节点，接着设定一个辅助节点Z，将它与知识图谱中的问题节点、答案节点连接起来，构成一个工作图(working graph)。</p></li><li><p>应用如下公式计算每个节点的相关性评分:</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN1.png"></p></li><li><p>应用以GAT为基础的图神经网络(GNN)在工作图上进行推理，参数更新如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN2.png"></p><p>这里的$f_n$是两层MLP。</p></li><li><p>对于每一个节点，我们要考虑节点类型和其能提供的信息，节点类型的计算：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN3.png"></p><p>这里的$f_u$是一个线性变换，$f_r$是一个2层感知机，就是两层MLP。其中源、目标节点、关系类型用one-hot方法表示，记作$u_s,u_t$，二者关系用$e_{st}$表示。提供的信息用如下公式进行计算：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN4.png"></p><p>一个线性变换。</p></li><li><p>接着计算最终的注意力权重：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/QAGNN5.png"></p><p>首先将节点的相关性分数升维，然后计算查询向量和key向量带来的权重，接着计算注意力机制即可。</p></li></ol><h2 id="JointLK"><a href="#JointLK" class="headerlink" title="JointLK"></a>JointLK</h2><p>处理选择题。其创新之处在于双向注意力机制的应用。</p><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK.png"></p><p>该结构包括两个主要部分：交叉推理模块和动态修剪模块。</p><p>LM Encoder层先采用预训练的语言模型编码问题和备选项，接着应用下图公式，先输入进一个线性变换层，接着应用一个激活函数输出即可：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK2.png"></p><p>GNN Layer层则要复杂一些，首先使用平均池化的BERT获得KG中每个实体的表示，接着应用以RGAT为基础的GNN层处理得到的实体表示：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK3.png"></p><p>交叉推理模块的目的是减少知识图谱特征和查询向量之间的差异，其输入是之前提到的两个层的输出。首先根据如下公式构造一个“亲和力矩阵”(Affinity Matrix):</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK4.png"></p><p>其中$q_i^{l-1}$是第l层交叉推理模块输入的第i个查询向量。</p><p>接着用Softmax函数处理，得到KG-to-LM attention，若用Softmax函数处理亲和力矩阵的转置矩阵，则得到LM-to-KG attention。</p><p>原有的查询向量和KG-to-LM attention矩阵相乘，得到暂时的查询向量表示；原有的KG表示和LM-to-KG attention矩阵相乘，得到暂时的KG表示。暂时的查询向量表示和暂时的KG表示相连，再送入线性层，即可得到新的查询向量表示，新的KG表示也可以通过类似的方法得到。详情见总结构图。</p><p>对于动态修建模块来说，我们的目标是在KG中切除没用的节点，断开没用的关系边，计算公式如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/JointLK5.png"></p><p>$K$是一个超参数，决定修剪的激进程度，而$|V|$则表示实体的数量。公式14的意思就是，从Z这个KG中，留下$upperbound(K|V|)$个节点。</p><p>在这之后，将切除的节点和与它们相连的边删除即可。</p><p>在N层迭代之后，将KG表示做注意力池化，将查询向量表示做平均池化，将二者concat，输入MLP层，即可得到输出。</p><h2 id="GreaseLM"><a href="#GreaseLM" class="headerlink" title="GreaseLM"></a>GreaseLM</h2><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/GreaseLM.png"></p><p>其结构很简单，通过LM编码query，通过GNN编码KG，接着将query中的一个元素和GNN中的一个元素接入一个MLP，这就完成了信息的传递，接着将剩下的元素分别传入LM和GNN，在这两个结构内，信息逐步传播到邻近的节点。</p><h1 id="检索增强的知识融合实例"><a href="#检索增强的知识融合实例" class="headerlink" title="检索增强的知识融合实例"></a>检索增强的知识融合实例</h1><h2 id="Think-on-graph"><a href="#Think-on-graph" class="headerlink" title="Think-on-graph"></a>Think-on-graph</h2><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/Think-On-Graph.png"></p><p>步骤如下：</p><ol><li>实体获取：根据输入的问题，应用LLM获取有关联节点。</li><li>基于束搜索(Beam Search)的探索：<ol><li>关系搜索与修剪：从现有的节点开始，探索所有相连的关系边，迭代操作，最终应用LLM修剪贡献不大的边。</li><li>实体搜索与修剪：在关系搜索的过程中，每次迭代都会获取一个实体的集合，应用LLM修剪贡献不大的实体节点。</li></ol></li><li>推理：最终我们获取了P条推理链，应用LLM判断这些推理链是否足够推理出最终结果。能，就输出最终结果，否则重复探索操作。</li></ol><h2 id="StructGPT"><a href="#StructGPT" class="headerlink" title="StructGPT"></a>StructGPT</h2><p>本篇论文提出的方法可以被简单地概括为<strong>迭代阅读-推理方法</strong>。</p><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/StructGPT.png"></p><p>该篇论文没有局限在只使用KG来增强LLM，作者使用了各种结构化的知识库，如KG、数据库和数据表。</p><p>步骤如下：</p><ol><li>阅读：应用预选设计的一系列API，从结构化的知识库中提取出相关知识。</li><li>推理：首先将阅读得到的信息线性化，亦即转化为规定好的格式，然后交付给LLM输出。LLM的输出有两种情况，一种是简单地输出最终答案，一种是输出根据现有信息推导出的新信息，根据新信息，继续迭代阅读。</li></ol><p>该方法没有完全解决Hallucination的问题。</p><h2 id="EMAT"><a href="#EMAT" class="headerlink" title="EMAT"></a>EMAT</h2><p>结构如下：</p><p><img src="/2023/10/02/%E3%80%90%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E3%80%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%8D%8F%E5%90%8C/EMAT.png"></p><p>步骤如下：</p><ol><li>将结构化的知识存储为键值对。作者采用的结构化知识库的key是问题，value是答案。<ol><li>对key编码时，首先在key前增加一个长度为P的前缀，卷积最后一层隐藏层的输出，接着取前P个结果作为编码。</li><li>对value编码时，增加长度为P的前缀，取最后一层隐藏层输出的前P个元素作为编码。</li></ol></li><li>对于输入的问题，应用上面对key编码的方式，接着应用MIPS(Maximun Inner Product Search)搜索top-K个最相关的键值对，按照相关顺序排序。</li><li>将key增加位置编码，然后concat成一个矩阵，在每一层隐藏层的状态前都concat这个矩阵。对于value，做同样的操作，但是要加在每一层隐藏层的前面。如此操作，最终输出答案即可。</li></ol><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><h2 id="CRITIC"><a href="#CRITIC" class="headerlink" title="CRITIC"></a>CRITIC</h2><p>应用外部应用(搜索引擎、编程语言、知识图谱等)验证、修改LLM输出。</p><h2 id="Graph-Toolformer"><a href="#Graph-Toolformer" class="headerlink" title="Graph-Toolformer"></a>Graph-Toolformer</h2><p>微调出一个能够生成在KG中查询的LLM。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thanatos</title>
      <link href="/2023/09/21/Thanatos/"/>
      <url>/2023/09/21/Thanatos/</url>
      
        <content type="html"><![CDATA[<p>我丢弃了二十年的年华，</p><p>在课本上画黑白的花，</p><p>在铃声中下沉，</p><p>在脸上刻满血红的涂鸦。</p><p><br>他踩在我的脑袋上，</p><p>我的脚踩住他的脸，</p><p>可我们笑容满面，</p><p>鲜血与自由换来无上的荣光。</p><br><p>于是我们沉迷于酒精、药物和——</p><p>那些畸形又强烈的快乐。</p><p>我知道，我永远无法成为那个——</p><p>梦中的，优秀的，正常的我。</p><br><p>梦！我竟做过梦！</p><p>梦中的我曾逃离这一切，</p><p>我曾在悬崖之上吹风，</p><p>我曾生活在空无一人的旷野，</p><p>我曾拉着她的手，一起杀死过去的恶灵，</p><p>我曾啜饮着他们的鲜血。</p><br><p>梦醒时分，我的泪水将我的灵魂打湿，</p><p>我知道我丢失了太多东西——</p><p>情感，思维，和生命的意义，</p><p>所失之物为我所是。</p><br><p>天空还未被太阳照亮，</p><p>屋子里被黑暗占领，</p><p>窗外如此宁静，</p><p>世界了无一点声响。</p><br><p>我是世界的弃婴，</p><p>我是叹息的缘由，</p><p>我是破旧水管里的铁锈，</p><p>我是塔纳托斯的螟蛉。</p><br><p>如今我只有我自己了，</p><p>我幸福，温暖又快乐。</p><br><p>若我从此失掉了一切——</p><p>我臆想中的一切，</p><p>我将在深夜凝视着镜中的自己，</p><p>哀叹——如同寒风漫步在旷野。</p><br><p>旋即，我将歌唱，我将大笑，</p><p>我将歌颂这以野草作装饰的地面，</p><p>我将记住芸芸众生的脸，</p><p>在凌晨之时对黑暗大叫：</p><br><p>杀了我吧，杀了我吧！</p><p>将我的尸体展示给世人吧！</p><p>抽干我的鲜血吧！</p><p>用你们给予我的东西阉割我吧！</p><p>将我的大脑挖出，将残次品展示给世人吧！</p><p>你们，且载歌载舞，放声大笑吧！</p><p>你们，且载歌载舞，放声大笑吧！</p><p>你们，且载歌载舞，放声大笑吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】线性SVM的推导</title>
      <link href="/2023/09/18/%E3%80%90AI%E3%80%91SVM%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
      <url>/2023/09/18/%E3%80%90AI%E3%80%91SVM%E7%9A%84%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>线性支持向量机(LSVM)用来处理二分类问题。</p><p>拿二维平面来说，一个二维平面上有一堆白色和黑色的点，线性支持向量机求这样一条直线：该直线能够将二者分开——直线的一边全是白色的点，另一边全是黑色的点。</p><p>支持向量机的关键是“支持向量”，试看下图：</p><p><img src="/2023/09/18/%E3%80%90AI%E3%80%91SVM%E7%9A%84%E6%8E%A8%E5%AF%BC/1.png"></p><p>假设我们已经求取出了这样一条直线，那么支持向量就是离这条直线最近的样本点向量，就是图中落在虚线上的点。我们的目标是，求取出一条直线（超平面），使得超平面和支持向量之间的距离尽可能大。为什么？因为距离越大，表示两类样本点越泾渭分明。</p><h1 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h1><h2 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h2><p>假设我们有一个点$A(x_1,x_2,\cdots,x_n)$和一条直线$Y&#x3D;k^TX+b$，那么该点到直线的距离为：<br>$$<br>d_{A-Y}&#x3D;\frac{|k^TA+b|}{||k||}<br>$$</p><h2 id="约束问题简化的拉格朗日方法"><a href="#约束问题简化的拉格朗日方法" class="headerlink" title="约束问题简化的拉格朗日方法"></a>约束问题简化的拉格朗日方法</h2><p>对于如下的约束问题：<br>$$<br>minf(x)\ s.t.\ \ g(x,y)&lt;0<br>$$<br>则可简化为无约束问题：<br>$$<br>L(x,y,\lambda)&#x3D;f(x)-\lambda (g(x,y)+k)<br>$$<br>这里，我们首先添加松弛变量$k$，令约束问题化为等式约束问题，接着构造上面的函数，通过下面式子求解：<br>$$<br>\frac{\partial L}{\partial x}&#x3D;0,\frac{\partial L}{\partial y}&#x3D;0,\frac{\partial L}{\partial \lambda}&#x3D;0<br>$$</p><h1 id="1-初始问题的化简"><a href="#1-初始问题的化简" class="headerlink" title="1. 初始问题的化简"></a>1. 初始问题的化简</h1><p>根据引子里提到的内容，我们的问题可以记为：</p><p>求这样一条直线$Y&#x3D;k^TX+b$，使得下列式子：<br>$$<br>\frac{k^TA+b}{||k||}\geq d,y&#x3D;1<br>$$</p><p>$$<br>\frac{k^TA+b}{||k||}\leq -d,y &#x3D; -1<br>$$</p><p>中的$d$尽可能大，由于我们只采用支持向量，所以取等号即可。这里的$y$用于表示样本点的类别，根据样本点的类别判断距离的正负。那么：<br>$$<br>d&#x3D;\frac{y(k^TA+b)}{||k||}<br>$$<br>我们的问题等价于:<br>$$<br>max\frac{y(k^TA+b)}{||k||}<br>$$</p><p>不妨设分子为1，分子完全是一个尺度，表示支持向量到超平面的距离，假设为任意数不影响结果。那么我们的问题等价于:<br>$$<br>max\frac{1}{||k||}<br>$$<br>做个转换，方便后面求导：<br>$$<br>min\frac{1}{2}||k||^2\ s.t.\ \  \forall x_i\in D,y_i(k^Tx_i+b)&#x3D; 1<br>$$<br>应用拉格朗日方法，和强对偶性，这里我略去了关于强对偶性的推导，转化为：<br>$$<br>\min_{w,b}\max_{\lambda}L(k, \lambda_i,b)&#x3D;\frac{1}{2}||k||^2+\sum_{i&#x3D;1}^n\lambda_i(1-y_i(k^Tx_i+b))<br>$$<br>记：<br>$$<br>f(k)&#x3D;\frac{1}{2}||k||^2<br>$$</p><p>$$<br>g_i(k)&#x3D;1-y_i(k^Tx_i+b)<br>$$</p><p>接着，求解：<br>$$<br>\frac{\partial L}{\partial k}&#x3D;k-\sum y_i\lambda_ix_i&#x3D;0<br>$$</p><p>$$<br>\frac{\partial L}{\partial b}&#x3D;-\sum\lambda_iy_i&#x3D;0<br>$$</p><p>$$<br>\frac{\partial L}{\partial \lambda_i}&#x3D;g_i(k)&#x3D;0<br>$$</p><p>代入回原来的式子，得到：<br>$$<br>\max_{\lambda_i}L(\lambda_i)&#x3D;\sum \lambda_i-\frac{1}{2}\sum_{i,j&#x3D;1}\lambda_i\lambda_jy_iy_jx_i^Tx_j<br>$$<br>带上约束条件：<br>$$<br>\max_{\lambda_i}L(\lambda_i)&#x3D;\sum \lambda_i-\frac{1}{2}\sum_{i,j&#x3D;1}\lambda_i\lambda_jy_iy_jx_i^Tx_j\ s.t.\ \ \sum\lambda_i y_i&#x3D;0<br>$$<br>应用相应算法求解出$\lambda_i$之后，通过下面的式子，权重和bias都可求：<br>$$<br>k&#x3D;\sum y_i\lambda_ix_i<br>$$</p><p>$$<br>y_i(k^Tx_i+b)&#x3D;1<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP】智能软件工程课程笔记</title>
      <link href="/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这门课本来是研究生课程，不知道为什么，本学期也给本科生开了。</p><p>说是上课，不过是老师带着学生读论文而已。</p><p>这门课所讲述的内容，是将NLP相关的模型，用于软件工程上，简化相应工作。</p><p>我将老师讲述的部分模型记录于此，权当备忘。</p><h1 id="代码表示学习和几类代表性任务"><a href="#代码表示学习和几类代表性任务" class="headerlink" title="代码表示学习和几类代表性任务"></a>代码表示学习和几类代表性任务</h1><p>代码表示学习，就是将代码用一系列张量表示，通过机器学习的相关模型，学习出一些特征来。在软件开发中，常见的几类代码表示学习任务有：</p><ol><li>Bug定位。将缺陷报告和源文件作为输入，输出为缺陷代码具体的位置，免去人工调试定位。</li><li>代码分类。</li><li>代码生成。将用户需求作为输入，输出实现对应功能的代码。</li><li>代码翻译。将Java程序翻译成C程序。</li></ol><p>根据编译原理的相关知识，源代码变为目标代码需要经历以下几个步骤：</p><ol><li>词法分析，该步生成token序列。</li><li>语法分析，该步生成抽象语法树(AST)。</li><li>语义分析，该步可以生成图，比如数据依赖图(DDG)、控制依赖图(CDG)等。</li><li>中间代码生成。</li><li>优化。</li><li>目标代码生成。</li></ol><p>那么代码表示学习大致可以分为三类：</p><ol><li>基于序列的代码表示学习。</li><li>基于树的代码表示学习。</li><li>基于图的代码表示学习。</li></ol><h1 id="基于序列的代码表示学习"><a href="#基于序列的代码表示学习" class="headerlink" title="基于序列的代码表示学习"></a>基于序列的代码表示学习</h1><h2 id="RNN-循环神经网络"><a href="#RNN-循环神经网络" class="headerlink" title="RNN(循环神经网络)"></a>RNN(循环神经网络)</h2><p>RNN的结构如下:</p><p><img src="/1.png"></p><p>整个RNN其实只有一套参数，只不过$t-1$时刻的输出会作为$t$时刻的输入而已。$o_{t-1},o_{t},o_{t+1}$可有可无，根据实际需要修改即可。</p><p>每个时刻的输出如下:<br>$$<br>s_t&#x3D;f(Ux_t+Ws_{t-1}+b_0)<br>$$<br>$$<br>o_t&#x3D;g(Vs_t+b_1)<br>$$</p><p>$f,g$分别为隐藏层、输出层的激活函数。</p><p>因为每个时刻的输出和前一个时刻有关，所以RNN能够一定程度记忆过去发生的信息，有一定的<strong>时序记忆性</strong>。</p><p>优点：结构简单，易于训练。</p><p>缺点：简单根据链式法则推算反向传播，容易发现RNN有梯度消失和梯度爆炸的问题。详见<a href="https://zhuanlan.zhihu.com/p/44163528">RNN 的梯度消失问题</a>。</p><h2 id="LSTM-长短期记忆模型"><a href="#LSTM-长短期记忆模型" class="headerlink" title="LSTM(长短期记忆模型)"></a>LSTM(长短期记忆模型)</h2><p>为了解决RNN的问题，有研究者提出了LSTM，其结构如下：</p><p><img src="/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2.png"></p><p>其内部有三个门(上图中三个$\sigma$)，从左到右分别为遗忘门、输入门和输出门。这三个门就是三个全连接网络。遗忘门用来选择性遗忘上一个节点传来的信息，输入门用来选择性记忆输入的信息，输出门用来筛选输出的信息。</p><p>将输入token $x_t$和前一时刻的状态$h_{t-1}$应用concat操作，作为三个门的输入:</p><p>$$<br>f_t &#x3D; \sigma(W_f[h_{t-1},x_t]+b_f)<br>$$<br>$$<br>i_t &#x3D; \sigma(W_i[h_{t-1},x_t]+b_i)<br>$$</p><p>$$<br>o_t &#x3D; \sigma(W_o[h_{t-1},x_t]+b_o)<br>$$</p><p>此外，LSTM也有另外一个输入：记忆节点状态${c}_t$。在图中，其从节点左上角输入。根据图中结构：</p><p>$$<br>h_t&#x3D;o_t\circ tanh(c_t)<br>$$<br>$$<br>c_t&#x3D;f_t\circ c_{t-1}+i_t\circ tanh(W_c[h_{t-1},x_t]+b_c)<br>$$</p><p>优点：易于长期记忆重要信息。</p><p>缺点：参数量太多，不易训练。</p><h2 id="GRU-门控循环单元"><a href="#GRU-门控循环单元" class="headerlink" title="GRU(门控循环单元)"></a>GRU(门控循环单元)</h2><p>LSTM参数太多，那么就简化一下：</p><p><img src="/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2.jpg"></p><p>从左到右的两个门分别为重置门、更新门，公式如下：</p><p><img src="/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/3.png"></p><p>优点：平衡了易训练性和记忆性。</p><p>缺点：这个算是循环网络的通病，在训练长序列时，根据链式法则，总会出现梯度下降、梯度爆炸的问题。</p><h1 id="基于语法树的代码表示学习"><a href="#基于语法树的代码表示学习" class="headerlink" title="基于语法树的代码表示学习"></a>基于语法树的代码表示学习</h1><h2 id="Tree-LSTM"><a href="#Tree-LSTM" class="headerlink" title="Tree-LSTM"></a>Tree-LSTM</h2><p>和LSTM差不多，只不过有多个记忆节点状态和前时刻状态而已。假设一个节点有$k$个子节点，那么该cell中，就有$k$个遗忘门，将每个记忆节点状态输入对应的遗忘门中，将结果相加，就等价于LSTM的遗忘门输出。</p><p>对于前时刻状态，则将他们加起来即可。</p><p>结构如下：</p><p><img src="/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/4.png"></p><p>基于序列的LSTM可以看作树LSTM的特例。</p><h2 id="TBCNN"><a href="#TBCNN" class="headerlink" title="TBCNN"></a>TBCNN</h2><p>NLP也从CV那里获得了很多有趣的灵感，比如将CNN应用到NLP相关人物的求解上去。</p><p>TBCNN结构如下：</p><p><img src="/2023/09/16/%E3%80%90NLP%E3%80%91%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/tbcnn.png"></p><p>其步骤为：</p><ol><li>获取AST，并向量化。</li><li>定深窗口卷积。用一个定深的窗口检测器在树上滑动卷积，缺位补0。</li><li>动态池化。</li><li>输出。</li></ol><h2 id="分阶段的代码表示学习"><a href="#分阶段的代码表示学习" class="headerlink" title="分阶段的代码表示学习"></a>分阶段的代码表示学习</h2><p>也可以直接将CNN应用到语句上，比如将语句利用one-hot表示，然后变换成一个矩阵，用CNN卷积、池化，接着将每一行都导入LSTM当中去，池化输出。</p><h2 id="ASTNN"><a href="#ASTNN" class="headerlink" title="ASTNN"></a>ASTNN</h2><p>采用分治算法，将大AST按照语句粒度分解为小AST，接着通过RvNN编码，输入双向RNN中，池化，输出。</p><h1 id="基于图的代码表示学习"><a href="#基于图的代码表示学习" class="headerlink" title="基于图的代码表示学习"></a>基于图的代码表示学习</h1><p>待更新…</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】堆和优先队列</title>
      <link href="/2023/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2023/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一棵树，若父节点的值不小于子节点的值，就是大根堆，若父节点的值不大于子节点的值，就是小根堆。常用的堆为二叉大根堆。</p><p>二叉堆是一个完全二叉树。所谓完全二叉树就是，每一层的节点都”左对齐”，具体参考<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a>。</p><p>堆有几种操作：</p><ol><li><p>插入。向二叉堆中插入节点，只需在最后一层插入，之后根据堆的性质和父节点的值比较大小，调整位置即可，该操作最多比较的次数和层数几乎一致，故复杂度为$O(log_2n)$。</p></li><li><p>修改。同样复杂度为$O(log_2n)$。</p></li><li><p>删除根节点。该操作通常直接将层序从左向右遍历的最后一个节点赋给根节点的值，删除最后一个节点，接着根节点和子节点值比较，进行调整，复杂度同样为$O(log_2n)$。</p></li></ol><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>优先队列是排好序的队列。其本质就是一个堆。为什么？将堆拉直，第二层节点置于第一层右侧，第三层节点置于第二层右侧，就实现了一个线性的数据结构，由于删除常常删除根节点，而插入常常在末尾添加，这就是一个队列。</p><p>在C++里，优先队列是一个大根堆，由<code>vector</code>实现，严格来说，优先队列是<code>vector</code>的一个适配器。如果对性能有要求，可以自己写一个堆。</p><p>由于是使用<code>vector</code>实现的，那么讨论几种操作的复杂度：</p><ol><li>插入。只需要从左到右将待插入的元素和队列里元素逐个比较即可，复杂度为$O(n)$，注意，这里并非将整个队列排序，而是对单个元素进行排序，所以复杂度不是$O(nlogn)$。</li><li>删除。复杂度为$O(n)$。</li></ol><h1 id="适用于什么问题"><a href="#适用于什么问题" class="headerlink" title="适用于什么问题"></a>适用于什么问题</h1><p>由于优先队列和堆的有序性，其常常用于“前k个…”问题。</p><p>比如<a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">Leetcode703. Kth Largest Element in a Stream</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt; ,greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和<a href="https://leetcode.com/problems/k-closest-points-to-origin/">Leetcode973. K Closest Points to Origin</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> (a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>]) &lt; (b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, compare&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; p : points) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(p);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法</h1><p>该算法适用于求解上述问题，其本质是分治算法(divide and conquer)。</p><p>该算法的思想是：逐步缩小选择范围。</p><p>具体的解释在<a href="https://zhuanlan.zhihu.com/p/64627590">Top K 问题的最优解 - 快速选择算法（Quickselect）</a>这里解释的已经很清楚了，这里只是用C++实现一下相关代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pivot = arr[r], i = l;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j] &lt;= pivot) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">swap</span>(arr[i], arr[r]);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KthSmallest</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> part_index = <span class="built_in">Partition</span>(arr, l, r);</span><br><span class="line">  <span class="keyword">if</span>(k - <span class="number">1</span> == part_index - l) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[part_index];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k - <span class="number">1</span> &lt; part_index - l) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">KthSmallest</span>(arr, l, part_index - <span class="number">1</span>, k);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">KthSmallest</span>(arr, part_index+<span class="number">1</span>, r, k - part_index - <span class="number">1</span> + l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">KthSmallest</span>(arr, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用这个方法做<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode215. Kth Largest Element in an Array</a>会导致TLE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot_index = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l, i = l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivot_index], nums[r]);</span><br><span class="line">        <span class="type">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">partition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(index != nums.<span class="built_in">size</span>() - k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt; nums.<span class="built_in">size</span>() - k) &#123;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, <span class="number">0</span>, index - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, index + <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>远不如调用<code>std::priority_queue</code>来得舒适。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】位运算</title>
      <link href="/2023/08/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2023/08/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1. 位运算符"></a>1. 位运算符</h1><p>在C++里，位运算一共有六种：</p><ol><li><code>&amp;</code>，按位与。</li><li><code>|</code>，按位或。</li><li><code>^</code>，异或符。</li><li><code>~</code>，按位取反符。</li><li><code>&gt;&gt;</code>，算术右移运算符，即左侧用符号为补位，比如同样右移四位：0000 1111-&gt;0000 0000，而1111 0000-&gt;1111 1111。</li><li><code>&lt;&lt;</code>，左移运算符。</li></ol><p>Java语言在上述基础上，多了一个逻辑右移运算符<code>&gt;&gt;&gt;</code>，即右移时高位只补0。</p><h1 id="2-位运算符的各种用法"><a href="#2-位运算符的各种用法" class="headerlink" title="2. 位运算符的各种用法"></a>2. 位运算符的各种用法</h1><h2 id="1-判断奇偶"><a href="#1-判断奇偶" class="headerlink" title="1. 判断奇偶"></a>1. 判断奇偶</h2><p>设一个十进制数$N$的补码二进制表示为$a_na_{n-1}\cdots a_1$，则对于正数有：<br>$$<br>N &#x3D; a_n \times 2^{n-1} + a_{n-1}\times 2^{n-2}+\cdots+a_1 \times 1<br>$$<br>对于负数有：<br>$$<br>N &#x3D; -a_n \times 2^{n-1} + a_{n-1}\times 2^{n-2}+\cdots+a_1 \times 1<br>$$</p><p>公式参见《深入理解计算机系统》。</p><p>对于一个二进制数来说，除去其最低位，各位的权重都为2的整数次幂，修改它们，等价于加上&#x2F;减去一个偶数，不影响二进制数的奇偶性。</p><p>二进制数字的奇偶性由其最低位决定，最低位为1，则该数为奇，否则为偶。</p><p>根据上述理论，可写出判断奇偶数的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsOdd</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如<a href="https://leetcode.com/problems/number-of-1-bits/">Leetcode191. Number of 1 Bits</a>，就是该用法的变体，解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) result++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-swap-函数的位运算实现"><a href="#2-swap-函数的位运算实现" class="headerlink" title="2. swap()函数的位运算实现"></a>2. swap()函数的位运算实现</h2><p>出自《深入理解计算机系统》。一般来说，没人会这么写的，说实话。</p><p>至于为什么，看看下面提到的异或的性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-异或的性质-amp-只出现一次的数字"><a href="#3-异或的性质-amp-只出现一次的数字" class="headerlink" title="3. 异或的性质&amp;只出现一次的数字"></a>3. 异或的性质&amp;只出现一次的数字</h2><p>只出现一次的数字问题为<a href="https://leetcode.com/problems/single-number/">Leetcode136. Single Number</a>，解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            result ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解这道题，不得不知道异或的性质：</p><ol><li>交换律：$a \oplus b &#x3D; b \oplus a$。</li><li>结合律：$a\oplus (b\oplus c) &#x3D; (a\oplus b)\oplus c$。</li><li>无序性：任意多个元素进行异或运算，结果与运算次序无关。</li><li>$x\oplus x &#x3D; 0$，$x\oplus 0 &#x3D; x$。事实上，这是一个幺半群，0是该幺半群的单位元&#x2F;幺元。</li></ol><p>所以，对于上面那道题，由于大多元素出现两次，只有一个元素出现一次，就可以使用第四条性质求解。</p><p>此外，对于<a href="https://leetcode.com/problems/missing-number/">Leetcode268. Missing Number</a>则有使用异或的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            target ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            target ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-乘除法的简化"><a href="#4-乘除法的简化" class="headerlink" title="4. 乘除法的简化"></a>4. 乘除法的简化</h2><p>理论上来讲，若二进制数字有无限位，则左移1位等价于乘2，右移一位等价于除2。</p><p>所以乘&#x2F;除2的整数次幂可以用移位位运算简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Times2</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Divide2</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    a &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-判断一个正数是否为2的整数幂"><a href="#5-判断一个正数是否为2的整数幂" class="headerlink" title="5. 判断一个正数是否为2的整数幂"></a>5. 判断一个正数是否为2的整数幂</h2><p>这种数的补码表示只有一个1，这种数减一会让1后面的所有0置1,本身置0,即：00100 - 00001 &#x3D; 00011。其他数字没有这个特点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPowOf2</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(a &amp; (a - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如<a href="https://leetcode.com/problems/counting-bits/">Leetcode338. Counting Bits</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lower_bound = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(!(i == <span class="number">0</span>));</span><br><span class="line">                lower_bound = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(result[i - lower_bound] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-不用加法运算符实现加法"><a href="#6-不用加法运算符实现加法" class="headerlink" title="6. 不用加法运算符实现加法"></a>6. 不用加法运算符实现加法</h2><p>本题为<a href="https://leetcode.com/problems/sum-of-two-integers/">Leetcode371. Sum of Two Integers</a>。按照半加器的思路来就行。</p><p>每次只考虑最后一位，进位由$a\And b$决定，而本位则由$a \oplus b$决定。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> carry = a &amp; b;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = carry &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">0</span> &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-位反转"><a href="#7-位反转" class="headerlink" title="7. 位反转"></a>7. 位反转</h2><p>移位运算也可以做一些有用的操作，将二进制数字看作一个数组即可。本题为<a href="https://leetcode.com/problems/reverse-bits/">Leetcode190. Reverse Bits</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            result &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            result += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tears in Rain</title>
      <link href="/2023/08/21/Tears-in-Rain/"/>
      <url>/2023/08/21/Tears-in-Rain/</url>
      
        <content type="html"><![CDATA[<p>我知道我是个怎样的人。</p><hr><p>最近我的过敏性鼻炎犯了，好严重，晚上睡觉的时候鼻子总是堵，难以入眠，早上起来鼻子里面又痒又疼，有好多黄鼻涕。或许回到学校会好一点吧。回学校之后，我要试着慢跑，来改善我的体质——按照西医来说，过敏很难治好。我不怎么信中医，但这回还是通过倪海厦的视频学了一些中医的理论，回学校操练操练。</p><p>中医更像是一种神秘学，信也可以，不信也没错。听说很多人通过中医的方式治好了鼻炎，我也打算试一试——太难受了。</p><hr><p>我最近老是做梦，梦见和自己的前女友依偎在一块——我丢失了好多记忆。梦里的感觉既温暖又舒服，让我找回了我丢失已久的理智——和情感支持，真正能给我爱的人，少之又少。但是，我看不清她的脸，每次当我望向她的面庞，我就感觉好痛苦，好痛苦。痛苦驱使着我低下头去，闭上眼睛——</p><p>“Je t’aime.”</p><p>我听见她的低语——那不是她的声音，是我的声音。</p><p>我没办法再去联系她。丢失的东西就是丢失了，我快忘记她的面庞、她的声音、她带给我的美好记忆——我已经孤身一人好久了。</p><p>更多的时候，都是我给予别人情感支持，这更像是一种赎罪而非善意——过去的我一味索取不知给予的罪恶——让我自己好受一点罢了。</p><p>我还要长时间地忍受孤寂——离了它，我会更加痛苦。</p><p>过去种种终将消逝，正如雨中的泪水。</p><hr><p>看着别人的幸福就会联想到自己的不幸，产生嫉妒之心；目睹别人的不幸，要么加深自己的痛苦，要么令自己产生一种虚无缥缈的优越感。人啊竟是如此下贱的生物。</p><p>我不知道怎么去爱人，我也永远不可能学会去爱一个人，同样的，我也永远不会被别人所爱。这是独属于我的诅咒，从我记事那天起就生效的诅咒。</p><p>我希望我能够爱一个人，但是我是自私的，我比其他人还要自私一千倍、一万倍。我是个彻头彻尾的混蛋。</p><p>我似乎每时每刻都不开心，我也不知道为什么。我脑子里有些东西快坏掉了，这令我一味寻死。寻死之人早已丧失为人的资格。Deus…这世界上可有神么？若有神，可以来救我么？我们都是神的孩子么？ </p><p>我在梦里总是沉默的，我无话可说。我在梦里没有身体，我早早消失了。我在梦里只能旁观一切事物的发生，那些事物和我的互动对我毫无影响。我和梦里的现实处于一种伪二元论的对立中，因为我是多，梦里的现实也是多，而多元论是一元论——这一切都没什么不同。</p><p>“我”永远是缺位的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】一维动态规划</title>
      <link href="/2023/08/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/08/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>动态规划永远是一道迈不过去的坎～</p><p>道理我都懂，但是相关的题目就是做不出来～</p><p>这种问题太灵活啦！</p><h1 id="何为动态规划？"><a href="#何为动态规划？" class="headerlink" title="何为动态规划？"></a>何为动态规划？</h1><p>我曾经在上过“算法设计与分析”课程后，写过相关的文章：<a href="https://coder109.github.io/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">【算法】动态规划</a>。</p><p>简单说来，动态规划这个名字本身没什么特殊的，可能就是某人为了装B而设计的：<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92#%E5%8E%86%E5%8F%B2">动态规划-历史</a>。</p><p>动态规划本身是这样的一种方法：从小的子问题逐步求解，最终求解大的主问题的过程。直接求取这种“主问题”，往往会重复计算子问题，造成不必要的开销，若从子问题求解，并<strong>记住</strong>子问题的结果，就能在求取主问题时，节省大量的开销。</p><p>其步骤大概为：简化原问题-建立递归方程-求解子问题-求解原问题。其中，建立递归方程(建立递推公式)是最重要的一步。</p><p>简单应用可以参考我之前的博文，本文主要记录力扣上几类一维DP问题的思路、求解方法。</p><h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><h2 id="递推公式：主问题和子问题有明显联系"><a href="#递推公式：主问题和子问题有明显联系" class="headerlink" title="递推公式：主问题和子问题有明显联系"></a>递推公式：主问题和子问题有明显联系</h2><p>主问题和子问题通过递推公式连接在一起，可以通过分析题目寻找这种关系。</p><p>对于<a href="https://leetcode.com/problems/climbing-stairs/">Leetcode70. Climbing Stairs</a>：</p><p>主问题不好直接求解，先从小问题考虑：上到第一层有一种走法，第二层有两种走法，那么可以在这个基础上推得：</p><p>单独拿每一层来分析，到达$i$层共有两种方法，从$i-1$层跨一级台阶走上来，或者从$i-2$层跨两级走上来，于是，令$dp[i]$为到达第$i$层的总共方法数，递推公式为：<br>$$<br>dp[i] &#x3D; dp[i-1]+dp[i-2]<br>$$<br>对于<a href="https://leetcode.com/problems/pascals-triangle/">Leetcode118. Pascal’s Triangle</a>，联系已经非常明显了，令$dp[i][j]$为第$i$行第$j$列的元素，递推公式为:<br>$$<br>dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]<br>$$</p><h2 id="递推公式：主问题和部分子问题有明显联系"><a href="#递推公式：主问题和部分子问题有明显联系" class="headerlink" title="递推公式：主问题和部分子问题有明显联系"></a>递推公式：主问题和部分子问题有明显联系</h2><p>主问题有时无法直接使用DP，需要拆分成部分子问题，对于这些子问题应用DP，最后合并。</p><p>对于<a href="https://leetcode.com/problems/house-robber-ii/">Leetcode213. House Robber II</a>来说，由于最后一个房子和第一个房子是邻接房子，不能直接使用<a href="https://leetcode.com/problems/house-robber/">Leetcode198. House Robber</a>的直接递推DP，需要对于两个子问题进行DP：最终的最大值为不抢最后一个房子的值和不抢第一个房子的值的最大值。用类似Python表示方法来表示递推公式：<br>$$<br>dp[all]&#x3D;max(dp[1:],dp[:-1])<br>$$<br>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], self.helper(nums[<span class="number">1</span>:]), self.helper(nums[:-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        rob1, rob2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            newRob = <span class="built_in">max</span>(rob1 + n, rob2)</span><br><span class="line">            rob1 = rob2</span><br><span class="line">            rob2 = newRob</span><br><span class="line">        <span class="keyword">return</span> rob2</span><br></pre></td></tr></table></figure><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><p>有的时候递推公式并不是很好写出来，但是可以根据相关子问题的模式，获得主问题和子问题的关系，之后用代码实现这种关系即可。大多数问题都属于这样的问题。</p><p>对于<a href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode5. Longest Palindromic Substring</a>最长回文子串问题，可以通过一维DP求解。</p><p>考虑回文串本身是如何构建的：</p><ol><li>奇数长度的回文串，可以看作由中心字母向两边拓展而来，即：”c”-&gt;”aca”-&gt;”bacab”-&gt;”cbacabc”。</li><li>偶数长度的回文串，可以看作由空白字符向两边扩展而来，即：””-&gt;”cc”-&gt;”bccb”-&gt;”dbccbd”。</li></ol><p>用上下文无关文法来表示:<br>$$<br>S\to aSa|bSb|\cdots|zSz|a|b|\cdots|z|\varepsilon<br>$$<br>那么可以使用$dp[i]$记录以$i$结尾的<strong>最长回文子串</strong>的起始索引，这样就相当于表示了现有的一串回文子串，在这个基础上拓展或修改，就可以得到全局的最长回文串：</p><p>一般的，当遍历到$dp[i+1]$时，如果$i+1$处的字符和$dp[i]-1$处相等，则表明可以扩展，让$dp[i+1]$为$dp[i]-1$即可:</p><p><img src="/2023/08/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.jpg"></p><p>若二者不相等，则遍历以$dp[i],dp[i]+1,dp[i]+2,\cdots$起始的所有子串，直到找到回文串。</p><p>可行的C++解法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string a)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = a.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r; l++, r--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[l] != a[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        result += s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; s[dp[i<span class="number">-1</span>] - <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(dp[i<span class="number">-1</span>] - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l, r = i;</span><br><span class="line">                <span class="keyword">for</span>(l = dp[i<span class="number">-1</span>]; l &lt; r; ++l) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(l, r - l + <span class="number">1</span>))) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(l);</span><br><span class="line">            &#125;</span><br><span class="line">            result = (i - dp[i] + <span class="number">1</span>) &gt; result.<span class="built_in">size</span>() ? s.<span class="built_in">substr</span>(dp[i], i-dp[i]+<span class="number">1</span>) : result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim折腾小记</title>
      <link href="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Emacs很好，写一些中小型项目体验还不错，但是写一些Python的小项目时，体验很差。我怎么也配置不好Python的LSP，每次进行代码补全，Emacs都会非常卡顿。</p><p>于是我稍稍尝试了一下Neovim，发现Python的LSP在这上面的表现出色得多。</p><p>我并没有从0开始写Neovim的配置文件，而是在<a href="https://github.com/jdhao/nvim-config">jdhao&#x2F;nvim-config</a>的基础上进行修改，这个配置已经很出色了，很好看，lsp、git之类的功能实现得也很完善。但是和我想要的体验还有一点点差距。</p><h1 id="1-美化"><a href="#1-美化" class="headerlink" title="1. 美化"></a>1. 美化</h1><p>用惯了Emacs下的<code>dashboard</code>，我还是喜欢在编辑器启动的时候显示一些有用的信息：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/1.png"></p><p>于是通过<code>startup-nvim</code>配置主界面，大概效果如下：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/2.png"></p><p>此外，原配置每次启动都会随机使用一套主题，有的主题很丑，修改<code>core/colorschemes.lua</code>中的随机生成主题函数，发现其从一个数组中选取主题，让该数组中只有一个主题即可。(lua？一点都不会！只能用这种愚蠢的办法了～)</p><h1 id="2-更人性化的括号处理"><a href="#2-更人性化的括号处理" class="headerlink" title="2. 更人性化的括号处理"></a>2. 更人性化的括号处理</h1><p>在Emacs上，当打出一个左大括号，按下回车，会自动补全另一个大括号，并且会自动换行，最终这个样子：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/3.png"></p><p>然而在Neovim上，编辑器只会补全大括号，而不换行：</p><p><img src="/2023/08/14/Neovim%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/4.png"></p><p>这样太难受了，通过修改配置文件<code>core/options.vim</code>让表现和Emacs下一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;Esc&gt;ko&lt;Tab&gt;</span><br><span class="line">imap &#125;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;Esc&gt;ko</span><br></pre></td></tr></table></figure><h1 id="3-更多的语言支持"><a href="#3-更多的语言支持" class="headerlink" title="3. 更多的语言支持"></a>3. 更多的语言支持</h1><p>除去Python，我偶尔还会用OCaml、rust等语言写一些小项目。</p><p>照猫画虎在<code>lua/config/lsp.lua</code>中将其它的Language Server安装上即可。不得不说，在Neovim上配置lsp实在是简单，也不会碰见什么奇奇怪怪的问题。</p><p>接着在<code>lua/plugins.lua</code>中安装<code>codeium</code>AI补全工具，基本上就万事大吉了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>配置Emacs、Linux、Neovim，的确很有趣，但是也很费时间，有些东西我实在实在懒得配置了。</p><p>写JS，HTML之类的东西还得用VSCode，写Java还得用IDEA，最终感觉，这一切都是工具而已，结果要比工具重要得多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Neovim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】链表相关</title>
      <link href="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环形链表的判别"><a href="#1-环形链表的判别" class="headerlink" title="1. 环形链表的判别"></a>1. 环形链表的判别</h1><p>常用于判断链表是否有环的问题，拿可解<a href="https://leetcode.com/problems/linked-list-cycle/">Leetcode141. Linked List Cycle</a>举例子，对于如下的链表：</p><p><img src="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/1.png"></p><p>判断是否有环有两种方法：</p><ol><li>哈希表。从头开始遍历，若碰见遍历过的节点，就返回“有环”；若碰见未遍历过的节点，就将之加入哈希表；若碰见空指针，就返回“无环”。</li><li>从头开始遍历，设立两个指针，一个慢指针指向头节点，一次遍历一个节点，一个快指针指向头节点的下一个节点，一次遍历两个节点，二者若指向同一节点，就返回有环，若二者其中之一碰到空指针，就返回无环。</li></ol><p>Java的哈希表更好用一些，第一种方法的Java解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashMap&lt;ListNode, Integer&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.getOrDefault(head, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                myMap.put(head, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于快慢指针法，为什么两个指针一定能相遇呢？普遍的环形链表结构如下：</p><p><img src="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/2.png"></p><p>此时，设慢指针走了$x+k$步，那么快指针便走了$2x+2k+1$步(记得算上二者初始差的一步)假设二者无法相遇，则表明：<br>$$<br>x+k+n(y+1)&#x3D;2x+2k+1,n\in Z^+<br>$$<br>中的$k$无解，显然：<br>$$<br>k&#x3D;n(y+1)-x-1,n\in Z^+<br>$$<br>是一个解，那么假设不成立，二者可以相遇。</p><p>对于无环链表，显然快慢指针无法相遇。</p><p>快慢指针C++解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1-5-环形入口的搜索"><a href="#1-5-环形入口的搜索" class="headerlink" title="1.5 环形入口的搜索"></a>1.5 环形入口的搜索</h1><p>将上面的$k$解带入$y$快指针走过的距离：<br>$$<br>s_{total} &#x3D; 2x+2k+1 &#x3D; 2n(y+1)-1<br>$$<br>可以求出快指针在环内走过的距离：<br>$$<br>s_{cycle} &#x3D; 2n(y+1)-1-x<br>$$<br>快指针距离环形入口的距离为$x+1$。</p><p>若想让快慢指针相遇在环形入口处，则需要先让快指针走一个节点，然后将慢指针放回头节点，接着让二者向前遍历，相遇点则为环形入口。</p><p>可解<a href="https://leetcode.com/problems/linked-list-cycle-ii/">Leetcode142. Linked List Cycle II</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-基本的插入-x2F-删除-x2F-反转-x2F-合并问题"><a href="#2-基本的插入-x2F-删除-x2F-反转-x2F-合并问题" class="headerlink" title="2. 基本的插入&#x2F;删除&#x2F;反转&#x2F;合并问题"></a>2. 基本的插入&#x2F;删除&#x2F;反转&#x2F;合并问题</h1><p>在纸上画一画就好，仔细捋清楚节点具体该如何变换、该返回哪个节点、先做什么再做什么。</p><p>比如反转链表：<a href="https://leetcode.com/problems/reverse-linked-list/">Leetcode206. Reverse Linked List</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">            next = (next == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，利用STL本身的性质解题，往往事半功倍，比如<a href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode23. Merge k Sorted Lists</a>，利用<code>map</code>底层的红黑树性质解题，速度很快：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* node : lists) &#123;</span><br><span class="line">            ListNode* temp = node;</span><br><span class="line">            <span class="keyword">while</span>(temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                dict[temp-&gt;val]++;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = dict.<span class="built_in">begin</span>(); iter != dict.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            <span class="type">int</span> key = iter-&gt;first;</span><br><span class="line">            <span class="type">int</span> val = iter-&gt;second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; val; ++i) &#123;</span><br><span class="line">                ListNode* neo = <span class="keyword">new</span> <span class="built_in">ListNode</span>(key);</span><br><span class="line">                curr-&gt;next = neo;</span><br><span class="line">                curr = neo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-5-隐藏的成环可能"><a href="#2-5-隐藏的成环可能" class="headerlink" title="2.5 隐藏的成环可能"></a>2.5 隐藏的成环可能</h1><p>对于<a href="https://leetcode.com/problems/reorder-list/">Leetcode143. Reorder List</a>，完全可以用一个<code>vector</code>记录遍历过的结点，然后根据索引规律排列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt; memo;</span><br><span class="line">        ListNode* ptr = head;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            memo.<span class="built_in">push_back</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = memo.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        ListNode* curr = ptr;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">                curr-&gt;next = memo[l++];</span><br><span class="line">                <span class="comment">//curr = curr-&gt;next;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr-&gt;next = memo[l++];</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = memo[r--];</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//curr-&gt;next = nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解注释所有注释的语句，可以通过检验。</p><p>注释掉的语句的作用是：让遍历到的最后一个节点的下一个节点为空，若不空，则链表会成环，会报类似错误：</p><blockquote><p>&#x3D;&#x3D;22&#x3D;&#x3D;ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000000b8 at pc 0x00000038b12d bp 0x7ffda25fd140 sp 0x7ffda25fd138</p></blockquote><p>猜测，可能的原因为，析构<code>ListNode</code>时，是逐个遍历析构的，若成环，则会析构已经析构的节点，报错。</p><h1 id="3-深拷贝问题"><a href="#3-深拷贝问题" class="headerlink" title="3. 深拷贝问题"></a>3. 深拷贝问题</h1><p>所谓深拷贝(deep copy)，就是:</p><blockquote><p>A <strong>deep copy</strong> of an object is a copy whose properties do  not share the same references (point to the same underlying values) as  those of the source object from which the copy was made. </p><p>一个对象的深拷贝是一种拷贝，其属性值与原对象相等，但是不与原对象共享引用。</p><p>——<a href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy">MDN Web Docs</a></p></blockquote><p>简单来说，就是两个一模一样的对象，分布在不同的内存空间中。本问题对应<a href="https://leetcode.com/problems/copy-list-with-random-pointer/">Leetcode138. Copy List with Random Pointer</a>。</p><p>如果本题链表节点类没有<code>random</code>成员，那么逐个遍历就行。有<code>random</code>，就需要用某种数据结构记忆新旧节点之间的对应关系——哈希表：先复制<code>next</code>关系，将全部节点放置入表；接着复制<code>random</code>关系即可。</p><p>一种可行的C++解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        map&lt;Node*, Node*&gt; dict;</span><br><span class="line">        Node* result = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        Node* neo_head = result;</span><br><span class="line">        Node* memo = head;</span><br><span class="line">        dict[head] = neo_head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node* curr = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            neo_head-&gt;next = curr;</span><br><span class="line">            neo_head = neo_head-&gt;next;</span><br><span class="line">            dict[head] = neo_head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = memo;</span><br><span class="line">        neo_head = result;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            neo_head-&gt;random = dict[head-&gt;random];</span><br><span class="line">            neo_head = neo_head-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">count</span>(head))</span><br><span class="line">      <span class="keyword">return</span> map[head];</span><br><span class="line"></span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">    map[head] = newNode;</span><br><span class="line">    newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">    newNode-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】旋转数列</title>
      <link href="/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E5%88%97/"/>
      <url>/2023/08/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h1><blockquote><p>这东西和动态规划一样令人作呕。</p></blockquote><p>旋转数列一般为旋转排序数列(Rotated Sorted Array)，和它有关的问题有很多，比如<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Leetcode153. Find Minimum in Rotated Sorted Array</a>、<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Leetcode33. Search in Rotated Sorted Array</a>。</p><p>旋转数列的定义为，对于给定数列$a_1,a_2,\cdots,a_n$，其以$k,k\in[1,n]$为中心旋转得到的数列为$a_k,a_{k+1},\cdots,a_{k-1}$。</p><p>这种数列，记作$num$，有这样几条性质：</p><ol><li><p>最左端元素大于最右端元素，即$num[left] \geq num[right]$。</p></li><li><p>$num$可沿着分界点$a_n$分为两个排序的数列，$a_k,a_{k+1},\cdots,a_n$和$a_1,a_2,\cdots,a_{k-1}。$</p></li></ol><p>几乎所有问题都围绕这两条性质展开，我将讨论比较有代表性的几个问题。</p><h1 id="无重复值：分界点的确定"><a href="#无重复值：分界点的确定" class="headerlink" title="无重复值：分界点的确定"></a>无重复值：分界点的确定</h1><p>该问题等价于寻找$a_n$，也等价于在旋转数列中寻找最大值&#x2F;最小值的问题。</p><p>根据上面的第二条性质，可以发现，分界点处的值为左半数列最大值，其右侧的值为右半数列最小值。那么，这个问题可以很简单地通过二分搜索求解，判断中间值是否小于右指针处的值即可，分类讨论二者关系：</p><ol><li>若大于，则表明中间值目前处于左半数列，需要让左端指针右移。</li><li>若小于，则表明其处于右半数列中，需要右端指针左移，但不能移动到<code>mid-1</code>，否则会导致搜索范围完全落在左半数列，无法求出正确的解。</li><li>若二者相等，则表明左右端指针都必然指向同一位置，实际上表明搜索其实已经结束了，此时可以选择让左指针右移跳出循环，也可以选择直接返回。</li></ol><p>根据循环条件，退出循环时，左指针必然大于右指针，指向的是右侧数列的第二个元素或<code>nums.size()</code>，而右侧指针指向右侧数列的第一个元素，也就是旋转数列的最小值。</p><p>于是，我们可以解出<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Leetcode153. Find Minimum in Rotated Sorted Array</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么不和左指针的值比较呢？因为当数列不旋转时，左半数列并不存在；而不论如何右半数列必然存在。和左侧指针的值作比较，很有可能出bug，解法也不如上面的方法优雅简单。</p><h1 id="有重复值：分界点的确定"><a href="#有重复值：分界点的确定" class="headerlink" title="有重复值：分界点的确定"></a>有重复值：分界点的确定</h1><p>这种状况对应<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">Leetcode154. Find Minimum in Rotated Sorted Array II</a>。</p><p>我自己的解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本思想为，碰到重复的，就逐步缩小搜索区域。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】回溯法</title>
      <link href="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>回溯(Backtrack)是一种搜索方法，常用于排列问题、搜索问题的求解。其基本思想为DFS(Depth-First Search)：分步求解，步步为营，一旦探索完该状态的所有可能性，就回退到前一个状态。</p><p>回溯算法的模板大概如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(vector&lt;T&gt;&amp; record, vector&lt;T&gt;&amp; temp, vector&lt;T&gt; choices...)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">IsTerminate</span><span class="params">(temp)</span> </span>&#123;</span><br><span class="line">            record.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(T choice : choices) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">IsLegal</span>(choice)) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(choice);</span><br><span class="line">                <span class="built_in">Backtrack</span>(record, temp, choices);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>(choice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;T&gt; <span class="title">Solve</span><span class="params">(vector&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">        vector&lt;T&gt; record;ge shu</span><br><span class="line">        vector&lt;T&gt; temp;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">Backtrack</span>(record, temp, choices, ...);</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回溯函数里，首先判断是否为终止状态，若是，则将临时状态加入最终结果，若否，则遍历所有的可行选择，加入临时状态，接着继续回溯，等待回溯完成，将选择从临时状态中删除。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>回溯可以应用于排列问题，比如说<a href="https://leetcode.com/problems/permutations/">Leetcode 46. Permutations</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; curr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; answ, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            answ.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(curr.<span class="built_in">begin</span>(), curr.<span class="built_in">end</span>(), num) == curr.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="built_in">backtrack</span>(curr, answ, nums);</span><br><span class="line">                curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">backtrack</span>(curr, result, nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回溯函数中，先判断是否为一个可行的全排列，若是，则将其加入结果列表，否则就挑选合适的数字加入临时状态，挑选的判据为该数字是否已经出现过。</p><p>也可以应用于搜索问题上，比如<a href="https://leetcode.com/problems/all-paths-from-source-to-target/">Leetcode 797. All Paths From Source to Target</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> curr_node, vector&lt;<span class="type">int</span>&gt;&amp; curr_vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr_node == graph.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(curr_vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> node : graph[curr_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(curr_vec.<span class="built_in">begin</span>(), curr_vec.<span class="built_in">end</span>(), node) == curr_vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                curr_vec.<span class="built_in">push_back</span>(node);</span><br><span class="line">                <span class="built_in">backtrack</span>(result, graph, node, curr_vec);</span><br><span class="line">                curr_vec.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp_vec;</span><br><span class="line">        temp_vec.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(result, graph, <span class="number">0</span>, temp_vec);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回溯也可以变得很复杂，比如有<a href="https://leetcode.com/problems/generate-parentheses/">Leetcode 22. Generate Parentheses</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ( - +1 ) - -1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(vector&lt;string&gt;&amp; result, <span class="type">int</span> n, string&amp; curr, <span class="type">int</span> l_num, <span class="type">int</span> r_num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l_num == r_num) &#123;</span><br><span class="line">            curr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">Backtrack</span>(result, n, curr, l_num+<span class="number">1</span>, r_num);</span><br><span class="line">            curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l_num == n) &#123;</span><br><span class="line">            curr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">Backtrack</span>(result, n, curr, l_num, r_num+<span class="number">1</span>);</span><br><span class="line">            curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l_num &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l_num == r_num) &#123;</span><br><span class="line">                curr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="built_in">Backtrack</span>(result, n, curr, l_num+<span class="number">1</span>, r_num);</span><br><span class="line">                curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="built_in">Backtrack</span>(result, n, curr, l_num+<span class="number">1</span>, r_num);</span><br><span class="line">                curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                curr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="built_in">Backtrack</span>(result, n, curr, l_num, r_num+<span class="number">1</span>);</span><br><span class="line">                curr = curr.<span class="built_in">substr</span>(<span class="number">0</span>, curr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string now = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">Backtrack</span>(result, n, now, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>生成括号时，合法性判据为已经生成的左右括号个数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】单调栈</title>
      <link href="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>单调栈(Monotonic Stack)严格来说是一种数据结构，常用于求解这样的问题：在一个数组中，对每一个元素，寻找下一个比它大&#x2F;小的元素。显然，它有两种：单调递增栈(Monotonic Increasing Stack)和单调递减栈(Monotonic Decreasing Stack)。</p><p>举一个单调递增栈的例子，一个数组的单调递增栈用如下方法构造：从左向右遍历数组，将新元素压栈时，判断栈顶元素是否比新元素大，如果栈顶元素更大，则弹栈，否则将新元素压栈。</p><p>对于数组：<code>1,3,2,4,7</code>来说，其单调栈构造过程如下：</p><ol><li><code>1</code>。</li><li><code>1,3</code>。</li><li><code>1,2</code>，栈顶元素3比2大，先弹栈再将2入栈。</li><li><code>1,2,4</code>。</li><li><code>1,2,4,7</code>。</li></ol><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>本题为经典的<a href="https://leetcode.com/problems/trapping-rain-water/">Leetcode 42. Trapping Rain Water</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mono_stack;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono_stack.<span class="built_in">empty</span>() &amp;&amp; height[mono_stack.<span class="built_in">top</span>()] &lt; height[i])&#123;</span><br><span class="line">                <span class="type">int</span> top = mono_stack.<span class="built_in">top</span>();</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(mono_stack.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> length = i - mono_stack.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> high = <span class="built_in">min</span>(height[mono_stack.<span class="built_in">top</span>()], height[i]) - height[top];</span><br><span class="line">                result += length * high;</span><br><span class="line">            &#125;</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题写了蛮久，其思想基本上就是，从左向右遍历数组，维护一个单调递减栈，只要遍历到了一个比栈顶元素大的元素，就代表有可能形成一个可以装雨水的凹形容器。这时，凹形容器的右边就是当前遍历到的高度，栈顶元素表示凹形的低点，然后弹栈，接着，栈顶元素表示凹形的左侧。</p><p>举个例子：</p><p><img src="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/1.png"></p><p>当遍历到索引4的时候，栈顶是索引3,是凹点，所以计算的水的体积是橘色部分：</p><p><img src="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/2.png"></p><p>接着弹栈，栈顶是索引2，是凹点，所以计算的水的体积是黑色部分：</p><p><img src="/2023/08/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/3.png"></p><p>这样就计算出了一个不规则凹形中所能容纳雨水的体积。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】KMP算法</title>
      <link href="/2023/08/09/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/09/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>KMP算法，也叫做Knuth-Morris-Pratt算法，是常见的字符串匹配算法，效率很高，能在$O(n)$复杂度内求解字符串匹配问题。</p><p>我自己用C语言大概写过三四回KMP算法，每次都有大大小小的bug。这次我就来好好捋一捋KMP算法的原理。</p><h1 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h1><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TrivialMatch</span><span class="params">(string pattern, string text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pattern_len = pattern.length;</span><br><span class="line">    <span class="type">int</span> text_len = text.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> text_p = <span class="number">0</span>; text_p &lt;= text_len - pattern_len; text_p++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pattern_p = <span class="number">0</span>; pattern_p &lt; pattern_len; pattern_p++) &#123;</span><br><span class="line">            <span class="comment">// Check one by one</span></span><br><span class="line">            <span class="keyword">if</span> (pattern[pattern_p] != text[text_p + pattern_p])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If all matched</span></span><br><span class="line">        <span class="keyword">if</span> (pattern_p == pattern_len) <span class="keyword">return</span> text_p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法时间复杂度为$O(mn)$，其中$m,n$分别为文本和模式子串的长度。</p><p>用动画(来自<a href="https://segmentfault.com/a/1190000022642180">https://segmentfault.com/a/1190000022642180</a>)表示出来就是这样的：</p><p><img src="/2023/08/09/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/1.webp"></p><h1 id="简短的分析"><a href="#简短的分析" class="headerlink" title="简短的分析"></a>简短的分析</h1><p>该方法的缺点是，不论在文本串还是模式子串上，二者的指针都会回退，有没有什么方法不让指针回退呢？</p><p>匹配失败的时候，模式子串的指针必须回退，那么可不可以让文本串的指针不回退，尽可能少地回退模式串的指针呢？KMP算法便是应用这种思想的一种算法。</p><p>具体怎么应用？试想一下，进行如下的匹配时：</p><p><img src="https://pic4.zhimg.com/80/v2-bcb634c9d7b2eeb2d4886bf549f0acdb_720w.webp" alt="img"></p><p><code>B</code>和<code>D</code>不匹配，但是我们知道前面的<code>ABACABA</code>已经匹配上了，而且其具有<strong>最长的、相等的</strong>前缀后缀<code>ABA</code>。如何最小程度回退模式串的指针？我们可以让模式串的指针回退到<code>C</code>，因为只有回退到<code>C</code>，才能保证模式串指针之前的部分和文本串匹配：</p><p><img src="https://pic4.zhimg.com/80/v2-5769d470eda95bc7a8bbf60b31ba3f8b_720w.webp" alt="img"></p><p>应用如上原理：</p><p><img src="https://pic1.zhimg.com/80/v2-5f591a07ff5f071351337006bc842f80_720w.webp" alt="img"></p><p>OK，如何实现？</p><h1 id="KMP算法-next数组的计算"><a href="#KMP算法-next数组的计算" class="headerlink" title="KMP算法: next数组的计算"></a>KMP算法: next数组的计算</h1><p>next数组，就是用来记录模式子串的、每个位置对应的最长前缀后缀的数组。</p><p>C++实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">CalculateNext</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; next &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> prefix_length = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pointer_pattern = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(pointer_pattern &lt; pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern[pointer_pattern] == pattern[prefix_length]) &#123;</span><br><span class="line">      next.<span class="built_in">push_back</span>(++prefix_length);</span><br><span class="line">      pointer_pattern++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(prefix_length == <span class="number">0</span>) &#123;</span><br><span class="line">next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">pointer_pattern++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prefix_length = next[prefix_length - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设立两个变量，一个用来记录当前最长的前缀长，一个用来遍历模式子串。若二者对应的字符相等，则二者都加一，并让此时的next数组值为最长的前缀长；若不相等，当最长前缀长为0，说明第一个字符和此时的字符不等，直接让next数组值为0，否则，让最长前缀长等于前一个字符的最长前缀长，由于长度和索引的不等关系，该方法能合理的移动标尺——Quite hard to understand.</p><p>可以手动推一推。</p><h1 id="KMP算法：-匹配过程"><a href="#KMP算法：-匹配过程" class="headerlink" title="KMP算法： 匹配过程"></a>KMP算法： 匹配过程</h1><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(string text, string pattern)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">CalculateNext</span>(pattern);</span><br><span class="line">  <span class="type">int</span> pointer_pattern = <span class="number">0</span>, pointer_text = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((text.<span class="built_in">size</span>() - pointer_text) &gt;= (pattern.<span class="built_in">size</span>() - pointer_pattern))&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern[pointer_pattern] == text[pointer_text]) &#123;</span><br><span class="line">      pointer_pattern++;</span><br><span class="line">      pointer_text++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pointer_pattern == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pointer_text &lt; text.<span class="built_in">size</span>() &amp;&amp; pattern[pointer_pattern] != text[pointer_text]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pointer_pattern != <span class="number">0</span>) &#123;</span><br><span class="line">pointer_pattern = next[pointer_pattern - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pointer_text++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这算是一种比较繁琐，但是比较清晰的实现方法。先计算模式串的next数组，然后匹配，<code>while</code>里的条件是判断文本串剩下的长度是否不少于模式串剩下的长度，防止可能出现的溢出。接着，就按照上面提到的方法实现即可。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>本题为<a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375:【模板】KMP 字符串匹配</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">CalculateNext</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix_length = <span class="number">0</span>, pattern_p = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(pattern_p &lt; pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pattern[pattern_p] == pattern[prefix_length]) &#123;</span><br><span class="line">            next.<span class="built_in">push_back</span>(++prefix_length);</span><br><span class="line">            pattern_p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix_length == <span class="number">0</span>) &#123;</span><br><span class="line">                next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                pattern_p++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix_length = next[prefix_length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    string text, pattern;</span><br><span class="line">    cin &gt;&gt; text &gt;&gt; pattern;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">CalculateNext</span>(pattern);</span><br><span class="line">    <span class="type">int</span> text_p = <span class="number">0</span>, pattern_p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(text_p &lt; text.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(text[text_p] == pattern[pattern_p]) &#123;</span><br><span class="line">            text_p++;</span><br><span class="line">            pattern_p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern_p == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; text_p - pattern_p + <span class="number">1</span>&lt;&lt; endl;</span><br><span class="line">            pattern_p = next[pattern_p - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(text_p &lt; text.<span class="built_in">size</span>() &amp;&amp; text[text_p] != pattern[pattern_p]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pattern_p == <span class="number">0</span>) &#123;</span><br><span class="line">                text_p++;    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pattern_p = next[pattern_p - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> border : next) &#123;</span><br><span class="line">        cout &lt;&lt; border &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】C++的map如何按值排序</title>
      <link href="/2023/08/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91map%E5%A6%82%E4%BD%95%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/08/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91map%E5%A6%82%E4%BD%95%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><code>map</code>自定义是按照键排序的，有些时候需要按照值排序，比如说这道题：<a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a>。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>使用<code>vector</code>和自定义排序函数结合的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; anti_record;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = record.<span class="built_in">begin</span>(); iter != record.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    anti_record.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(iter-&gt;first, iter-&gt;second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(anti_record.<span class="built_in">begin</span>(), anti_record.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br></pre></td></tr></table></figure><p>更清楚一些：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; anti_record;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = record.<span class="built_in">begin</span>(); iter != record.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    anti_record.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(iter-&gt;first, iter-&gt;second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(anti_record.<span class="built_in">begin</span>(), anti_record.<span class="built_in">end</span>(), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>引子中的题解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            record[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; anti_record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = record.<span class="built_in">begin</span>(); iter != record.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            anti_record.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(iter-&gt;first, iter-&gt;second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(anti_record.<span class="built_in">begin</span>(), anti_record.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">        <span class="keyword">auto</span> iter = anti_record.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>((*iter++).first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heavy Wave</title>
      <link href="/2023/08/08/Heavy-Wave/"/>
      <url>/2023/08/08/Heavy-Wave/</url>
      
        <content type="html"><![CDATA[<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>我梦见自己的心脏被另一个我扯出来，他将之放在我面前，任我看着那一团红色的秽物跳动。</p><p>此刻的我知道自己在做梦，我也知道梦的神将要觉察我的觉知，将我踢出梦境。每次都这样，梦的神不会允许清醒的人出现在梦里，梦境是疯癫之人的无何有之乡。只有疯子才能做出色彩斑斓的梦来，理智的人的梦是灰暗的，他们的激情早已被吞噬，化作虚无。</p><p>我此时就看着我自己的心脏跳动，我无比欣喜。我能看见从血管出泵出鲜血，滴落在地面上。</p><p>失掉心脏的人终究要死么？我不知道，这世上似乎有好多没有心脏的人，依旧活得开开心心，而有心脏的人，却遍体鳞伤。</p><p>于是我问那一个自己，“你可有心脏？”，他不作声。</p><h1 id="信仰"><a href="#信仰" class="headerlink" title="信仰"></a>信仰</h1><p>高中的时候曾经看过一段时间有关<a href="https://zh.wikipedia.org/wiki/%E9%BB%83%E9%87%91%E9%BB%8E%E6%98%8E%E5%8D%94%E6%9C%83">“黄金黎明(Ordo Hermeticus Aurorae Aureae)”</a>的文章，也读过一点圣经。当时的自己真的蛮相信世界上有神，还学了一点使用灵摆、塔罗牌占卜的方法。可后来，逐渐的，也了解了一些“上帝悖论”，自己也就不再信神了。圣经里的很多故事很有趣，当成小说来看也蛮有意思。</p><p>后来读了尼采和一系列后现代哲学家的理论，所存的一点信仰也消解了。现在很难说自己还相信什么——我现在所信仰的貌似就是信仰缺位带来的匮乏。我信仰追求信仰的过程。</p><p>人们信仰什么都无所谓，也都没有错。</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>自己白白浪费了好多时间。</p><p>编程真的蛮有意思——自己写一些有趣的东西。自己写东西不必遵循代码规范之类的东西，尽管写就好了。</p><p>曾经教我数理逻辑的老师，在Ubuntu 12.04系统上，使用自己编写的幻灯片放映软件授课，据说编程语言是Lua-JIT，编辑器是Emacs。</p><p>曾经教我CSAPP的老师，使用汇编写了许多有意思的小工具。</p><p>上他们的课，和他们交流，带给我的感受，如同《黑客》这本书带给我的感受一样——Just for fun。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>从现在开始学习吧。我知道自己一旦闲下来，就会胡思乱想，而胡思乱想不利于稳定我的精神。</p><p>尽我所能，学好数学，提升编程相关的水平，学好英语，学一学法语。</p><p>我不愿长久驻留于此。我除了学习，没什么可做的了。</p><h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>我仍无法摆脱家庭带给我的压抑与恐惧。物质生活毫不匮乏，而精神上恣意打压。我想，若我出生在一个开明一些的家庭里，我也不至于像现在这样内向、自卑、神经质。我时刻都感觉自己快要疯掉——正常人谁读哲学呀！我感觉自己脑子里有些东西快要坏掉了，我只能拼命的维持它脆弱的正常状态。好事！我还蛮正常！</p><p>我没办法从根本上解决这个问题，我这一代的父母大多都这样——也算是一种时代烙印了。我尝试去改变我自己，我不能变得像他们那样。</p><p>Just run, run away.</p><p>其实这种压抑与恐惧倒也不是完全的坏事——至少，我对恐惧的耐受度要高一些了。我有什么好怕的呢:)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二分查找的相关细节</title>
      <link href="/2023/08/07/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82/"/>
      <url>/2023/08/07/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>二分查找是一种高效的搜索算法，常用于有序结构的搜索。</p><p>二分查找也是分治法(Divide and Conquer)的一个经典实例：在一个长度为$n$的数组中进行二分查找，其复杂度是$O(logn)$，这是因为二分查找每一次都筛选掉一半搜索区间长度的元素，其递推公式为:<br>$$<br>T(n)&#x3D;\frac{1}{2}T(\frac{n}{2})+O(1)<br>$$<br>可根据主定理(Master Theorem)求解。</p><h1 id="1-经典的二分查找"><a href="#1-经典的二分查找" class="headerlink" title="1. 经典的二分查找"></a>1. 经典的二分查找</h1><p>简单的测试程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; my_vector;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">    my_vector.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = my_vector.<span class="built_in">size</span>() - <span class="number">1</span>, target = <span class="number">19</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(my_vector[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(my_vector[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Find Target At&quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Left: &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot; Right: &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Left: &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot; Right: &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code>循环里的条件一般是<code>left &lt;= right</code>而非<code>left &lt; right</code>。为什么常用前者？让我们看看输出：</p><p>按照程序里的模式，如果将等号省略，输出为：</p><blockquote><p>Left: 10 Right: 19</p><p>Left: 15 Right: 19</p><p>Left: 18 Right: 19</p><p>Left: 19 Right: 19</p><p>Left: 19 Right: 19</p></blockquote><p>不省略等号，输出为：</p><blockquote><p>Left: 10 Right: 19</p><p>Left: 15 Right: 19</p><p>Left: 18 Right: 19</p><p>Left: 19 Right: 19</p><p>Find Target At 19</p><p>Left: 19 Right: 19</p></blockquote><p>搜索21时，省略等号的输出为：</p><blockquote><p>Left: 10 Right: 19<br>Left: 15 Right: 19<br>Left: 18 Right: 19<br>Left: 19 Right: 19<br>Left: 19 Right: 19</p></blockquote><p>不省略等号的输出为：</p><blockquote><p>Left: 10 Right: 19<br>Left: 15 Right: 19<br>Left: 18 Right: 19<br>Left: 19 Right: 19<br>Left: 20 Right: 19<br>Left: 20 Right: 19</p></blockquote><p>当元素存在时：</p><p>省略等号，则当<code>left</code>和<code>right</code>相等时，直接退出循环，<code>break</code>存在与否都无所谓，程序不会陷入死循环。</p><p>不省略等号，则当<code>left</code>和<code>right</code>相等时，输出提示信息，这时如果不加<code>break</code>，程序将死循环。</p><p>这对应着两种需求。前者适用于只要元素下标的情况，比如一维数组的搜索，后者不仅适用于前者的情况，也适用于需要在获取下标的基础上，另外进行一些操作的情况，比如在二维数组中搜索某元素，先搜索列，再搜索行。所以常常使用<code>left &lt;= right</code>的格式。</p><p>当元素不存在时：</p><p>二者的差别仅在于最后<code>left</code>和<code>right</code>的值。省略等号，二者相等，不省略等号，<code>left</code>大于<code>right</code>，且<code>left</code>和<code>right</code>的差为1。</p><p>二分查找的灵活性很强，比如<a href="https://leetcode.com/problems/search-a-2d-matrix/">Leetcode 74. Search a 2D Matrix</a>，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = matrix.<span class="built_in">size</span>() * col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> ele = matrix[mid / col][mid % col];</span><br><span class="line">            <span class="keyword">if</span>(ele &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ele == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-寻找左右边界的二分查找"><a href="#2-寻找左右边界的二分查找" class="headerlink" title="2. 寻找左右边界的二分查找"></a>2. 寻找左右边界的二分查找</h1><p>在递增数组中寻找左边界的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> border1 = left;</span><br></pre></td></tr></table></figure><p>所谓左边界，就是某元素第一次出现的位置，若中间值大于等于目标值，就让右指针左移，略去的值大多都不是元素第一次出现的位置。如果略去了元素第一次出现的位置怎么办呢？可以通过左指针来弥补，因为右指针最远也只能挪移到，元素第一次出现的位置的左侧一格，而最终左指针必然等于右指针指向的值加1，这时左指针必然指向元素第一次出现的位置。</p><p>那么寻找右边界的代码也好写啦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> border2 = right;</span><br></pre></td></tr></table></figure><p>这样我们也就快解出了<a href="https://leetcode.com/problems/find-target-indices-after-sorting-array/">Leetcode 2089. Find Target Indices After Sorting Array</a>。</p><p>该题的C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">targetIndices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> border1 = left;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = border1; i &lt; left; ++i) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似的，也有<a href="https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/">Leetcode 2529. Maximum Count of Positive Integer and Negative Integer</a>，该题只需要将问题转换为求0的左右区间即可，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> borderLeft = left;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(borderLeft, (<span class="type">int</span>)nums.<span class="built_in">size</span>() - left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无聊系列】利用Q-Learning玩2048</title>
      <link href="/2023/08/04/%E3%80%90%E6%97%A0%E8%81%8A%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8Q-Learning%E7%8E%A92048/"/>
      <url>/2023/08/04/%E3%80%90%E6%97%A0%E8%81%8A%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8Q-Learning%E7%8E%A92048/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>OK。这回我们换了个模型，从单纯的与或树搜索法换到了强化学习的方法。我之前从来没有研究过强化学习的具体模型，这次正好学习一下。强化学习模拟的是智能体与环境中的交互，通过设立奖励&#x2F;惩罚函数欲求使结果最优化。Q-Learning是强化学习中，相对简单的一个方法。</p><p>Q-Learning的具体信息，请参考<a href="https://zhuanlan.zhihu.com/p/365814943">强化学习入门笔记——Q-learning从理论到实践</a>。</p><h1 id="1-奖励函数的设定"><a href="#1-奖励函数的设定" class="headerlink" title="1. 奖励函数的设定"></a>1. 奖励函数的设定</h1><p>奖励函数和上一章提到的利益函数不一样，前者考虑操作带来的优劣，后者考虑整体地图的优劣。</p><p>人也是智能体，可以根据我们自己玩2048的体验，来设定奖励函数：</p><ol><li>输掉游戏，非常不爽，给-400点奖励。</li><li>合并两个单元格，比较开心，给$log_2(V)$点奖励，其中，$V$是合并前单元格的值。没有合并单元格，有点不爽，给-1点奖励。</li><li>赢得游戏，非常开心，给400点奖励。</li></ol><h1 id="2-具体的算法"><a href="#2-具体的算法" class="headerlink" title="2. 具体的算法"></a>2. 具体的算法</h1><p>我根据这张图实现Q-Learning算法：</p><p><img src="https://pic3.zhimg.com/80/v2-5dffaf220ee0fd1af0686dd3802d214a_720w.webp"></p><p>其中，$\epsilon$为探索系数，表示随机采取动作的概率；$1-\epsilon$就是采取贪心策略的概率，贪心策略就是指，从已经探索出来的所有$Q(s,a)$中，选取奖励最大的动作；$\alpha$是一个参数；$s$代表状态，也就是当前地图；$a$是采取的动作；所谓$\hat{Q}(s,a)$就表示在$s$状态下，采取$a$动作的奖励值；$\gamma$也是一个超参数。</p><h2 id="设置超参数"><a href="#设置超参数" class="headerlink" title="设置超参数"></a>设置超参数</h2><p>所谓超参数(Hyperparameter)，就是一些不随训练改变的参数，比如总的训练次数，训练batch大小，都属于超参数。</p><p>我的超参数设置如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line">map_size = <span class="number">4</span></span><br><span class="line">epsilon = <span class="number">0.42</span></span><br><span class="line">update_step = <span class="number">0.42</span></span><br><span class="line">memory_size = <span class="number">5000000</span></span><br><span class="line">q_pointer = <span class="number">0</span></span><br><span class="line">operations = [<span class="string">&#x27;LEFT&#x27;</span>, <span class="string">&#x27;RIGHT&#x27;</span>, <span class="string">&#x27;UP&#x27;</span>, <span class="string">&#x27;DOWN&#x27;</span>, <span class="string">&#x27;GREEDY&#x27;</span>]</span><br><span class="line">episode = <span class="number">200</span></span><br><span class="line">reward_discount = <span class="number">0.9</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, movement=<span class="literal">None</span>, reward=<span class="number">0</span></span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.movement = movement</span><br><span class="line">        self.reward = reward</span><br><span class="line">q_table: <span class="built_in">list</span>[Strategy] = []</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><code>map_size</code>，地图的长和宽的值。</li><li><code>epsilon</code>，采取随机动作的概率，<code>1-epsilon</code>就表示采取贪心策略的概率。</li><li><code>update_step</code>，更新步长。</li><li><code>memory_size</code>，最多能存放多少个训练出来的$Q(s,a)$。</li><li><code>q_pointer</code>，指向<code>q_table</code>的指针，代表当前最新更新的是哪一个元素。后者是存放$Q(s,a)$的列表。</li><li><code>episode</code>，一共训练多少次。</li><li><code>reward_discount</code>，即上面提到的$\gamma$，一个超参数。</li><li><code>Strategy</code>，记录$Q(s,a)$的类。</li></ol><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>按照上面的伪代码，容易实现出学习的函数框架:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Learn</span>():</span><br><span class="line">    <span class="keyword">global</span> episode, update_step, reward_discount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(episode):</span><br><span class="line">        <span class="comment"># Initialize the map</span></span><br><span class="line">        original_map = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(map_size)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(map_size)]</span><br><span class="line">        game.GenerateTwo(original_map)</span><br><span class="line">        game.GenerateTwo(original_map)</span><br><span class="line">        node = Strategy(original_map, <span class="number">0</span>)</span><br><span class="line">        state = node.state.copy()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Initialize a and Q</span></span><br><span class="line">        reward = <span class="number">0</span></span><br><span class="line">        curr_Q = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Starting episode: &quot;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> game.GameFailed(state) <span class="keyword">and</span> <span class="keyword">not</span> game.GameSuccess(state):</span><br><span class="line">            <span class="comment"># Choose an operation</span></span><br><span class="line">            operation = GetOperation()</span><br><span class="line">            <span class="keyword">if</span> operation == <span class="string">&#x27;GREEDY&#x27;</span>:</span><br><span class="line">                operation = Greedy(state)</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># Get the corresponding state and reward</span></span><br><span class="line">            state, reward = GetStatusAndReward(state, operation)</span><br><span class="line">            game.GenerateTwo(state)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Update Q</span></span><br><span class="line">            curr_Q = curr_Q + update_step * (reward + reward_discount * GetMaxQByStrategy(Strategy(state, operation)) - curr_Q)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Update Q table</span></span><br><span class="line">            UpdateQTable(Strategy(state, operation, reward))</span><br><span class="line">        <span class="comment"># Show result</span></span><br><span class="line">        game.ShowMap(state)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Current Reward: &quot;</span> + <span class="built_in">str</span>(reward))</span><br></pre></td></tr></table></figure><h2 id="获取行动方式"><a href="#获取行动方式" class="headerlink" title="获取行动方式"></a>获取行动方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetOperation</span>():</span><br><span class="line">    rand_num = random.uniform(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> rand_num &lt; epsilon * <span class="number">100</span>:</span><br><span class="line">        rand_num = random.randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> operations[rand_num]</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;GREEDY&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Greedy</span>(<span class="params">state</span>):</span><br><span class="line">    temp_operation = <span class="string">&#x27;LEFT&#x27;</span></span><br><span class="line">    temp_max_reward = -sys.maxsize</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q_table)):</span><br><span class="line">        <span class="keyword">if</span> q_table[i].state == state:</span><br><span class="line">            <span class="keyword">if</span> q_table[i].reward &gt; temp_max_reward:</span><br><span class="line">                temp_max_reward = q_table[i].reward</span><br><span class="line">                temp_operation = q_table[i].movement</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> temp_operation</span><br></pre></td></tr></table></figure><h2 id="奖励的计算"><a href="#奖励的计算" class="headerlink" title="奖励的计算"></a>奖励的计算</h2><p>可以通过分数的增量来模拟合并单元格带来的奖励：获取分数的增量，之后取以2为底的对数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetStatusAndReward</span>(<span class="params">original_map, operation</span>):</span><br><span class="line">    <span class="built_in">map</span> = original_map.copy()</span><br><span class="line">    bonus = <span class="number">0</span></span><br><span class="line">    delta = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operation == <span class="string">&#x27;LEFT&#x27;</span>:</span><br><span class="line">        <span class="built_in">map</span>, neo_bonus = game.MoveLeft(<span class="built_in">map</span>, bonus)</span><br><span class="line">        delta = neo_bonus - bonus</span><br><span class="line">    <span class="keyword">elif</span> operation == <span class="string">&#x27;RIGHT&#x27;</span>:</span><br><span class="line">        <span class="built_in">map</span>, neo_bonus = game.MoveRight(<span class="built_in">map</span>, bonus)</span><br><span class="line">        delta = neo_bonus - bonus</span><br><span class="line">    <span class="keyword">elif</span> operation == <span class="string">&#x27;UP&#x27;</span>:</span><br><span class="line">        <span class="built_in">map</span>, neo_bonus = game.MoveUp(<span class="built_in">map</span>, bonus)</span><br><span class="line">        delta = neo_bonus - bonus</span><br><span class="line">    <span class="keyword">elif</span> operation == <span class="string">&#x27;DOWN&#x27;</span>:</span><br><span class="line">        <span class="built_in">map</span>, neo_bonus = game.MoveDown(<span class="built_in">map</span>, bonus)</span><br><span class="line">        delta = neo_bonus - bonus</span><br><span class="line">    <span class="keyword">if</span> game.GameFailed(<span class="built_in">map</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>, <span class="number">400</span></span><br><span class="line">    <span class="keyword">if</span> game.GameSuccess(<span class="built_in">map</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>, <span class="number">400</span></span><br><span class="line">    <span class="keyword">if</span> delta == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>, math.log2(delta)</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>测试的结果用如下判据表示：将每次最终态的最大值块值加起来，除以总的训练次数。</p><p>最终训练结果也蛮难看：</p><ul><li>200次-86.8</li><li>400次-88.4</li><li>2000次-94.544</li></ul><p>发现结果都差不多，<a href="https://github.com/williamwang0/2048-RL">2048-RL</a>Repo的统计结果如下：</p><blockquote><h4 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h4><ul><li>1 minute of training<ul><li>Average Max Tile: 115.2</li><li>Reached 2048: 0</li></ul></li><li>1 hour of training<ul><li>Average Max Tile: 137.8</li><li>Reached 2048: 0</li></ul></li><li>1 day of training<ul><li>Insufficient storage and computing power</li></ul></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Boredom </tag>
            
            <tag> Python </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无聊系列】利用极大极小分析法玩2048</title>
      <link href="/2023/08/03/%E3%80%90%E6%97%A0%E8%81%8A%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%88%86%E6%9E%90%E6%B3%95%E7%8E%A92048/"/>
      <url>/2023/08/03/%E3%80%90%E6%97%A0%E8%81%8A%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%88%86%E6%9E%90%E6%B3%95%E7%8E%A92048/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>I suck at playing 2048.</p><p>所以我打算尝试一下，编写一个程序替我玩2048。2048完全可以抽象成为一个博弈问题，玩家可以进行上下左右的滑动操作，欲求分数最高；对手是游戏本身，在随机的地方生成方块，欲求让我们输掉游戏——计算机并没有什么欲求，我们假定其每次都将格子生成在最不利于我们的位置。</p><p>极小极大分析法常常用于博弈问题的求解，其优点是模型很简单，其缺点是需要细心地调参。</p><p>我曾用过这种方法求解井字棋问题，正确设置代价函数，效果蛮好；一旦修改参数，效果便会显著下降。</p><h1 id="1-代价-x2F-利益函数的设定"><a href="#1-代价-x2F-利益函数的设定" class="headerlink" title="1. 代价&#x2F;利益函数的设定"></a>1. 代价&#x2F;利益函数的设定</h1><p>利于我们还是不利于我们，需要有判据，这个判据和地图上的局势息息相关，查阅相关资料，大概有如下的判据：</p><ol><li>空格数量。越多越好，越多代表我们的自由度越高。</li><li>等值相邻格的对数。若有相邻的两格值相等，代表我们可以将之合并，增加分数，同时也能增加方格的个数。</li><li>平滑性是指每个方块与其直接相邻方块数值的差，其中差越小越平滑。例如2旁边是4就比2旁边是128平滑。一般认为越平滑的格局越好。第二点可以和这一条合并。</li><li>单调性。若行、列都按照递减、递增顺序排列，则能更加方便地合并格子。</li></ol><p>我觉得还有几条判据也很重要：</p><ol><li>最大值的格子应尽可能靠近角落，否则其必然会遮挡住某些格子，阻拦合并。</li><li>最大值越大越好，越大越有可能获得高分数。</li></ol><p>我初步设定的利益函数为:</p><p>空格数+等值相邻格对数+单调性+最大值距离最近角落的距离+最大值的以2为底的对数。</p><p>其中不严谨的单调性计算的函数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetRowMonotonicity</span>(<span class="params"><span class="built_in">map</span></span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(map_size):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(map_size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i][j + <span class="number">1</span>]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetColMonotonicity</span>(<span class="params"><span class="built_in">map</span></span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(map_size - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(map_size):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i + <span class="number">1</span>][j]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetMonotonicity</span>(<span class="params"><span class="built_in">map</span></span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    row_result = GetRowMonotonicity(<span class="built_in">map</span>)</span><br><span class="line">    col_result = GetColMonotonicity(<span class="built_in">map</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(worst_monotonicity - row_result) + <span class="built_in">abs</span>(worst_monotonicity - col_result)</span><br></pre></td></tr></table></figure><p>对于一行来说，计算左比右大的个数，3表示该行严格递增，0表示严格递减。</p><h1 id="2-基本的极小极大分析法"><a href="#2-基本的极小极大分析法" class="headerlink" title="2. 基本的极小极大分析法"></a>2. 基本的极小极大分析法</h1><p>这种方法的中心思想很简单。我们之前已经设立了利益函数，我方与对方交替下棋，我方会进行最利于我们的操作，而对方会进行最不利于我们的操作。部分代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> game</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, depth</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line">        self.depth = depth</span><br><span class="line">        self.score = utils.CalculateBenefit(self.state)</span><br><span class="line">        self.children = []</span><br><span class="line">        </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MiniMax</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> game.GameFailed(node.state) <span class="keyword">or</span> node.depth == max_depth:</span><br><span class="line">        <span class="keyword">return</span> node.score</span><br><span class="line">    <span class="keyword">if</span> GetNodeCategory(node) == min_node:</span><br><span class="line">        node.GetOurChildren()</span><br><span class="line">        temp_benefit = sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">            temp_benefit = <span class="built_in">min</span>(temp_benefit, MiniMax(child))</span><br><span class="line">        <span class="keyword">return</span> temp_benefit</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.GetOpponetsChildren()</span><br><span class="line">        temp_benefit = -sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">            temp_benefit = <span class="built_in">max</span>(temp_benefit, MiniMax(child))</span><br><span class="line">        <span class="keyword">return</span> temp_benefit</span><br><span class="line">    </span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>该算法的成绩大多稳定在400～500分之间，距离我最差分数600还有很明显的一段距离。最后的地图经常是这样的：</p><blockquote><p>2  4  8  16<br>4  8  16 32<br>8  16 32 64<br>16 32 64 128</p></blockquote><p>显然，我们的代价函数设置的不够精准。</p><p>对我而言，调参毫无意义，或许，我应该选用另外的模型。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.codinglabs.org/articles/2048-ai-analysis.html">2048-AI程序算法分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Boredom </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无聊系列】C实现类似2048的游戏</title>
      <link href="/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/"/>
      <url>/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>无聊是第一生产力。实现一下以前玩过的一版修改版的2048，正好测试一下<code>codeium</code>工具的效果。</p><p>Just for fun:)</p><h1 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h1><p>2048的定义是这样的：</p><blockquote><p>该游戏使用方向键让方块整体上下左右移动。如果两个带有相同数字的方块在移动中碰撞，则它们会合并为一个方块，且所带数字变为两者之和。每次移动时，会有一个值为2或者4的新方块出现，所出現的數字都是2的冪。</p><p>当值为2048的方块出现时，游戏即胜利，该游戏因此得名。</p></blockquote><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>对于移动的实现，我的想法大概是“拆分-合并-补位”，比如让方块向右移动：</p><ol><li>拆分：向右移动的过程中，行与行之间相互独立，只需要实现单个行上的移动操作即可。</li><li>合并：从左往右合并方块。对于2 2 4 8这样的行，原版的2048会合并成0 4 4 8，我的代码将之合并成0 0 0 16，玩起来快一些。</li><li>补位：将方块都紧密地置于一边，即让4 0 8 16变成 0 4 8 16。</li></ol><p>移动的代码大概如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RowMoveRight</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size], <span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; map_size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">map</span>[index][i] == <span class="built_in">map</span>[index][i<span class="number">-1</span>]) &#123;</span><br><span class="line">      <span class="built_in">map</span>[index][i] = <span class="number">2</span> * <span class="built_in">map</span>[index][i];</span><br><span class="line">      <span class="built_in">map</span>[index][i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[index][i] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">map</span>[index][i] = <span class="built_in">map</span>[index][i<span class="number">-1</span>];</span><br><span class="line">      <span class="built_in">map</span>[index][i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; map_size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">map</span>[index][i] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">map</span>[index][i] = <span class="built_in">map</span>[index][i<span class="number">-1</span>];</span><br><span class="line">      <span class="built_in">map</span>[index][i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MoveRight</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size])</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map_size; i++) &#123;</span><br><span class="line">    RowMoveRight(<span class="built_in">map</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  GenerateTwo(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输赢的判断"><a href="#输赢的判断" class="headerlink" title="输赢的判断"></a>输赢的判断</h2><p>如果出现了任意一个2048方块，即为赢。大概的逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GameSuccess</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; map_size; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; map_size; col++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">map</span>[row][col] == <span class="number">2048</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> not_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若每个方块的值，都不等于右侧方块和下侧方块的值，并且，地图被占满，就是输。<code>codeium</code>生成的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GameFailed</span><span class="params">(<span class="type">int</span> <span class="built_in">map</span>[map_size][map_size])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map_size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; map_size - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> not_failed;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="built_in">map</span>[i+<span class="number">1</span>][j] || <span class="built_in">map</span>[i][j] == <span class="built_in">map</span>[i][j+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> not_failed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺对的，哈？No！对于最后一行来说，没法判断方块的值是否等于其右侧方块的值。所以要分开来比较。</p><h2 id="输出相关"><a href="#输出相关" class="headerlink" title="输出相关"></a>输出相关</h2><p>首先要输出的是地图、移动次数和分数，分数的计算规则很简单，2和2拼出4得4分。</p><p>接着，彩色输出方块里数字的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_RED     <span class="string">&quot;\x1b[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_GREEN   <span class="string">&quot;\x1b[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_YELLOW  <span class="string">&quot;\x1b[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_BLUE    <span class="string">&quot;\x1b[34m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_MAGENTA <span class="string">&quot;\x1b[35m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_CYAN    <span class="string">&quot;\x1b[36m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANSI_COLOR_RESET   <span class="string">&quot;\x1b[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputDigit</span><span class="params">(<span class="type">int</span> digit)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(digit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, digit);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_RED);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_GREEN);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_MAGENTA);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">256</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_YELLOW);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(digit &lt;= <span class="number">512</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_CYAN);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_COLOR_BLUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, digit);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(ANSI_COLOR_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出大概长这样：</p><p><img src="/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/1.png"></p><p>在随便整个主菜单：</p><p><img src="/2023/08/03/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%842048/2.png"></p><p>简陋版2048就做好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Boredom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的一些基础知识</title>
      <link href="/2023/07/29/C-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/07/29/C-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引用和指针的区别"><a href="#1-引用和指针的区别" class="headerlink" title="1. 引用和指针的区别"></a>1. 引用和指针的区别</h1><h2 id="定义上的差别"><a href="#定义上的差别" class="headerlink" title="定义上的差别"></a>定义上的差别</h2><p>定义上来说，指针本身代表的不是变量，而是变量的地址；引用是一个变量的别名，所代表的仍是变量本身。也容易推得，指针和引用的数据类型也不同。</p><h2 id="是否可空的差别"><a href="#是否可空的差别" class="headerlink" title="是否可空的差别"></a>是否可空的差别</h2><p>指针可以为空，而引用则不行，创建引用的时候必须将其初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> *b = <span class="literal">nullptr</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;d = c; <span class="comment">// OK</span></span><br><span class="line"><span class="type">int</span> &amp;e; <span class="comment">// Error: Declaration of reference variable &#x27;e&#x27; requires an initializer (lsp)</span></span><br></pre></td></tr></table></figure><p>在考虑传递引用还是指针给函数时，这是很重要的一个考虑点。</p><h2 id="是否可以改变所指对象的差别"><a href="#是否可以改变所指对象的差别" class="headerlink" title="是否可以改变所指对象的差别"></a>是否可以改变所指对象的差别</h2><p>对于指针来说，可以随意改变其所指对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *c = &amp;a;</span><br><span class="line">cout &lt;&lt; *c &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">c = &amp;b;</span><br><span class="line">cout &lt;&lt; *c &lt;&lt; endl; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对于引用来说，修改引用的值，会将引用所指向的值修改掉，而引用仍指向原来的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; &amp;b &lt;&lt; endl; <span class="comment">// 0x7ffde8411808</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; &amp;b &lt;&lt; endl; <span class="comment">// 0x7ffde8411808</span></span><br></pre></td></tr></table></figure><h1 id="2-值类型-Value-categories"><a href="#2-值类型-Value-categories" class="headerlink" title="2. 值类型(Value categories)"></a>2. 值类型(Value categories)</h1><p>参考：</p><ol><li><a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf</a></li><li><a href="https://stackoverflow.com/questions/6107914/how-to-test-whether-expression-is-a-temporary/6114546#6114546">https://stackoverflow.com/questions/6107914/how-to-test-whether-expression-is-a-temporary/6114546#6114546</a></li><li><a href="https://www.zhihu.com/question/46599246/answer/102830868">https://www.zhihu.com/question/46599246/answer/102830868</a></li></ol><h2 id="lvalue-左值"><a href="#lvalue-左值" class="headerlink" title="lvalue-左值"></a>lvalue-左值</h2><p>左值（历史上如此称呼，因为左值可以出现在赋值表达式的左侧）指定一个函数或一个对象。可以理解为，在汇编语句中，具有实际存储地址的值。</p><h2 id="xvalue-将亡值"><a href="#xvalue-将亡值" class="headerlink" title="xvalue-将亡值"></a>xvalue-将亡值</h2><p>将亡值也指对象，通常接近其生命周期结束（例如，以便可以move其资源）。xvalue是涉及右值引用的某些类型表达式的结果。</p><h2 id="glvalue-广义左值"><a href="#glvalue-广义左值" class="headerlink" title="glvalue-广义左值"></a>glvalue-广义左值</h2><p>广义左值就是左值和将亡值。</p><h2 id="rvalue-右值"><a href="#rvalue-右值" class="headerlink" title="rvalue-右值"></a>rvalue-右值</h2><p>右值（历史上所谓的右值，因为右值可能出现在赋值表达式的右侧）是xvalue、临时对象或其子对象，或者不与对象关联的值。可以理解为，在汇编语句中，使用寄存器保存的值和立即数。</p><h2 id="prvalue-纯右值"><a href="#prvalue-纯右值" class="headerlink" title="prvalue-纯右值"></a>prvalue-纯右值</h2><p>不是xvalue的右值。</p><h2 id="测试一下！"><a href="#测试一下！" class="headerlink" title="测试一下！"></a>测试一下！</h2><p>有如下宏定义，可以表示一个变量的类型；又编写了一些函数，定义一些变量，用于测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LVALUE(...) std::is_lvalue_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_XVALUE(...) std::is_rvalue_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_PRVALUE(...) !std::is_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestFunctionRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br></pre></td></tr></table></figure><p>做出如下测试，结果如下：</p><ol><li>变量<code>a</code>是左值，因为其表示一个对象。</li><li><code>TestFunction</code>是左值，因为其是一个函数。</li><li>字符串是左值，因为在编译阶段，其存放在内存的常量空间里，详见:<a href="https://coder109.github.io/2023/05/23/Linux%E4%B8%8BHello-World%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84/#%E8%A7%A3%E9%87%8A-1">Linux下Hello World是如何输出的</a>。</li><li>对变量<code>a</code>取地址是右值，对<code>b</code>取值是左值。</li><li><code>TestFunction()</code>是纯右值，因为函数返回值存储在对应的寄存器中，是一个临时的值。</li><li><code>this</code>是一个纯右值。</li></ol><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>对于<code>std::move()</code>等方法来说，需要明确区分这几个值的类型。</p><p>详见<a href="https://zhuanlan.zhihu.com/p/402251966">https://zhuanlan.zhihu.com/p/402251966</a>。</p><h1 id="3-STL相关"><a href="#3-STL相关" class="headerlink" title="3. STL相关"></a>3. STL相关</h1><blockquote><p>Algorithms + Data Structures &#x3D; Programs </p><p>——Niklaus Wirth</p></blockquote><p>所有源代码都在64位Arch Linux下查看，所使用的g++版本为13.1.1。</p><p>如果感兴趣，可以查看:<a href="https://love-la.in/1e7Ug5">https://love-la.in/1e7Ug5</a>。</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>STL无非就那几个容器。STL的关键部分为分配器(allocator)，算法(algorithm)，适配器(adapter)，容器(containers)，迭代器(iterator)和仿函数(functor)组成。</p><p>容器是一种数据结构。使用的时候需要先通过分配器在内存中为对应的容器分配空间，接着通过能够访问容器中元素的迭代器将算法应用到容器上。</p><p>适配器允许我们将本无法应用到容器上的算法，改变一下，使之能够应用到容器上，而仿函数则是一个类，内部重载了<code>()</code>运算符，其使我们能够拥有更多对容器的操纵方式，比如说:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; my_list;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    my_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> target_index_iter = <span class="built_in">find_if</span>(my_list.<span class="built_in">begin</span>(), my_list.<span class="built_in">end</span>(), <span class="built_in">bind</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">9</span>));</span><br><span class="line">  cout &lt;&lt; *target_index_iter &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了寻找vector中大于9的元素的功能。</p><p><code>find_if</code>的第三个参数需要一个一元谓词，类似于一个接收一个变量的函数指针，单独编写一个判断是否大于9的函数有些麻烦，我们可以通过适配器+仿函数来简单地达成这个目的。代码中的<code>bind()</code>是一个适配器，允许我们简单的通过二元仿函数<code>greater()</code>来对容器进行操作。我们提前将9绑定为<code>greater()</code>函数的第二个参数，这样<code>bind()</code>返回了一元谓词，符合参数规范要求。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>list</code>本身是一个<strong>双向环形链表</strong>，详情参考<code>&lt;bits/stl_list.h&gt;</code>。显然，不支持随机访问。</p><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p><code>forward_list</code>是个<strong>线性单向链表</strong>。显然，不支持随机访问。</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>vector</code>是一个<strong>可变长的数组</strong>，更具体的来讲，是一个扩张因子为2的<strong>动态表</strong>。这个数据结构在《算法导论》中有提及，作为平摊分析的一个例子来讲解。</p><p>什么是扩张因子为2的动态表？具体来说，您不断地向<code>vector</code>当中插入元素，一旦满了，就在内存中申请<strong>新的</strong>两倍于原先大小的空间。这会造成一定的开销。</p><p>然而，<code>sizeof(vector)</code>的大小并非可变值，而是3个指针的长度，因为其底层定义里，<code>vector</code>类的成员只包含三个指针——<code>begin</code>,<code>end</code>和<code>end_of_storage</code>。</p><p>显然，支持随机访问。</p><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p><code>array</code>是一个<strong>定长数组</strong>。支持随机访问。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>全称为double-ended queue。由一个<code>map</code>和多个<code>vector</code>组成。注意这里的<code>map</code>不是STL的<code>map</code>，更像是<code>vector</code>。<code>deque</code>可以理解为双头队列，也可以近似理解为是一个<code>vector&lt;vector&gt;</code>。</p><p>如果查看源代码，会发现，一个<code>deque</code>类包含四个成员，一个<code>map</code>，一个<code>map_size</code>，和两个迭代器<code>start</code>、<code>finish</code>。<code>map</code>里的每一个单元都指向一个<code>vector</code>，头插的时候，就在单元所对应的第一个有数据的<code>vector</code>的头部插入，尾插就在最后一个有数据的<code>vector</code>的尾部插入。</p><p><code>deque</code>里的迭代器是一个类，有四个部分，<code>first</code>，<code>last</code>，<code>cur</code>和<code>node</code>。前两者指向迭代器所对应<code>vector</code>（也称作缓冲区）的头和尾，<code>cur</code>指向当前数据，<code>node</code>则指向该<code>map</code>中，指向该<code>vector</code>的地址。也就是<code>map</code>里对应的地址。</p><p>看不懂的话，在<code>&lt;bits/stl_deque.h&gt;</code>中，有如下的注释说明：</p><blockquote><ul><li><p>For any nonsingular iterator i:</p><ul><li><p>i.node points to a member of the %map array.  (Yes, you read that correctly:  i.node does not actually point to a node.)  The member of the %map array is what actually points to the node.</p></li><li><p>i.first &#x3D;&#x3D; *(i.node)    (This points to the node (first Tp element).)</p></li><li><p>i.last  &#x3D;&#x3D; i.first + node_size</p></li><li><p>i.cur is a pointer in the range [i.first, i.last).  NOTE: the implication of this is that i.cur is always a dereferenceable pointer, even if i is a past-the-end iterator.</p></li><li><p>Start and Finish are always nonsingular iterators.</p></li></ul></li></ul></blockquote><p>缓冲区大小一般是512，如果一个元素的大小大于512，就让一个缓冲区放1个元素。</p><p>这种设计是为了保证<code>deque</code>表面的连续性，某些情况下，<code>cur</code>指针迭代出当前<code>vector</code>范围，就要通过<code>node</code>进行计算，指向下一个<code>vector</code>的区间内。</p><p>另外，<code>deque</code>的扩容方式和扩张因子为2的动态表一致。</p><p>当指定位置插入的时候，<code>deque</code>会计算，此位置是不是<code>start</code>或者<code>finish</code>，若非，是离<code>start</code>近，还是离<code>finish</code>近，从而进行不同的插入表现。</p><p>允许随机访问。</p><h2 id="queue-x2F-stack"><a href="#queue-x2F-stack" class="headerlink" title="queue&#x2F;stack"></a>queue&#x2F;stack</h2><p><code>queue</code>和<code>stack</code>严格来说不是容器，而是适配器。</p><p>它们底层都是<code>deque</code>，将<code>deque</code>阉割一下就能得到这两种数据结构。双端开口改为一端开口，仅保留部分的<code>push</code>和<code>pop</code>操作即可。二者无法被遍历。</p><p>对于<code>stack</code>，查看<code>&lt;bits/stl_stack.h&gt;</code>:</p><blockquote><p>This is not a true container, but an @e adaptor.  It holds another container, and provides a wrapper interface to that container.  The wrapper is what enforces strict first-in-last-out %stack behavior. The second template parameter defines the type of the underlying sequence&#x2F;container. It defaults to std::deque, but it can be any type that supports @c back, @c push_back, and @c pop_back, such as std::list, std::vector, or an appropriate user-defined type.</p></blockquote><p><code>stack</code>底层可以是<code>list</code>，也可以是<code>vector</code>，也可以是自定义的数据结构，默认是<code>deque</code>。</p><p>对于<code>queue</code>，查看<code>&lt;bits/stl_queue.h&gt;</code>:</p><blockquote><p>This is not a true container, but an @e adaptor.  It holds another container, and provides a wrapper interface to that container.  The wrapper is what enforces strict first-in-first-out %queue behavior. The second template parameter defines the type of the underlying sequence&#x2F;container. It defaults to std::deque, but it can be any type that supports @c front, @c back, @c push_back, and @c pop_front, such as std::list or an appropriate user-defined type.</p></blockquote><p>其底层可以是<code>list</code>，可以是自定义的数据结构，默认是<code>deque</code>。</p><p>有个细节，为什么<code>queue</code>不能用<code>vector</code>做底层结构呢？其实很简单，因为后者没有<code>pop_front()</code>。</p><h2 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h2><p>二者的底层都是<code>红黑树</code>。二者想要表示的都是数学上集合的概念，不同点在于，<code>set</code>里的元素不可以重复，而<code>multiset</code>里的元素可以重复。二者里的数据都是排好序的。在<code>&lt;bits/stl_set.h&gt;</code>中，<code>set</code>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">   <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> set</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如您所见，其默认的排序方式是从小到大排序。<code>multiset</code>也是如此。</p><p>插入、删除、查找的复杂度都是$O(logn)$。</p><h2 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h2><p>二者底层都是<code>红黑树</code>，和<code>set/multiset</code>不同的是，二者存储的数据以键值对的方式存在，排序的时候以键的值为排序准则。</p><h2 id="unordered-map-x2F-unordered-set"><a href="#unordered-map-x2F-unordered-set" class="headerlink" title="unordered_map&#x2F;unordered_set"></a>unordered_map&#x2F;unordered_set</h2><p>底层是<code>哈希表</code>，查找的效率为$O(1)$，最坏为$O(n)$。</p><p>默认的哈希算法是开链法。</p><h1 id="4-简单的小知识"><a href="#4-简单的小知识" class="headerlink" title="4. 简单的小知识"></a>4. 简单的小知识</h1><h2 id="new-x2F-delete-VS-malloc-x2F-free"><a href="#new-x2F-delete-VS-malloc-x2F-free" class="headerlink" title="new&#x2F;delete VS malloc()&#x2F;free()"></a>new&#x2F;delete VS malloc()&#x2F;free()</h2><p>new的时候，先调用malloc()分配空间，然后调用类的构造函数。delete的时候，先调用析构函数，然后调用free()回收空间。</p><h2 id="const-VS-define"><a href="#const-VS-define" class="headerlink" title="const VS #define"></a>const VS #define</h2><p>#define所做的，是简单的替换。在预处理阶段进行处理。</p><p>有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = A;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过预处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><p>有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.i</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;defineTest.c&quot;</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">0</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;defineTest.c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于const定义的常量来说，其具有数据类型，也在后续阶段被处理，相对来说更加安全。此外，const也可以在函数内被定义，定义一个局部常量，也更加灵活。</p><p>此外，const也有多种功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">4</span>; <span class="comment">// 常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = &amp;x; <span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = &amp;x; <span class="comment">// 指向非常量变量的指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 成员函数内不可修改类成员值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static的用法"><a href="#static的用法" class="headerlink" title="static的用法"></a>static的用法</h2><ol><li>static可以用来声明静态成员，但是一定要在类外初始化，否则在链接时会报错。</li><li>static也可以用来设定类的静态方法，无须初始化就可以调用这个方法。静态方法无法调用非静态成员变量。</li><li>static可以表明一个普通函数只在当前文件中有效。</li><li>static可以修饰一个变量，在函数内修饰，表明不论函数调用多少次，这个变量只初始化一次；若在函数外修饰，则在程序运行之前就创建该变量。</li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在一个类里面，this可以理解为，指向自己的指针，与此同时，this是一个右值。</p><p>有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_PRVALUE(...) !std::is_reference<span class="string">&lt;decltype((__VA_ARGS__))&gt;</span>::value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">IS_PRVALUE</span>(<span class="keyword">this</span>) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo* test = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">  test-&gt;<span class="built_in">bar</span>(); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在普通的成员函数<code>Foo::bar()</code>里，this的类型是<code>Foo*</code>，也是一个纯右值。在<code>Foo::test()</code>里，this的类型是<code>const Foo*</code>，这也保证在这种函数里面，没法修改成员变量的值。</p><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>其常用于声明类的构造函数，规避对构造函数的隐性调用和复制初始化。</p><h2 id="与-的用法"><a href="#与-的用法" class="headerlink" title="::与:的用法"></a>::与:的用法</h2><p>总结一下，<code>::</code>有如下用法：</p><ol><li><p>声明所调用变量为全局变量，有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var_g = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> var_sg = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> var_g = <span class="number">20</span>;</span><br><span class="line">  <span class="type">int</span> var_sg = <span class="number">21</span>;</span><br><span class="line">  std::cout &lt;&lt; ::var_g &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">  std::cout &lt;&lt; ::var_sg &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">  std::cout &lt;&lt; var_g &lt;&lt; std::endl; <span class="comment">// 20</span></span><br><span class="line">  std::cout &lt;&lt; var_sg &lt;&lt; std::endl; <span class="comment">// 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于访问命名空间和类下的函数&#x2F;方法，如<code>std::cout</code>或<code>Foo::test()</code>。</p></li></ol><p>而<code>:</code>用法如下：</p><ol><li><p>表示类的继承关系，如<code>class Foo : public Father</code>。</p></li><li><p>用于初始化列表，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> a) : <span class="built_in">i</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Some-OOP-stuff-一些面向对象的理论"><a href="#Some-OOP-stuff-一些面向对象的理论" class="headerlink" title="Some OOP stuff-一些面向对象的理论"></a>Some OOP stuff-一些面向对象的理论</h2><ol><li>有时候面试会问“C++的三大特点”，倒不如问“OOP”的三大特点了，是封装、继承和多态。</li><li>C++的多态有两种：早绑定&#x2F;晚绑定(编译时多态&#x2F;运行时多态，静态多态&#x2F;动态多态)，前者依靠方法的重写，后者则依靠虚函数。对于Java来说，有<code>interface</code>和<code>abstract</code>关键字，而在C++里则没有这两个关键字声明接口和抽象类，这两个功能也好实现，只有纯虚函数的类叫做接口，有纯虚函数的类叫做抽象类。</li><li>阐明几个名词：重写是子类重新写父类的方法；重载是同一个名称函数在同一个类中的，能够接收不同参数的实现；覆盖是指子类实现了父类的虚函数，覆盖了父类的实现。</li><li>由于STL没有虚析构函数，尽量不要继承它——自己写一个适配器就行嘛！</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><code>static_cast</code>，常用于T到各个类型的转换、数值之间的转换。</li><li><code>reinterpret_cast</code>，按位转换，常用于各种指针间的转换。</li><li><code>const_cast</code>，用于将常量转换为变量。</li><li><code>dynamic_cast</code>，可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，也可以转换引用，且检查安全性。</li></ol><h1 id="5-智能指针"><a href="#5-智能指针" class="headerlink" title="5. 智能指针"></a>5. 智能指针</h1><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>翻译自<a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">https://en.cppreference.com/w/cpp/memory/unique_ptr</a>：<code>unique_ptr</code> 是一个智能指针，它通过指针拥有和管理另一个对象，并在 <code>unique_ptr</code> 超出作用域时处置该对象。有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Halo!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;No!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;Foo&gt; p1 = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Nah!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: </span></span><br><span class="line"><span class="comment">// Halo!</span></span><br><span class="line"><span class="comment">// No!</span></span><br><span class="line"><span class="comment">// Nah!</span></span><br></pre></td></tr></table></figure><p>调用完<code>foo()</code>，直接调用生成<code>Foo</code>对象的析构，而不是等到最后再去销毁该对象。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>shared_ptr</code>其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。</p><p>参考:<a href="https://zhuanlan.zhihu.com/p/150555165">https://zhuanlan.zhihu.com/p/150555165</a></p><p>但这种指针会出现循环引用的问题，所以引出了<code>weak_ptr</code>。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>其指向对象，但不改变其引用计数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库的一些用法备忘</title>
      <link href="/2023/07/27/Pandas%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%E5%A4%87%E5%BF%98/"/>
      <url>/2023/07/27/Pandas%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-删除相关"><a href="#1-删除相关" class="headerlink" title="1. 删除相关"></a>1. 删除相关</h1><h2 id="drop方法的inplace参数和axis参数"><a href="#drop方法的inplace参数和axis参数" class="headerlink" title="drop方法的inplace参数和axis参数"></a><code>drop</code>方法的<code>inplace</code>参数和<code>axis</code>参数</h2><p>如今有这样一个Dataframe，有两列，一列名为<code>Id</code>，一列名为<code>Name</code>，现如今我想删除<code>Id</code>这一列，如下方法是错误的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.drop(columns=<span class="string">&quot;Id&quot;</span>)</span><br><span class="line">df = df.drop(columns=<span class="string">&quot;Id&quot;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>如下方法是正确的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.drop(columns=<span class="string">&quot;Id&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df = df.drop(columns=<span class="string">&quot;Id&quot;</span>)</span><br></pre></td></tr></table></figure><p>官方文档是这样提到<code>inplace</code>参数的：</p><blockquote><p><strong>inplace</strong>: bool, default False</p><p>If False, return a copy. Otherwise, do operation inplace and return None.</p></blockquote><p>默认是False，当此参数为False的时候，该方法返回一份Dataframe的拷贝；若为True，则返回一个空对象None。</p><p>对于<code>axis</code>参数，文档是这样写的：</p><blockquote><p><strong>axis</strong>: 0 or ‘index’, 1 or ‘columns’, default 0</p><p>Whether to drop labels from the index (0 or ‘index’) or columns (1 or ‘columns’).</p></blockquote><p>也就是说，<code>drop</code>方法默认删除行，要想删除列，需要指定<code>axis</code>参数为1。</p><h2 id="删除特定索引的行-x2F-列"><a href="#删除特定索引的行-x2F-列" class="headerlink" title="删除特定索引的行&#x2F;列"></a>删除特定索引的行&#x2F;列</h2><p>曾经听过很重要的一句话，”在<code>Pandas</code>里，行有索引，列有名称”。也就是说，如果想删除特定索引的行，要用行号删除；删除特定索引的列，要用列的名称删除。</p><p>举个例子，我们有如下格式的文件：</p><p><img src="/2023/07/27/Pandas%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%E5%A4%87%E5%BF%98/1.png"></p><p>想要删除前两行，用如下的代码删除就行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop([<span class="number">0</span>,<span class="number">1</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/07/27/Pandas%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%E5%A4%87%E5%BF%98/2.png"></p><p>若想删除前两列，不能用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop([<span class="number">0</span>,<span class="number">1</span>], inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这样做会报错，报错如下:</p><blockquote><p>KeyError: ‘[0, 1] not found in axis’</p></blockquote><p>因为列有名称，名为0和1的列没法在Dataframe中找到。想删除，则需要根据索引获取列名:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop(df.columns[[<span class="number">0</span>,<span class="number">1</span>]], inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/07/27/Pandas%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%E5%A4%87%E5%BF%98/3.png"></p><h1 id="2-输出-csv文件的格式"><a href="#2-输出-csv文件的格式" class="headerlink" title="2. 输出.csv文件的格式"></a>2. 输出.csv文件的格式</h1><p>在<a href="https://www.kaggle.com/">Kaggle</a>上提交文件，需要将文件的格式统一，若失败，常常是因为输出.csv的时候自动添加了索引，输出应该用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output_file.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h1 id="3-获取指定行-x2F-列"><a href="#3-获取指定行-x2F-列" class="headerlink" title="3. 获取指定行&#x2F;列"></a>3. 获取指定行&#x2F;列</h1><p>我常用<code>iloc</code>方法，一般通过<code>:</code>运算符获取。值得注意的是，最后一列用-1代替，而且<code>3:5</code>，代表的是一个左闭右开区间。一些例子：</p><h2 id="获取第4列"><a href="#获取第4列" class="headerlink" title="获取第4列"></a>获取第4列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.iloc[:,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>第一个<code>:</code>指，选择所有的行。</p><h2 id="获取最后一列"><a href="#获取最后一列" class="headerlink" title="获取最后一列"></a>获取最后一列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.iloc[:,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="获取除去最后一列外的所有列"><a href="#获取除去最后一列外的所有列" class="headerlink" title="获取除去最后一列外的所有列"></a>获取除去最后一列外的所有列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.iloc[:, <span class="number">0</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="获取指定数据类型的列"><a href="#获取指定数据类型的列" class="headerlink" title="获取指定数据类型的列"></a>获取指定数据类型的列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.select_dtypes(include=[<span class="string">&#x27;int64&#x27;</span>, <span class="string">&#x27;float64&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="4-NaN值的处理方法"><a href="#4-NaN值的处理方法" class="headerlink" title="4. NaN值的处理方法"></a>4. <code>NaN</code>值的处理方法</h1><p>对于<code>sklearn</code>的某些模型，比如<code>RandomForestRegressor()</code>，输入的Dataframe不能有<code>NaN</code>(Not a Number)的值。</p><p>一种处理方法是直接把含有<code>NaN</code>的列删除掉，这种方法同时有可能会丢掉有价值的数据。</p><p>一种处理方法是换用允许<code>NaN</code>的模型，比如将<code>RandomForestRegressor()</code>换成<code>HistGradientBoostingRegressor</code>。</p><p>还有一种处理方法是替换<code>NaN</code>为该列的平均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.fillna(X_train.mean())</span><br></pre></td></tr></table></figure><p>这行代码会计算每一列的均值，然后将每一列的<code>NaN</code>换成其所在列的均值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现一个简单Shell</title>
      <link href="/2023/07/24/C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95Shell/"/>
      <url>/2023/07/24/C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95Shell/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Shell运行的基本逻辑"><a href="#1-Shell运行的基本逻辑" class="headerlink" title="1. Shell运行的基本逻辑"></a>1. Shell运行的基本逻辑</h1><p>Shell一般按照如下的步骤运行：等待状态-获取命令行输入-处理-创建子进程-等待子进程运行结束-等待状态。</p><p>分别来说：</p><ol><li>获取命令行输入可以使用<code>readline()</code>,<code>scanf()</code>之类的函数。</li><li>处理输入，首先要做的是将输入按照分隔符分开，得到一个二维数组。接着，我们要对获得的命令进行判断，判断其是否为内置命令，如果为内置命令，需要执行我们自己编写函数，如果不是内置命令，就要通过<code>fork()</code>创建一个子进程，在子进程中执行非内置命令，父进程等待子进程的结束。</li></ol><h1 id="2-获取输入"><a href="#2-获取输入" class="headerlink" title="2. 获取输入"></a>2. 获取输入</h1><p>读取输入的函数大概如下，一个字符一个字符读取，方便我们控制对应的行为，比如读取到EOF就直接返回等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ReadLine</span><span class="params">(<span class="type">char</span>* buffer)</span> &#123;</span><br><span class="line">  <span class="type">int</span> buffer_pivot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(buffer_pivot == BUFFER_SIZE) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The expression is too long to process.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ERR_EXPR_TOO_LONG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> current_char = getchar();</span><br><span class="line">    <span class="keyword">if</span>(current_char == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">      buffer[buffer_pivot++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current_char == EOF)&#123;</span><br><span class="line">      <span class="keyword">return</span> INPUT_EOF;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer[buffer_pivot++] = current_char;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-处理输入"><a href="#3-处理输入" class="headerlink" title="3. 处理输入"></a>3. 处理输入</h1><p>使用<code>strtok()</code>函数，可以将字符串根据设定的分隔符，分割成各部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>** <span class="title function_">ProcessLine</span><span class="params">(<span class="type">char</span>* command)</span> &#123;</span><br><span class="line">  <span class="type">char</span>** command_tokens = (<span class="type">char</span>**)SafeMalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) * BUFFER_SIZE);</span><br><span class="line">  <span class="type">char</span>* token;</span><br><span class="line">  <span class="type">int</span> command_tokens_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  token = strtok(command, TOKEN_DELIMITER);</span><br><span class="line">  <span class="keyword">while</span>(token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    command_tokens[command_tokens_index++] = token;</span><br><span class="line">    token = strtok(<span class="literal">NULL</span>, TOKEN_DELIMITER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  command_tokens[command_tokens_index] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> command_tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-进程处理"><a href="#4-进程处理" class="headerlink" title="4. 进程处理"></a>4. 进程处理</h1><p>大致如此。之前CSAPP的课设里，执行程序使用的是<code>execve()</code>，用<code>execvp()</code>倒也无所谓，它们的功能都差不多。exec函数族属于”进程替换”的函数族，执行它们不创建新进程，而是将当前进程覆盖掉，执行要执行的程序，这也是我们要创建子进程执行命令的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ExecuteCommand</span><span class="params">(<span class="type">char</span> **token_list)</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> command_pid;</span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(token_list[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="built_in">strcmp</span>(token_list[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Command_cd(token_list);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(token_list[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Command_exit(token_list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  command_pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(command_pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(execvp(token_list[<span class="number">0</span>], token_list) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;Execute Error&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> ERR_FAILED_TO_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(command_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    perror(<span class="string">&quot;Fork Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(token_list);</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>令人唾弃的自杀者的自白</title>
      <link href="/2023/07/24/%E4%BB%A4%E4%BA%BA%E5%94%BE%E5%BC%83%E7%9A%84%E8%87%AA%E6%9D%80%E8%80%85%E7%9A%84%E8%87%AA%E7%99%BD/"/>
      <url>/2023/07/24/%E4%BB%A4%E4%BA%BA%E5%94%BE%E5%BC%83%E7%9A%84%E8%87%AA%E6%9D%80%E8%80%85%E7%9A%84%E8%87%AA%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>我决定要自杀。</p><p>雪花在我身边旋转，下降。午夜的城市一片死寂。</p><p>我抓不到未来的影子，而过往的尖刀令我遍体鳞伤，我的血流干了。我不得不为我所做的一切付出代价。如果我没办法为这世界做出一丝一毫的贡献、没办法融入这个社会中来，我只有去死。所以，我决定要自杀。此外，我是个疯子，我的脑子里有些结构坏掉了，导致我总是表现得很怪异。</p><p>我感觉到一丝痛楚从胸膛涌出，瞬间传遍了我的身体，让我突然战栗。生的女神在挽留我，而死亡之神，正静静地看着我做出抉择。</p><p>太阳早就落下了，月亮也被云笼罩。大雪让一切变得模糊、浪漫，粉饰着这以痛苦和欺辱为底色的世界。几个小时前热闹的大街、灯火通明的城市，如今终于露出它的本来面目，同墓地无异。而我的墓碑，不在这里，这里是乱葬岗。我喜欢安静的世界，墓碑在森林里。</p><p>我的外衣兜里揣着一封信，我写给我自己的。上面一个字也没有。因为我没什么好写的，一个社会蛀虫、垃圾人不配在洁白的纸上留下自己的证据。这只是个隐喻而已。</p><p>我忽然听见有人在唱歌。我顺着声音走去，最终拐进了一条巷子。一个小女孩躺在垃圾桶旁边，身上单薄、脏兮兮的，正对照着简谱哼歌。她看见我，勉强笑了笑。又低头哼着歌去。她打着寒战。</p><p>我把我的外衣披在她身上。她抬头注视着我。“您不必这么做，先生，您同我一样，都是将死之人。”</p><p>我没有想到小女孩会说出如此刻薄的话来。</p><p>“您瞧，这个时候，一般人都睡觉了，而您还在大街上走着。而且，您应该知道，我今晚会冻死在这小巷子里，这件外衣解决不了什么问题的。”</p><p>我没有说什么，转身走出小巷，为这没来由出现的女孩困惑不已。忽然，我记起我的信还在外衣口袋里，又进入小巷，发现女孩早已不见了。</p><p>“这刻薄的小贼！”</p><p>可我终究没有骂出来，那女孩应该能逃脱被冻死的命运，而我马上就要死了，要外衣也没什么用了。至于那封信，无所谓了。我知道，她没有偷东西。</p><p>……</p><p>我走到森林边缘，回头看城市，黄色的路灯光若隐若现。我耳旁寒风呼啸，雪花狠狠地打在我的脸上。我感觉自己心跳加快，胸闷气短，我离自己的终结又近了一步。现在就像是京剧的高潮，鼓声迭起。</p><p>我决定要自杀。</p><p>我把衬衫脱下来，打上结，爬上树，将它系在旁边的一根看起来足够粗的树枝上。</p><p>爬下树，我笑了笑。</p><p>我知道，自己如今走投无路都是自己的原因。我开始唱起歌来，森林里回荡着我的声音，城市边缘，靠近森林的一栋楼里，有两三户人家打开了灯，向我这边看去，似乎要为自己被中断的睡眠讨个公道。我没有理睬他们，如今我什么都不怕了，我也不再悲伤，不再忧郁，如今的我切切实实是在为自己而活了。我的歌声穿透黑夜，我好快乐！我随即大笑起来。我听见城市那边，有住户在朝着森林这里责骂。</p><p>笑累了，一切又回归沉寂。我又开始思索起来，这人死后到底有没有灵魂，有没有轮回转世，有没有所谓的天堂地狱审判。</p><p>我瑟缩着，思考着，终究想不透这些东西。</p><p>我爬上树，将脖子伸进那绳套中。窒息。</p><p>我感觉生命的强力消散在我周围的空气中，化作热量，随即又被冬日的寒风冷却，被同化为它们的一员。我瞄见那城市边缘的住户关上了灯……</p><p>我失去了意识。少顷。</p><p>我感觉自己从树上飘了下来。我感觉自己的身体在发光。我向树上望去，我的身体赫然挂在上面，面色狰狞可怖。舌头伸出来，滴着唾液。</p><p>哦，如今我确实是死掉了。伸手触碰旁边的树，我的手直接穿过树干，什么感觉也没有。我向城市里慢慢走去，如今我不感觉冰冷了，我既温暖，又快乐。</p><p>我走回刚才遇见小姑娘的巷子，那里空空如也。我走进巷子的深处，看见那个女孩正披着我的外衣，躺在旧床垫上呼呼睡着。我的那封信还在衣兜里。她今天至少还能活着。</p><p>“这里什么都没有，先生。”</p><p>一个浑厚的声音在我耳旁响起，我循着声音看去，是一个穿着西服，拄着拐杖的老人。</p><p>“您是……？”我问道。</p><p>“我是死的使者。”他顿了顿，“带您去冥界。”</p><p>“冥界可有东西？”</p><p>“在那里，你想要什么就有什么，倒也有些限制，您马上就明白了。”</p><p>“也好。”我没得选择。</p><p>他点点头，磕了磕拐杖，我周围的光景迅速化作黑暗，收缩为一点。</p><p>黑暗…安静…</p><p>一切都消失了，只有我，我觉得自己似乎已经到了冥界，于是我在内心想着，我要一百枚金币。</p><p>于是真有一百枚金币掉在我面前，闪闪发光，那些金币看起来，和现实世界中的一样。只是我捡不起来。</p><p>我要三幢别墅，于是真有三栋豪华的别墅，出现在我的面前，在黑暗中显得那么格格不入。我朝房子走去，它却离我越来越远。</p><p>我恍惚间意识到了什么。于是我想，让这些东西都消失掉。</p><p>一切都归于黑暗。冥界的使者出现了，告诉我：</p><p>“一切生成的东西，你都无法去触碰、无法获取，那些东西不属于你。那些可能引发悖论的东西，也不会产生。”</p><p>“冥界倒是如此残酷了！我可有离开这里的方法吗？”</p><p>“你现在可以去往任何维度，但是你只能影响自己生成的东西。”</p><p>我感到无聊。我去其他的维度旅游，我看到，其他的维度里，有的地方有长着三十个头的人，有的地方有血红色的天空，有的地方只有0和1。</p><p>这些维度都是其他死者创造的，其实，冥界也是某个“父维度”的死者创造的。</p><p>我回到黑暗的冥界，决定做些什么。</p><p>接下来，我想到，要有光。</p><p>于是，四周亮了起来。</p><p>我终于意识到世界和冥界的关系。我发动想象，看着自己周围变得明亮起来，那些是恒星的光芒，我又想，生成一个地球出来，一颗蓝色的星球就出现在那里。我看着上面生命的发展。</p><p>我就这么长久地在冥界生存——死存下去。由我生成的世界将长久不死，永存下去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现代码雨</title>
      <link href="/2023/07/16/C-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%9B%A8/"/>
      <url>/2023/07/16/C-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0-最终效果"><a href="#0-最终效果" class="headerlink" title="0. 最终效果"></a>0. 最终效果</h1><p>只适用于Linux系统。</p><p><img src="/2023/07/16/C-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%9B%A8/1.png"></p><h1 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h1><p>将每一列分开来处理。</p><p>每一列上半部分暗一些，最下面的字符为白色。</p><h1 id="2-遇到的坑"><a href="#2-遇到的坑" class="headerlink" title="2. 遇到的坑"></a>2. 遇到的坑</h1><h3 id="清屏导致终端闪烁"><a href="#清屏导致终端闪烁" class="headerlink" title="清屏导致终端闪烁"></a>清屏导致终端闪烁</h3><p>不论是调用<code>&lt;ncurses.h&gt;</code>里的<code>clear()</code>函数，还是直接用不优雅的<code>system(&quot;clear&quot;)</code>，在清屏时，都会导致显示的内容闪烁。</p><p>我没有查到什么好的解决方案，我通过使用输出空字符代替清屏来解决这个问题。</p><h3 id="终端尺寸变化导致显示效果不全"><a href="#终端尺寸变化导致显示效果不全" class="headerlink" title="终端尺寸变化导致显示效果不全"></a>终端尺寸变化导致显示效果不全</h3><p><del>Windows下可以使用Hook机制——maybe，我没在Windows下写过复杂的东西——而在Linux下，貌似可以使用类似的信号机制，但是信号的Handler只能传递一个int类型的变量，我还没有想到如何在这种情况下，通过它修改一个类里面的值。</del></p><p><del>我的确可以使用一种不甚优雅的方式：在每次处理列的时候，都去获取一次窗口的长和宽。</del></p><p>可以这样做，设立一个全局变量，当每次收到<code>SIGWINCH</code>信号的时候，就去修改这个变量的值，主函数中每次循环都去根据这个变量的值，调整窗口大小。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><details>    <summary>Matrix.hpp</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATRIX_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Matrix</span>(<span class="type">int</span> show_length = <span class="number">9</span>, <span class="type">int</span> color = <span class="number">0</span>);</span><br><span class="line">  ~<span class="built_in">Matrix</span>();</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ShowColumn</span><span class="params">(<span class="type">int</span> column)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  WINDOW* my_window;</span><br><span class="line">  <span class="type">int</span> row_recorder[<span class="number">2000</span>];</span><br><span class="line">  <span class="type">int</span> window_height;</span><br><span class="line">  <span class="type">int</span> window_width;</span><br><span class="line">  <span class="type">int</span> show_length;</span><br><span class="line">  <span class="type">int</span> color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Matrix.cpp</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment"> * Filename: Matrix.cpp</span></span><br><span class="line"><span class="comment"> * Author: Coder109</span></span><br><span class="line"><span class="comment"> * Date: 2023-07-16 07:20:42</span></span><br><span class="line"><span class="comment"> * Description: Deal with the matrix rain</span></span><br><span class="line"><span class="comment"> *****************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Matrix.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> character_list[] = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYXZ&quot;</span>;</span><br><span class="line"></span><br><span class="line">Matrix::<span class="built_in">Matrix</span>(<span class="type">int</span> show_length, <span class="type">int</span> color) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;show_length = show_length;</span><br><span class="line">  <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;my_window = <span class="built_in">initscr</span>();</span><br><span class="line">  <span class="built_in">cbreak</span>();</span><br><span class="line">  <span class="built_in">noecho</span>();</span><br><span class="line">  <span class="built_in">getmaxyx</span>(<span class="keyword">this</span>-&gt;my_window, <span class="keyword">this</span>-&gt;window_height, <span class="keyword">this</span>-&gt;window_width);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">start_color</span>();</span><br><span class="line">  <span class="built_in">init_pair</span>(<span class="number">1</span>, COLOR_BLUE, COLOR_BLACK);</span><br><span class="line">  <span class="built_in">init_pair</span>(<span class="number">2</span>, COLOR_WHITE, COLOR_BLACK);</span><br><span class="line">  <span class="built_in">init_pair</span>(<span class="number">3</span>, COLOR_BLACK, COLOR_BLACK);</span><br><span class="line">  <span class="built_in">attron</span>(A_BOLD);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;window_width; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;row_recorder[i] = -<span class="built_in">rand</span>() % <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix::~<span class="built_in">Matrix</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Matrix::ShowColumn</span><span class="params">(<span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> curr_row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;row_recorder[column] &gt;= <span class="keyword">this</span>-&gt;window_height + <span class="keyword">this</span>-&gt;show_length) &#123;</span><br><span class="line">    curr_row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;row_recorder[column] = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    curr_row = <span class="keyword">this</span>-&gt;row_recorder[column]++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Output empty char in order to solve the problem:</span></span><br><span class="line">  <span class="comment">// When clearing the screen, the terminal will flicker.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_processing_row = <span class="number">0</span>;</span><br><span class="line">      curr_processing_row &lt; curr_row - <span class="keyword">this</span>-&gt;show_length;</span><br><span class="line">      curr_processing_row++) &#123;</span><br><span class="line">    <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">mvaddch</span>(curr_processing_row, column, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Upper half of the column should be darker, and the bottom char should be white</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_processing_row = curr_row - <span class="keyword">this</span>-&gt;show_length;</span><br><span class="line">      curr_processing_row &lt;= curr_row;</span><br><span class="line">      ++curr_processing_row) &#123;</span><br><span class="line">    <span class="type">char</span> show_char = character_list[std::<span class="built_in">rand</span>() % <span class="built_in">strlen</span>(character_list)];</span><br><span class="line">    <span class="keyword">if</span>(curr_processing_row &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr_processing_row &gt;= <span class="keyword">this</span>-&gt;window_height) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr_processing_row == curr_row) &#123;</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">2</span>));</span><br><span class="line">      <span class="built_in">mvaddch</span>(curr_processing_row, column, show_char);</span><br><span class="line">      <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr_processing_row &lt; curr_row - <span class="keyword">this</span>-&gt;show_length / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">      <span class="built_in">attron</span>(A_DIM);</span><br><span class="line">      <span class="built_in">mvaddch</span>(curr_processing_row, column, show_char);</span><br><span class="line">      <span class="built_in">attroff</span>(A_DIM);</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">      <span class="built_in">mvaddch</span>(curr_processing_row, column, show_char);</span><br><span class="line">      <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Output empty char in order to solve the problem:</span></span><br><span class="line">  <span class="comment">// When clearing the screen, the terminal will flicker.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_processing_row = curr_row + <span class="number">1</span>;</span><br><span class="line">      curr_processing_row &lt; <span class="keyword">this</span>-&gt;window_height;</span><br><span class="line">      curr_processing_row++) &#123;</span><br><span class="line">    <span class="built_in">attron</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">mvaddch</span>(curr_processing_row, column, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">attroff</span>(<span class="built_in">COLOR_PAIR</span>(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Matrix::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr_column = <span class="number">0</span>; curr_column &lt; window_width; curr_column++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;<span class="built_in">ShowColumn</span>(curr_column)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">refresh</span>();</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">70000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>main.cpp</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/Matrix.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  Matrix *my_matrix = <span class="keyword">new</span> <span class="built_in">Matrix</span>();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    my_matrix-&gt;<span class="built_in">Run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> my_matrix;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夏日狂想2.0</title>
      <link href="/2023/07/14/%E5%A4%8F%E6%97%A5%E7%8B%82%E6%83%B3/"/>
      <url>/2023/07/14/%E5%A4%8F%E6%97%A5%E7%8B%82%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有时，混沌是一个巨大的黑洞，人们尽力在其中固定一个不稳定的点作为中心。有时，人们围绕这个点组建起一个平静和稳定的“形态”：黑洞已经变成一个安身之所。有时，人们在这个形态之上嫁接上一条逃离黑洞的通道。——德勒兹&amp;加塔利《资本主义与精神分裂：千高原》</p></blockquote><h1 id="开头瞎扯点东西"><a href="#开头瞎扯点东西" class="headerlink" title="开头瞎扯点东西"></a>开头瞎扯点东西</h1><p>天青色。雨下了一天。气温本来就低，教室里还开足冷气，有时令我战栗。不过也好，我喜欢冷天胜过热天。</p><p>我写东西的逻辑往往很跳跃，这和我的思维方式有关，假如说得高大上一点，是致敬德勒兹和加塔利书写《千高原》的方式——每一章之间的关系不大，单独读哪一章，都OK，不必按照章节顺序读。</p><h1 id="编程？我也不知道咋起标题"><a href="#编程？我也不知道咋起标题" class="headerlink" title="编程？我也不知道咋起标题"></a>编程？我也不知道咋起标题</h1><p>我们学校有个夏季学期，会安排一些相对不重要、主学期不大适合开的课，时长四周。我最近在上一门叫做“项目实训”的课，有Java和C++两个方向可供选择，我选择了C++。技术栈一直在Java还是C++之间游走，最终还是选择了C++，因为C++的薪资要高一些？无所谓……语言只是一门工具了，这不是最重要的部分。话说回来，所谓实训，其实和上课没啥差别，就是老师带着写个小小项目，大概内容就是讲讲Windows上的Qt开发流程和一些MySQL的知识，最终实现一个云盘。教室里没有足够的插座，我的笔记本没法充电，也就没法开我的Windows虚拟机，我也不想把自己的Linux系统替换掉，就在课上用Linux的库替换老师演示的利用Windows API的写法。说实话，挺麻烦的。</p><p>Linux让我学会了很多知识，也让我体会到类似当时MIT黑客折腾TTY的快乐。从当时折腾对桌面环境的美化，到如今自己调用Linux的一些API写小工具，我感觉自己在不断变强。在不断尝试各种发行版的同时，我也逐渐能感受到这些发行版设计者侧重什么，看轻什么。使用Linux，不能只使用那些”应用程序”，更应该去学习那种与Windows截然不同的思考方式。我们学校的LUG(Linux User Group，“自称技术宅”集中营)只有261人(群里还有许多学长，本届的学生没多少)，不过，能遇见一些志同道合的人，倒是蛮快乐的。</p><p>学技术真的挺有意思的。更好地明白机器运转的机理，把握同机器对话的规则……太爽了。根据自己的需要，结合学到的知识，写出个小工具来，成就感满满。但是那些算法，我是真的学不太懂，只能通过不断地重复来掌握了。滑窗、双指针、DP……太抽象了。</p><p>我是人工智能专业的学生。现在，AI专业出去要想有出息，只能干research相关的岗位，这东西很有意思，小厂用不到太多AI相关的东西，而大厂卷得要死，一堆牛逼的博士往里进。我倒不是怕到时候竞争不过他们，只是我对搞research毫无兴趣。所以，我现在处于这样一个状态：计科学的，我要学得比他们好；我自己AI的东西，也要弄清楚。如果到时候我在研发岗面试方面竞争不过那些人，我就要去走计科的路线。迷茫？那就去学习。</p><p>AI给我的印象是”AI&#x3D;70%数学+30%计算机”。我目前大致看了十多篇AI方面的论文，也差不多跑过相关的代码，发现AI的东西难在数学推理上，而非代码实现上。数学？你要让我上班成天和数学打交道？不是不行，就是感觉没啥意思。我更喜欢去拆解那些复杂的需求，将它们分模块大致实现出来，通过不断地修改，变成一个可以交付的项目。而且，我觉得看论文真没有看C++文档有趣。<del>我就是干脏活累活的命。</del></p><p>迷茫？那就去学习。过去虚度光阴，那就从现在开始努力嘛。</p><p>我蛮喜欢我们学校教授的授课方式，总会有意或无意地告诉你所学知识在工程上有何应用，能解决什么问题。理工类为主的大学，工程味总是蛮浓的。</p><p>如何与人交流，是另一种截然不同的方法论，我也在努力地去学习，我觉得这远比和机器交流要难。面对各式各样的竞争，我不得不去提升各方面的能力。现在，除非是蠢蛋，否则都知道提升竞争力的必要性。乘着上升气流，人活得蛮轻松；可惜逆风强劲，每个人都好累。我舍友——身边的一部分人对于未来没什么看法——仍在快乐的打游戏，求职很简单嘛？他们的生活，与我无关。</p><p>至于博客，评论区老有BUG，有啥需要联系的，还是给我发QQ邮箱吧，没事唠唠嗑也行，就是我不一定有时间……就”关于”页面里那个QQ邮箱……评论系统实在没精力修了。</p><h1 id="生活……生和死的活"><a href="#生活……生和死的活" class="headerlink" title="生活……生和死的活"></a>生活……生和死的活</h1><p>以后我会自己去一座城市打拼，租个小房子，拼出点事业来(maybe not? 富有富的活法，穷也有穷的活法嘛)，买点喜欢的书、乐器、数码设备，学学画画、写歌，自己研究研究菜谱，一个人快快乐乐地过一辈子，倒也蛮好。另一半什么的，真没必要，我的性格，若是谈恋爱、结婚了，也会让她过得不快乐，这不是出于自卑的看法，而是我对自己喜欢什么、是什么样的人、想要成为什么样的人有很清晰的认知。……孤独？受难也是人生的一部分……不是么？我不惧怕受难，也不惧怕死亡，看的那些哲学书早已告诉我，死亡没什么好怕的。有轮回也好，没有也罢(虽然我一直相信有魂灵、有转世的存在，但我不相信有神)，这都无所谓，活着有什么好的？死又有什么坏处呢？我只是乐意看这世界的变化，通过发生的事情猜测、猜不出来就去学习这世界的运转方式。</p><p>Pecunia，钱很重要。</p><p>我想要追求那种快乐——和快餐式多人游戏之类事物带来的刺激性快乐相反——类似于读书、画画的快乐。</p><p>哲学。学完马原之后看黑格尔和德勒兹不再困惑了，终于能明白那几个老头说的具体是什么了。你让我整这些理论，真整不出来。看了挺多哲学书，看完之后我自己的变化也很大，我觉得迷茫是人生的常态了，不如碰见问题的时候再去思考，平时别想太多，想了也没用，该做出选择的时候，之前想过的东西也都忘了！至于我生存的意义——拉康已经表明了，大他者(大概可以理解为最终的那个意义)永远缺失啦——就是我生存的过程，我这一生，享受当下就好，正如当时学拉丁语第一课学到的，Vive hodie！</p><p>我不知道哲学带给我的优势多，还是劣势多。我的确想通了很多事情，但也陷入一种无害的绝望当中，这种绝望——知道一切东西都没意义的绝望——让我像个旁观者，观察我的灵魂操纵着躯壳做事。我的确努力着，我好矛盾。我一直觉得我好像有精神疾病，却说不出来是哪一种，这种”疾病”也不影响我的日常生活……“意义的便秘”，齐泽克式的标题。我们每个人都缺少一种永远无法被填补的东西，这导致了我们的欲望的产生。我欲望的不是欲望的事物，而是欲望本身，只有欲望欲望本身，我才有动力活下去。</p><p>我还挺想出国生活的，但是貌似……大学出去不太可能。工作几年再考虑吧。得看我到时候混得咋样，混得好就考虑考虑润；混得不好，他妈的，混得不好更得考虑考虑啦！我对于国外的生活有着一种带滤镜的乐观，我或许需要找个机会亲自体验体验。我想要接触不同的文化，认识不同的人，让自己过得快乐些。国内的环境，戾气太重，我觉得未来迟早有一天，这些零星的火焰，会点燃整个草场，让整片大地燃烧起来，到时候，谁也逃不掉。我对于这件事还是很悲观的。</p><h1 id="结尾瞎扯点东西"><a href="#结尾瞎扯点东西" class="headerlink" title="结尾瞎扯点东西"></a>结尾瞎扯点东西</h1><p>德勒兹的书，让我想通了很多东西。</p><p>酒精让我晕乎乎的，如坠云中。我或许该去躺着休息一会，那就这样，回见！</p><blockquote><p>一个根茎可以在人一部分之中被瓦解、中断，但它会沿着自身的某条线或其他的线而重新开始。——德勒兹&amp;加塔利《资本主义与精神分裂：千高原》</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux下的问题与解决方案汇总</title>
      <link href="/2023/07/10/Arch-Linux%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/"/>
      <url>/2023/07/10/Arch-Linux%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h1><p>所用版本为10.0.2-1。</p><h2 id="qDebug无输出"><a href="#qDebug无输出" class="headerlink" title="qDebug无输出"></a>qDebug无输出</h2><p>首先，确保引入了<code>&lt;QDebug&gt;</code>头文件，并正确调用<code>qDebug()</code>，接着在“项目-&gt;运行-&gt;环境”中添加QT_ASSUME_STDERR_HAS_CONSOLE&#x3D;1这个环境变量即可。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="内核重装"><a href="#内核重装" class="headerlink" title="内核重装"></a>内核重装</h2><p>当Arch Linux系统突然断电后，有时会出现Kernel Panic或运行不正常的状况，对此，我们不需要重新安装整个系统，只需要重新安装内核即可。</p><p>首先需要一个启动盘，然后在BIOS里将引导方式调为U盘启动，然后在命令行中，先挂载主分区，然后挂载启动分区:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/root_partition /mnt</span><br><span class="line">mount --<span class="built_in">mkdir</span> /dev/efi_system_partition /mnt/boot</span><br></pre></td></tr></table></figure><p>最后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -K /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure><p>接着重新启动系统、更新软件包即可。</p><h1 id="MySQL相关环境"><a href="#MySQL相关环境" class="headerlink" title="MySQL相关环境"></a>MySQL相关环境</h1><p>目前，AUR的mysql包会直接引导安装<code>mariadb</code>或者<code>percona server</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S mariadb</span><br></pre></td></tr></table></figure><p>然后安装mariadb即可。</p><p>接着跟随Arch Wiki的指引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure><p>接着创建平时所用的非root用户，<code>some_pass</code>可修改为自定义的密码:</p><p>首先登陆root用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mariadb -u root -p</span><br></pre></td></tr></table></figure><p>接着创建普通用户，并给予全部权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;iwakura&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;some_pass&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;monty&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="MySQL-Workbench的配置"><a href="#MySQL-Workbench的配置" class="headerlink" title="MySQL Workbench的配置"></a>MySQL Workbench的配置</h1><p>安装MySQL Workbench:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S mysql-workbench</span><br></pre></td></tr></table></figure><p>点击MySQL Connections旁边的小加号，输入对应的用户名，连接即可。</p><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><h2 id="手动换源"><a href="#手动换源" class="headerlink" title="手动换源"></a>手动换源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry <span class="comment"># Show original registry</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/ <span class="comment"># Change registry to official registry</span></span><br></pre></td></tr></table></figure><h2 id="相对简单一点的换源"><a href="#相对简单一点的换源" class="headerlink" title="相对简单一点的换源"></a>相对简单一点的换源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i -g nrm <span class="comment"># Install NPM registry manager</span></span><br><span class="line">nrm use npm </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Anaconda和tmux在服务器上进行训练的流程</title>
      <link href="/2023/07/08/%E5%88%A9%E7%94%A8Anaconda%E5%92%8Ctmux%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/07/08/%E5%88%A9%E7%94%A8Anaconda%E5%92%8Ctmux%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h1><p>在Ubuntu服务器上进行训练的流程。</p><h1 id="1-Anaconda的安装和使用"><a href="#1-Anaconda的安装和使用" class="headerlink" title="1. Anaconda的安装和使用"></a>1. Anaconda的安装和使用</h1><p>Anaconda可以在无需超级管理员权限的情况下，配置任意版本的Python环境。</p><p>将安装脚本从镜像站wget到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.hit.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>接着运行该脚本，并使之生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>运行完之后，创建并启动相应版本的Python环境，可以修改env_name为任意名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name python=3.7</span><br><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure><p>若想退出环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate env_name</span><br></pre></td></tr></table></figure><h1 id="2-tmux的使用"><a href="#2-tmux的使用" class="headerlink" title="2. tmux的使用"></a>2. tmux的使用</h1><p>朴素理解，tmux是一个终端模拟器，可以在断开ssh连接下，继续运行程序。</p><p>服务器上通常安装的都是未配置的tmux。</p><p>在tmux中运行脚本，然后直接关闭ssh连接即可。</p><p>当再次连接到服务器，想查看脚本运行情况时，可输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach -t 0</span><br></pre></td></tr></table></figure><p>其中0需要被修改为当时运行脚本的窗口号。查看窗口可使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure><p>进一步了解，请参考<a href="https://www.bilibili.com/video/BV1ML411h7tF">TheCW:终端神器tmux：多任务管理大师</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暂且沉沉睡去</title>
      <link href="/2023/06/20/%E8%AE%B0%E6%A2%A6/"/>
      <url>/2023/06/20/%E8%AE%B0%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<p>我在9:40醒来，发觉今天依旧无事可干，便又沉沉睡去。</p><p>我知道我做了梦。</p><p>我不知道为什么，我在我梦中，始终是一个旅者、受难者，我前往不同的地方，遭受不同的苦难：被处刑、被追杀、被虐杀等。</p><p>我深知我的精神还算稳定，暂时没出现什么大的问题。我除了有些酗酒之外，与别人无异。</p><hr><p>我这是到访了哪里？太阳快要落山了。这里风很大，风中有一股青草的香味。</p><p>四周的住宅楼连窗户都没安装，外墙也是混凝土的灰色，上面爬满了爬山虎。它们彼此挨得很近，楼宇之间的距离约莫5厘米左右。可是沥青地面像是刚铺上的一样，黑得发亮。好奇怪。道两旁的树向道中间生长，形成了一个拱形，可是，枝条的末端光秃秃的，叶子只生长在树根附近。</p><p>这里一个人都没有，我走在沥青道上，脚下的质感逐渐变软。</p><p>月亮升起来了，占据了半面天空，它离地球是那么得近，我甚至能看到月球表面的陨石坑。我看见有蓝色、粉色的、闪着光的彗星绕着那灰不拉几的月球转动。我知道那蓝色彗星来自于哪里，也知道那粉色彗星终究是要坠落于月球上的，但我什么也没说。月亮缓慢地转动着。</p><p>这个地方给我一种熟悉的温暖感觉，让我浑身轻飘飘的。</p><p>……</p><p>我听见有人说话，旁边的人也多了起来。我听见有孩子在说在学校的见闻、也听见有上班族在和伴侣倾诉……我看见身旁的人们，脸上都洋溢着笑容。这里像是我的家乡一样，这些人我好像都认识，却又说不上名字来。我也很想像他们一样快乐。</p><p>“不要……被……浪潮……冲走……”</p><p>我脚下一空，身体也随之向下坠落。我的脚被一根藤条勾住。</p><p>人们的声音消失了，只有风声，我看见这悬崖的底下尽是枯骨。</p><hr><p>我瞬间被抽离。眼前的光景消逝了。一切色彩都变成黑白，接着，从四周向中间变为纯粹的、不留余地的黑暗。</p><p>我系好安全带，看向窗外的云层，月亮皎洁无暇。我在微微震动的座椅上难以入睡。</p><p>我只得尝试闭眼。我在大脑里和自己玩游戏，我想像出一个迷宫，和自己捉迷藏。</p><p>红砖砌成的墙，上面爬满了爬山虎；地面用青石块铺成，滑滑的；一片漆黑。我一直在转弯，我一直听见前面的拐角有脚步声，看见前面的拐角有黑影。我就这样一直走着。当我走过一个拐角，我向后望去，我看见一双血红的眼睛，直勾勾地盯着我，如同火焰。</p><p>那火焰，点燃了整个机舱，向下、向下。</p><hr><p>10：54，我昨夜睡得很安稳。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不协和音程</title>
      <link href="/2023/06/14/%E4%B8%8D%E5%8D%8F%E5%92%8C%E9%9F%B3%E7%A8%8B/"/>
      <url>/2023/06/14/%E4%B8%8D%E5%8D%8F%E5%92%8C%E9%9F%B3%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>我宁愿在毫无意义的事物中消耗自己的精力，也不愿触及那真正令我痛苦、令我受难的一点记忆。</p><p>Kernel panic.</p><p>人就像是一个中了定时病毒操作系统，在某些特定的时刻，这些病毒会开始运作，扰乱正常的工作状态……</p><p>KeRnEl pAnIc.</p><p>KeRNeL PanIC.</p><p>我该怎么修复这个系统呢？我不知道……我对着“灵魂”这个荧幕束手无策，我看着那些想法、情感在荧幕上飞来飞去，却什么也做不了……我只能静静地等待一切都恢复沉寂。我也可以用酒精麻痹自己，但是这……这对我的身体有害。</p><p>过去的自己是我吗？我宁愿不是。但我没法说服我自己。我任由那段记忆将我绑在柱子上，用力鞭笞，提醒着我我曾经的所作所为。我将自己推进髑髅地，如今找不到离开的路了。神灵、书本、音乐都没法帮助我。</p><p>这些都是过去的事情了。</p><p>……</p><p>我感觉这种煎熬在变淡，或许某日我将毫无痛苦地将这段记忆讲出来，或许不能——这是一种更残忍的残忍。</p><p>充其量，在未来，这就是个普普通通的小秘密罢了；在未来，我会嘲笑过去为这点“小事”悲天哀地的自己；在未来，我将释然，抑或……麻木……</p><hr><p>自打新冠好了之后，感觉自己身体出了点小问题。打字老打错，走路有的时候也会走不稳，协调性大大下降，好在这些情况出现的概率很小很小。</p><hr><p>北国的夏天也很热，我记得我小时候夏天是很凉快的，温室效应……？夏天就要吃着冰棍，开着空调，在房间里追剧打游戏嘛！</p><p>然而我还在苦逼地复习期末考试，一门令我痛苦不已的课，集最优化、线性代数pro max、高等数学、信息论和矩阵论于一体的“AI数学基础”。我真学不懂，好在期末考试在成绩中的占比比较小，不大可能挂。数学很有意思，但是数学课就不那么有意思了。</p><p>现在感觉上课真没什么意思。上课的时候，老师讲得没意思，自己也听不进去。还不如这样：学期开始通知我要学的内容，把PPT都发下来，自学一个学期，最后期末考试。这样，我的表现或许还能好点，顺着老师的讲课路线，我真的很难理解课程的内容。</p><p>最近在想要不要写个小项目，平时太闲啦，没事做。（还不是因为太闲了，才胡思乱想！）平时写的工具大多几十行，最多也就150行左右。还是要练一练写中型项目的能力啊。时间不能这样白白地从手指缝间溜走。</p><p>functional programming好像也挺有意思的，暑假研究研究。</p><hr><p>如果长时间将两块金属板用力贴在一起，它们最终会粘在一起，无法分离。时间、外力会让一些看起来不可能的事情发生。</p><p>如果人们长时间都彼此互不信任，而某种外力又在驱使人们彼此猜疑，那么终会有许许多多看起来很荒诞的事情发生。鲜血、侮辱、不合时宜的包庇……等等。</p><p>最近发生的许多事都令我和我的朋友们诧异，原来人与人之间的关系以及恶化成这个样子了。似乎人们都得了被害妄想症，脑子里早已预设了一个大前提——其他人对我是充满恶意的……</p><p>现实将越来越极端。</p><p><del>自由、平等、博爱。</del></p><blockquote><p>进入爱，是根本性的革命行为，是抵抗当今乏味的、社会限制的、文化紧缩的世界的先决条件。</p><p>……</p><p>同样，爱对当下的政治制度构成了威胁，因为很难说服一个在个人关系中拥有丰富东西的人愿意为 “国家” 这样的抽象事物而战斗和牺牲；就这一点而言，可能甚至很难说服他去交税。爱对各种文化都构成了威胁，因为当人类被真爱赋予智慧和勇气时，他们就不会被那些与指导他们的感情完全无关的传统或习俗所牵制。</p></blockquote><hr><p>我的命运驱使着我向前。我不得不向前，除去向前，我没有任何体验生命的方法。</p><p>生命的那些悲苦、快乐、压抑、解放……多么美好。</p><p>可是突然，我又一次陷入迷茫中去了，我好渺小。我也不知道这种迷茫来自于哪里。我厌恶容易情感突变的自己。</p><p>平行世界中的我会不会也在想这些问题呢，我们要是能交流就好了。我没什么人可以去聊这些东西……其实也没有必要，和他人交流也没法缓解自己的苦闷。这些东西，好像就得一个人去感受。</p><p>我是如此的矫情——在当下的快乐里寻觅可能到来的悲苦，在当下的悲苦里默默下沉，好像我来到这个世界上就是为了受罪似的。但是这种矫情——这种被人诟病的矫情——似乎在让我的心理承受能力变强，这就像是个游戏一样，残酷的游戏而已。我知道这和我的经历有很大的关系，可我又没办法处理这些问题，实际上，我连问题是什么都没法好好描述出来，如鲠在喉。我不断地从书本、音乐之类的东西寻找答案。我找不到，我知道我肯定找不到。或许根本没有什么问题吧。呵，疑病妄想。</p><p>我在受难。我总是没来由地相信，未来的自己会更好。或许是这样的，或许又不是。我像是一个观众，看着自己在这世界上不断“打怪升级”。</p><p>我是一团乱麻，一团乱码，乐观的悲观主义者，悲观的乐观主义者，“不理想的理想主义者”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】机器学习与深度学习备忘</title>
      <link href="/2023/06/07/%E3%80%90AI%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/07/%E3%80%90AI%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>机器学习是指，从数据出发来学习数据中蕴含的某种模式，对数据进行抽象。</p><p>其大概分为三类，有监督的学习，无监督的学习和强化学习。</p><h1 id="1-监督学习"><a href="#1-监督学习" class="headerlink" title="1. 监督学习"></a>1. 监督学习</h1><p>将被标记的数据结合一定算法，得到映射模型的过程，就是监督学习。常应用于分类、回归、识别、推荐等需求上。</p><p>其过程大致如下：将所有标记好的数据分为训练集和测试集，在训练集上进行训练，得到模型，在测试集上对训练得到的模型进行测试。</p><p>我们常用损失函数(Loss Function)作为测试的度量，应用损失函数，在训练集中计算得到的数据损失称作经验风险(empirical risk)；在测试集中计算得到的，称作期望风险(expected risk)。我们最终想要的结果，便是让经验风险、期望风险都尽可能最小化。如果经验风险小，期望风险也小，这表明我们得到的模型泛化能力较好；如果经验风险小，而期望风险大，表明模型发生了<strong>过拟合</strong>现象；如果两个风险都很大，表明模型发生了<strong>欠拟合</strong>；如果经验风险大，而期望风险小——这代表数据集的设置出现了一些问题。损失函数包括：均方误差、交叉熵等函数。</p><p>监督学习常用两种模型：判别模型(discriminative model)和生成模型(generative model)。前者关心一个输入对应的输出应该是什么；后者关心一个输入对应的所有输出的分布概率。</p><p>线性回归、K近邻算法等都属于监督学习的范畴。</p><h1 id="2-无监督学习"><a href="#2-无监督学习" class="headerlink" title="2. 无监督学习"></a>2. 无监督学习</h1><p>无监督学习不需要对数据进行标记，而是通过对数据的分析和处理来发现数据中的规律、关系和内在结构。主要任务为聚类、降维和关联规则挖掘。</p><p>K均值聚类算法属于该范畴。</p><h1 id="3-强化学习"><a href="#3-强化学习" class="headerlink" title="3. 强化学习"></a>3. 强化学习</h1><p>强化学习模拟智能体与环境的交互。</p><p>马尔可夫决策过程属于该范畴。</p><h1 id="4-深度学习"><a href="#4-深度学习" class="headerlink" title="4. 深度学习"></a>4. 深度学习</h1><p>模拟大脑处理信息的方式，对各类数据进行处理。</p><h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><p>神经元接收输入，处理之后再输出。McCulloch和Pitts俩大神基于这种工作方式提出了MCP模型。</p><p>MCP模型结构很简单：一个神经元对来自多个前面的神经元的输入，进行线性的加权求和，将和通过某种函数(激活函数)映射到0&#x2F;1，接着输出到后面的神经元。Sigmoid函数、ReLU函数都常用作激活函数。通过对多个激活函数的组合，可以对输入信息进行更为复杂的非线性变换。</p><p>单层感知机和MCP结构类似，感知机的输入层负责接收实数值为输入，通过线性加权求和、非线性变换，最终输出，输出的值要么为1，要么为-1。</p><p>后来，将多个单层感知机按层拼起来，就得到了多层感知机，其由输入层、输出层和至少一层的隐藏层构成，隐藏层中的神经元接收前层信息，处理后将信息发给后续隐藏层中的所有神经元。通过梯度下降、误差反向传播等算法，可以使得损失函数最小化，优化网络的参数。网络的参数常为线性加权求和的参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】贝叶斯推理网络</title>
      <link href="/2023/06/06/%E3%80%90AI%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E7%90%86%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/06/06/%E3%80%90AI%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E7%90%86%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>除了自然演绎推理等方法之外，我们也可以从概率论的角度入手，表示知识，进行推理，分析问题。</p><h1 id="1-表示方法"><a href="#1-表示方法" class="headerlink" title="1. 表示方法"></a>1. 表示方法</h1><p>贝叶斯网络是一个有向无环图，每一个节点代表一个变量，也代表着一个<strong>条件概率</strong>。父节点指向子节点的有向边，并不代表因果关系，而是表示两个节点之间的相关性。每个节点的条件概率以父节点的取值为条件，若$X$节点有$a_1,a_2,\cdots,a_n$共$n$个父节点，其代表的条件概率就是$P(X|a_1a_2\cdots a_n)$。</p><p>贝叶斯网络使用简单的局部概率分布（条件概率）来描述复杂联合概率分布。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><p>基于贝叶斯公式和相关知识：</p><h3 id="全部节点的联合概率"><a href="#全部节点的联合概率" class="headerlink" title="全部节点的联合概率"></a>全部节点的联合概率</h3><p>假设贝叶斯网络里有$X_1,X_2,\cdots,X_n$节点，那么将所有变量的条件概率相乘，就得到了所有变量的联合概率，即:<br>$$<br>P(X_1,X_2,\cdots,X_n)&#x3D;\prod_{i&#x3D;1}^{a}P(X_i|Parents(X_i))<br>$$</p><h3 id="节点之间的条件独立性判别法-d-seperation"><a href="#节点之间的条件独立性判别法-d-seperation" class="headerlink" title="节点之间的条件独立性判别法: d-seperation"></a>节点之间的条件独立性判别法: d-seperation</h3><p>若随机变量$X,Y$在条件$C$下条件独立，则有：<br>$$<br>P(X,Y|C)&#x3D;P(X|C)P(Y|C)<br>$$<br>意思就是，在$C$发生的情况下，$X,Y$发生与否与彼此是否发生无关。</p><p>d-分离的定义如下：路径$p$被限定集$Z$阻塞(block)当且仅当：</p><ul><li>路径$p$含有因果链结构$A\to B\to C$或分连结构$A\leftarrow B\to C$且中间节点$B$在$Z$中。</li><li>路径$p$含有汇连结构$A\to B\leftarrow C$且汇连节点$B$及其后代都不在$Z$中。</li></ul><p>若$Z$阻塞了节点$X$和节点$Y$之间的每一条路径，则称给定$Z$时，$X$和$Y$是d-分离的，即给定$Z$时，$X$和$Y$条件独立。</p><p>举个例子，在贝叶斯网络中，根据节点不同的连接方式，可以得到不同的条件独立关系：</p><ol><li><p>因果链(Serial Connection，或head-to-tail)</p><p>若确定$X_k$，则$X_iX_j$条件独立。</p><p><img src="https://pic3.zhimg.com/80/v2-cedd2ceaa71ac064c580bf2eff65a0d2_720w.webp" alt="img"></p></li><li><p>分连(Diverging connection，或tail-to-tail)</p><p>若确定$X_k$，则$X_iX_j$条件独立。</p><p><img src="https://pic3.zhimg.com/80/v2-35f82b7caf69b09b704d15b4b70e18ba_720w.webp" alt="img"></p></li><li><p>汇连(Converging connection)</p><p>确定$X_k$，$X_iX_j$相关，否则二者条件独立。</p><p><img src="https://pic4.zhimg.com/80/v2-40e784eff12ffbdb8dcb47e61671f1ab_720w.webp" alt="img"></p></li></ol><h1 id="3-贝叶斯网络的概率计算"><a href="#3-贝叶斯网络的概率计算" class="headerlink" title="3. 贝叶斯网络的概率计算"></a>3. 贝叶斯网络的概率计算</h1><p>更加精确地描述该问题：给定贝叶斯网络，如何计算某一个变量的概率。</p><h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>穷举变量的每一种可能性，然后加和即可，该方法简单，但是复杂度过高。</p><h2 id="变量消除法"><a href="#变量消除法" class="headerlink" title="变量消除法"></a>变量消除法</h2><p>您可以在参考资料中查看相关的操作方法。该方法的思路是，将条件概率分隔开，每次运算都消除一部分变量。</p><h2 id="采样法"><a href="#采样法" class="headerlink" title="采样法"></a>采样法</h2><p>从概率分布中，抽取N个样本，计算概率即可。然而采样也有多种方式：</p><h3 id="1-拒绝采样"><a href="#1-拒绝采样" class="headerlink" title="1. 拒绝采样"></a>1. 拒绝采样</h3><p>对于后验概率来说，如果我们想要求解$P(C|+s)$（s发生的条件下C发生的概率），那么我们就可以在采样时忽略掉s不发生的样本。这样最终得到的样本数除以总样本数就是该后验概率的值。但是，该方法在C发生概率很小的时候效果不够好。会拒绝掉很多样本。</p><h3 id="2-似然加权采样"><a href="#2-似然加权采样" class="headerlink" title="2. 似然加权采样"></a>2. 似然加权采样</h3><p>求取$P(C|+s,+w)$之类的后验概率时，我们只生成符合$+s,+w$的样本，对除$s，w$以外的变量赋予一个权重，最终计算出相应的概率值。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/41106670">d-seperation</a></p><p><a href="https://zhuanlan.zhihu.com/p/357474438">【机器学习系列】概率图模型第四讲：变量消除法和Belief Propagation算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】推理系统相关备忘</title>
      <link href="/2023/06/06/%E3%80%90AI%E3%80%91%E6%8E%A8%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/06/06/%E3%80%90AI%E3%80%91%E6%8E%A8%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-带有量词的自然演绎推理系统结论备忘"><a href="#1-带有量词的自然演绎推理系统结论备忘" class="headerlink" title="1. 带有量词的自然演绎推理系统结论备忘"></a>1. 带有量词的自然演绎推理系统结论备忘</h1><p>$$<br>\neg (\exist x)P\Leftrightarrow (\forall x)(\neg P)<br>$$</p><p>$$<br>\neg(\forall x)P\Leftrightarrow(\exist x)(\neg P)<br>$$</p><p>$$<br>(\forall x)(P\wedge Q)\Leftrightarrow(\forall x)P\wedge(\forall x)Q<br>$$</p><p>$$<br>(\exist x)(P\vee Q)\Leftrightarrow(\exist x)P\vee(\exist x)Q<br>$$</p><h1 id="2-谓词公式的置换和合一"><a href="#2-谓词公式的置换和合一" class="headerlink" title="2. 谓词公式的置换和合一"></a>2. 谓词公式的置换和合一</h1><h2 id="置换的概念"><a href="#置换的概念" class="headerlink" title="置换的概念"></a>置换的概念</h2><p>置换是形如：<br>$$<br>\theta&#x3D;{t_1&#x2F;x_1, t_2&#x2F;x_2, \cdots,t_n&#x2F;x_n}<br>$$<br>的有限集合，其中$t_i$是谓词中的项，$x_i$是互不相同的变量，$t_i&#x2F;x_i$表示用前者替换后者。要求：$t_i\neq x_i$。</p><h2 id="置换的合成"><a href="#置换的合成" class="headerlink" title="置换的合成"></a>置换的合成</h2><p>设：<br>$$<br>\theta&#x3D;{t_1&#x2F;x_1, t_2&#x2F;x_2, \cdots,t_n&#x2F;x_n},\lambda&#x3D;{u_1&#x2F;y_1,u_2&#x2F;y_2,\cdots,u_n&#x2F;y_n}<br>$$<br>是两个置换，则将集合：<br>$$<br>\gamma&#x3D;{t_1\lambda&#x2F;x_1,t_2\lambda&#x2F;x_2,\cdots,u_1&#x2F;y_1,u_2&#x2F;y_2,\cdots,u_n&#x2F;y_n}<br>$$<br>中符合下列条件的元素删除：</p><ol><li>$t_i\lambda&#x2F;x_i$，其中$t_i\lambda&#x3D;x_i$。</li><li>$u_i&#x2F;y_i$，其中$y_i\in {x_1,x_2,\cdots,x_n}$。</li></ol><p>如此得到的集合$\gamma$是一个置换，且：<br>$$<br>\gamma&#x3D;\theta·\lambda<br>$$<br>什么意思？首先将$\lambda$置换应用到$\theta$置换上，$t_i\lambda&#x2F;x_i$的意思是说，先使用$\lambda$变换替换$t_i$，再应用$\theta$本身的替换方法，使用$x_i$替换$t_i\lambda$。对于有些变元，在$\theta$变换中未被替换，就需要把一些在$\lambda$变换中出现的规则添加到集合中，最后去重，则得到合成的集合。</p><p>举个例子，求下面两个置换的合成：<br>$$<br>\theta&#x3D;{b&#x2F;y,c&#x2F;z},\lambda&#x3D;{x&#x2F;a,y&#x2F;b}<br>$$<br>得到集合：<br>$$<br>\gamma&#x3D;{b\lambda&#x2F;y,c\lambda&#x2F;z,x&#x2F;a,y&#x2F;b}<br>$$<br>其中：<br>$$<br>b\lambda&#x3D;y<br>$$<br>集合变化成：<br>$$<br>\gamma&#x3D;{y&#x2F;y,c&#x2F;z,x&#x2F;a,y&#x2F;b}<br>$$<br>去重：<br>$$<br>\gamma&#x3D;{c&#x2F;z,x&#x2F;a,y&#x2F;b}<br>$$</p><h2 id="合一的概念"><a href="#合一的概念" class="headerlink" title="合一的概念"></a>合一的概念</h2><p>设有公式集：<br>$$<br>F&#x3D;{F_1,F_2,\cdots,F_n}<br>$$<br>若存在一个置换$\theta$，令：<br>$$<br>F_1\theta&#x3D;F_2\theta&#x3D;\cdots&#x3D;F_n\theta<br>$$<br>则称$\theta$为$F$的一个合一。</p><h2 id="最一般合一"><a href="#最一般合一" class="headerlink" title="最一般合一"></a>最一般合一</h2><p>设$\sigma$是$F$的一个合一，若对$F$的任何一个合一$\theta$都存在一个置换$\lambda$，令$\theta&#x3D;\sigma·\lambda$，则称$\sigma$是一个最一般合一(most general unifier)，简记为mgu。</p><h1 id="3-归结演绎推理"><a href="#3-归结演绎推理" class="headerlink" title="3. 归结演绎推理"></a>3. 归结演绎推理</h1><p>通过某些方法，可以简化表达式。</p><h2 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h2><p>所有量词均非否定地出现在公式最前面，且辖域为整个公式。</p><p>比如：<br>$$<br>(\forall x)(\forall y)(P(x)\vee Q(y)\vee R(x, y))<br>$$</p><h2 id="化简方法"><a href="#化简方法" class="headerlink" title="化简方法"></a>化简方法</h2><p>在谓词逻辑中，任何一个谓词公式都可以通过推理规则化简。</p><h3 id="1-消去推导义连接词"><a href="#1-消去推导义连接词" class="headerlink" title="1. 消去推导义连接词"></a>1. 消去推导义连接词</h3><p>通过应用：<br>$$<br>P\to Q\Leftrightarrow \neg P\vee Q<br>$$</p><p>$$<br>P\leftrightarrow Q\Leftrightarrow (P\wedge Q)\vee(\neg P\wedge\neg Q)<br>$$</p><p>可消去谓词公式中的$\to$和$\leftrightarrow$两个连接词。</p><p>对于公式:<br>$$<br>(\forall x)((\forall y)P(x,y)\to\neg(\forall y)(Q(x,y)\to R(x,y)))<br>$$<br>可化简为：<br>$$<br>(\forall x)(\neg(\forall y)P(x,y)\vee \neg(\forall y)(\neg Q(x,y)\vee R(x,y)))<br>$$</p><h3 id="2-减少否定符号的辖域"><a href="#2-减少否定符号的辖域" class="headerlink" title="2. 减少否定符号的辖域"></a>2. 减少否定符号的辖域</h3><p>通过应用带有量词的自然演绎推理系统结论和摩根定律，可令否定词$\neg$的辖域最多只作用于一个谓词上。</p><p>上面的公式可以化简为：<br>$$<br>(\forall x)((\exist y)\neg P(x,y)\vee(\exist y)(Q(x,y)\wedge\neg R(x,y)))<br>$$</p><h3 id="3-标准化变元"><a href="#3-标准化变元" class="headerlink" title="3. 标准化变元"></a>3. 标准化变元</h3><p>让变元的名字尽可能不同。</p><p>上面的公式可以化简为：<br>$$<br>(\forall x)((\exist y)\neg P(x,y)\vee(\exist z)(Q(x,z)\wedge\neg R(x,z)))<br>$$</p><h3 id="4-化为前束范式"><a href="#4-化为前束范式" class="headerlink" title="4. 化为前束范式"></a>4. 化为前束范式</h3><p>因为我们将变元标准化了，所以可以把量词移动到最前面。</p><p>上面的公式可以化简为：<br>$$<br>(\forall x)(\exist y)(\exist z)(\neg P(x,y)\vee (Q(x,z)\wedge R(x,z)))<br>$$</p><h3 id="5-消除存在量词"><a href="#5-消除存在量词" class="headerlink" title="5. 消除存在量词"></a>5. 消除存在量词</h3><p>消去存在量词时，需要区分以下两种情况：</p><ol><li>若存在量词不出现在全称量词的辖域内（即它的左边没有全称量词），只要用一个新的个体常量替换受该存在量词约束的变元，就可消去该存在量词。</li><li>若存在量词位于一个或多个全称量词的辖域内，则需要用到Skolem函数。</li></ol><p>Skolem函数为：<br>$$<br>(\forall x)(\forall y)(\exist z)(P(x,y, z))\Leftrightarrow \forall xP(x, y, f(x,y))<br>$$<br>上面的公式可以化简为：<br>$$<br>(\forall x)(\neg P(x, f(x))\vee (Q(x, g(x))\wedge \neg R(x, g(x))))<br>$$</p><h3 id="6-化为Skolem标准型"><a href="#6-化为Skolem标准型" class="headerlink" title="6. 化为Skolem标准型"></a>6. 化为Skolem标准型</h3><p>应用如下关系：<br>$$<br>P\vee(Q\wedge R)\Leftrightarrow (P\vee Q)\wedge(P \vee R)<br>$$<br>上面的公式可以化简为：<br>$$<br>(\forall x)(\neg P(x, f(x))\vee (Q(x, g(x))\wedge (\neg P(x, f(x))\wedge \neg R(x, g(x))))<br>$$</p><h3 id="7-消除全称量词"><a href="#7-消除全称量词" class="headerlink" title="7. 消除全称量词"></a>7. 消除全称量词</h3><p>直接省略全称量词即可。</p><p>上面的公式可以化简为：<br>$$<br>\neg P(x, f(x))\vee (Q(x, g(x))\wedge (\neg P(x, f(x))\wedge \neg R(x, g(x)))<br>$$</p><h3 id="8-消除合取词"><a href="#8-消除合取词" class="headerlink" title="8. 消除合取词"></a>8. 消除合取词</h3><p>将前束范式拆成一系列子句。以合取词$\wedge$为分割。</p><p>上面的公式可以拆分为：<br>$$<br>\neg P(x,f(x))\vee Q(x,g(x))<br>$$</p><p>$$<br>\neg P(x,f(x))\vee\neg R(x,g(x))<br>$$</p><h3 id="9-改变量名"><a href="#9-改变量名" class="headerlink" title="9. 改变量名"></a>9. 改变量名</h3><p>令子句间，彼此没有共同变量。更改变量名，不会改变子句的真值。</p><p>上面的公式可以变为:<br>$$<br>\neg P(x,f(x))\vee Q(x,g(x))<br>$$</p><p>$$<br>\neg P(y,f(y))\vee\neg R(y,g(y))<br>$$</p><h3 id="10-通过子句的真值，判断原式的真值"><a href="#10-通过子句的真值，判断原式的真值" class="headerlink" title="10. 通过子句的真值，判断原式的真值"></a>10. 通过子句的真值，判断原式的真值</h3><p>子句之间是合取关系，子句集中若有一个子句不可满足，则子句集不可满足。此外，空子句也不可满足。</p><p>怎么判断？应用鲁滨逊归结原理。这个原理的思想很简单，归结时，删除句子中的互补源自谓词公式，即$\neg P $和$P$。</p><p>假设有三个子句：<br>$$<br>C_1 &#x3D; \neg P \vee Q<br>$$</p><p>$$<br>C_2 &#x3D; \neg Q<br>$$</p><p>$$<br>C_3 &#x3D; P<br>$$</p><p>应用归结定理将他们归结起来得到的结果，就是原式子的结果。</p><p>先归结$C_1C_2$，得到$\neg P$，再和剩下的子句归结，得到空子句，不可满足。</p><p>这里也有几个重要的结论：设$C_1C_2$归结得到$C_{12}$，则有$C_{12}&#x3D;C_1C_2$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】知识的表示方法</title>
      <link href="/2023/06/05/%E3%80%90AI%E3%80%91%E7%9F%A5%E8%AF%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2023/06/05/%E3%80%90AI%E3%80%91%E7%9F%A5%E8%AF%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>人工智能有三大关键要素：算法、数据和算力。将人工智能的训练工作比作造房子，数据就是建造房子所需要的石头、木头、砂浆等材料；算法就是房子的组成方式、造房子的方法等；算力就是吊车、独轮手推车一类的工具。</p><p>要想让计算机具有智能，首先要让它拥有知识。知识的表示方法，也是人工智能训练绕不过去的一个问题。</p><h1 id="1-一阶谓词逻辑表示法"><a href="#1-一阶谓词逻辑表示法" class="headerlink" title="1. 一阶谓词逻辑表示法"></a>1. 一阶谓词逻辑表示法</h1><p>“一阶谓词逻辑表示法是一种重要的知识表示方法，其以数理逻辑为基础，能够精确表达人类的思维活动规律。”，一些教科书上写道。这种表示法，就是采用一套符号系统，来表示对世界的描述性陈述，并在此基础上进行推导。</p><p>该表示系统有三个核心概念：</p><ul><li>个体：表示独立存在的事物。用小写表示。</li><li>谓词：用来描述个体的属性和个体之间关系，具有真假性。用大写字母表示。</li><li>量词：包括全称量词和存在量词，分别表示“对于任意的……，都……”和“存在……，使得……”的关系。</li></ul><p>此外，还有一些连接词，比如：</p><ul><li>合取词$\wedge$，其两侧命题同时为真，才为真。</li><li>析取词$\vee$，其两侧命题有一为真，则为真。</li><li>…</li></ul><p>举个例子，如何用该系统表示“只要你是一个人，就会死”呢？<br>$$<br>(\forall x)(P(x)\to D(x))<br>$$<br>其中，$x$代表个体，$P(x)$代表$x$是一个人类，$D(x)$代表$x$是会死的，中间的箭头表示推导出。</p><p>至于在该表示系统上的推理，可以使用数理逻辑的相关知识。</p><h1 id="2-产生式表示法"><a href="#2-产生式表示法" class="headerlink" title="2. 产生式表示法"></a>2. 产生式表示法</h1><p>有很多知识，可以被理解为规则。举个例子，“一个水分子由两个氢原子和一个氧原子组成”，就可以抽象成if…then…形式的语句：If 一个分子是水分子, then 这个分子由两个氢原子和一个氧原子组成。产生式表示法就是应用if…then…形式的语句来表示知识的一个系统。</p><p>对于确定的知识，我们可以这么表示：</p><p>If 前提, then 结论。</p><p>对于不确定的知识，我们可以这么表示：</p><p>If 前提, then 结论 （置信度）。</p><p>此外，这种表示系统可以用与或树来表示。对于如下的形式，可以用与节点表示：</p><p>If 前提1 and 前提2…, then 结论。</p><p>对于如下的形式，可以用或节点表示：</p><p>If 前提1 or 前提2…, then 结论。</p><p>这样我们便可以通过一系列已有的前提，得出相应的结论。</p><h1 id="3-语义网络表示法"><a href="#3-语义网络表示法" class="headerlink" title="3. 语义网络表示法"></a>3. 语义网络表示法</h1><p>不同的物品、概念间有着不同的关系。如果我们用节点表示物品，用有向边代表关系，就成功地用图表示了知识。</p><p>语义网络的基本结构很简单：</p><p>节点1-具有意义的有向边-节点2</p><p>有向边的意义有很多种，比如：</p><h2 id="实例关系：ISA"><a href="#实例关系：ISA" class="headerlink" title="实例关系：ISA"></a>实例关系：ISA</h2><p>“我是一个人”，这个知识就可以表示成：</p><p>我–ISA-&gt;人</p><p>其中，ISA为is a，表示“……是一个……”、个体与集合的关系、“具体与抽象”的关系。</p><h2 id="分类关系：AKO"><a href="#分类关系：AKO" class="headerlink" title="分类关系：AKO"></a>分类关系：AKO</h2><p>“鸵鸟属于鸟类”，可以表示成：</p><p>鸵鸟–AKO-&gt;鸟类</p><p>其中，AKO为a kind of，表示“……是一种……”、集合与集合的关系、“子类与超类”的关系。</p><h2 id="聚类关系：Part-of"><a href="#聚类关系：Part-of" class="headerlink" title="聚类关系：Part-of"></a>聚类关系：Part-of</h2><p>“手属于人体”，可以表示成:</p><p>手–Part-of-&gt;人体</p><p>表示“……是……的一部分”的关系。</p><h2 id="属性关系：have"><a href="#属性关系：have" class="headerlink" title="属性关系：have"></a>属性关系：have</h2><p>“人体有手”，可以表示成：</p><p>人体–have-&gt;手</p><p>表示“……有……”的关系。</p><h2 id="情况与动作的表示"><a href="#情况与动作的表示" class="headerlink" title="情况与动作的表示"></a>情况与动作的表示</h2><p>节点可以用来表示事件或者动作。</p><p><img src="/2023/06/05/%E3%80%90AI%E3%80%91%E7%9F%A5%E8%AF%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/1.png"></p><h2 id="连接词和量词的表示"><a href="#连接词和量词的表示" class="headerlink" title="连接词和量词的表示"></a>连接词和量词的表示</h2><p>合取、析取关系，可以通过引入相应的节点来表示。</p><p>对于否定、蕴含关系和存在量词，则可以通过引入相应的关系来表示。</p><p>对于全程量词则可以通过分块语义网络表示：</p><p><img src="/2023/06/05/%E3%80%90AI%E3%80%91%E7%9F%A5%E8%AF%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/2.png"></p><p>GS，表示所有全称实例的集合；G表示某一个全称实例，G的辖域（或者说，G所表示的具体内容），就是那条标记F的有向边所指向的方块。在这个方块里面，R是一个动作，是一种学习方式，学习的主体是S，S是一个学生，客体是P，P是一门外语。</p><h1 id="4-框架表示法"><a href="#4-框架表示法" class="headerlink" title="4. 框架表示法"></a>4. 框架表示法</h1><blockquote><p>这个表示系统里面，很多词翻译得都很奇怪。</p></blockquote><p>和语义网络表示法差不多，框架表示法用一种类似于键值对的方式存储数据。</p><p>首先，我们用一个Frame(框架)来表示一个物品、概念。该框架下面，包含着若干Slot，Slot用来表示该Frame的一些特征，接着，每个Slot(槽)都有一些Facet(侧面，一个方面)，Facet用来描述Slot的不同属性。</p><p>举个例子，一个景德镇制造的白色的陶瓷水杯可以用如下的框架来表示：</p><p>Frame: 水杯</p><p>Slot1 颜色：白色</p><p>Slot2 材质：陶瓷</p><p>Slot3 产地： </p><p>Facet1 国家：中国</p><p>Facet2 具体地址：景德镇</p><p>框架之间可以彼此继承，比如水杯这个框架可以继承自生活用品的框架。</p><p>面向对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法&amp;AI】搜索策略</title>
      <link href="/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>搜索，就是通过一定算法对状态空间进行分割，选出所需的解。</p><h1 id="1-搜索算法的形象化描述"><a href="#1-搜索算法的形象化描述" class="headerlink" title="1. 搜索算法的形象化描述"></a>1. 搜索算法的形象化描述</h1><h2 id="抽象为图"><a href="#抽象为图" class="headerlink" title="抽象为图"></a>抽象为图</h2><p>形象化搜索问题有助于我们设计相关的算法。举个例子，对于如下的二阶汉诺塔问题：</p><blockquote><p>设有三根钢针，它们的编号分别是1号、2号和3号。在初始情况下，1号钢针上穿有A、B两个金片，A比B小，A位于B的上面。要求把这两个金片全部移到另一根钢针上，而且规定每次只能移动一个金片，任何时刻都不能使大的位于小的上面。</p></blockquote><p>我们可以做出如下的抽象：</p><p>设定一些状态，用二元组表示，对于任意时刻$k$，任意的二元组$S_k&#x3D;(S_{k0}, S_{k1})$，$S_{k0},S_{k1}$分别表示A和B所在的钢针号。</p><p>接着，我们可以抽象出这样一张图：</p><p><img src="/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/1.png"></p><p>从$(1,1)$到$(2,2)$或$(3,3)$的所有路径都是可行解。</p><h2 id="抽象为树"><a href="#抽象为树" class="headerlink" title="抽象为树"></a>抽象为树</h2><p>这种抽象方法很简单，程序也易于编写，思想是：从起点开始，将所有的可能节点列为子节点。</p><p>但是，这种方法会导致抽象出来的结果出现大量重复的结构。</p><h2 id="与或树"><a href="#与或树" class="headerlink" title="与或树"></a>与或树</h2><p>一个问题，可以被分解为不同的部分，解决所有部分也就解决了该问题；可以被分割成不同的等价的子问题，解决任一子问题，也就相当于解决了该问题。当这两种分割方式同时存在时，就可以使用与或树表示。</p><p>与或树里包含着几种节点：</p><ul><li>叶子节点</li><li>与节点：与节点代表的问题被分割成很多部分。</li><li>或节点：或节点代表的问题被分割成很多等价的子问题。</li></ul><p>看个例子吧：</p><p><img src="https://img2018.cnblogs.com/i-beta/1358881/201912/1358881-20191218163659477-326368179.png" alt="img"></p><p>叶节点用弧表示的，是与节点；不带弧的，是或节点。根节点引出的“2”“3”两个节点就是与节点。</p><h1 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2. 深度优先搜索"></a>2. 深度优先搜索</h1><p>若能够将问题抽象为图，便可以应用图论的相关算法，深度优先搜索(DFS)便是其中一个。它可以用来搜索一条从起点到终点的路径。</p><p>若想进行深度优先搜索，则需要用到栈。</p><p>该算法的思想是，逐条探寻可行路径。</p><p>该算法步骤如下：</p><ol><li>从起点开始，沿着任意一条边探索下去。将探索到的点入栈，并将其标记为探索过的点。</li><li>若探索到一个顶点，该顶点还有未被探索过的后继点，则将该后继点入栈，做标记。若该顶点的所有后继点都被探寻过了，则将该点出栈。</li><li>若探索到最后还有没探索到的点，则表明该图非连通图，则选择任意一个未被探索过的点当作起点，回到步骤1。</li></ol><p>拿一个问题来说：</p><p><a href="https://www.luogu.com.cn/problem/P1706">洛谷 - P1706 全排列问题</a></p><p>问题摘录如下：</p><blockquote><p>按照字典序输出自然数 1 到 n 所有不重复的排列，即 n 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。</p></blockquote><p>C语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> totalLayer;</span><br><span class="line"><span class="type">int</span> answer[<span class="number">10</span>], used[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> currentLayer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(currentLayer == totalLayer) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; currentLayer; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, answer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalLayer; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i+<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            answer[currentLayer] = i+<span class="number">1</span>;</span><br><span class="line">            used[i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            dfs(currentLayer+<span class="number">1</span>);</span><br><span class="line">            used[i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fen ge</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;totalLayer);</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题中，将问题抽象为森林，对于三层的情况，两棵树如下：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/7293.png"></p><p><img src="https://cdn.luogu.com.cn/upload/pic/7294.png" alt="img"></p><p>在<code>dfs()</code>函数中，先判断是否为应该输出答案的状态，若非，则一层一层的探寻可行的状态。</p><h1 id="3-广度优先搜索"><a href="#3-广度优先搜索" class="headerlink" title="3. 广度优先搜索"></a>3. 广度优先搜索</h1><p>广度优先搜索(BFS)需要用到队列。</p><p>该算法思想是：从起点开始不断扩散，寻找可行解。</p><p>该算法步骤为：从起点开始，将所有未探索的后继点加入队列，将起点出队。重复此步骤。</p><h1 id="3-5-双向搜索"><a href="#3-5-双向搜索" class="headerlink" title="3.5 双向搜索"></a>3.5 双向搜索</h1><p>您也可以从起点、终点同时开始深搜、广搜，能一定程度上降低复杂度。</p><h1 id="4-代价一致搜索"><a href="#4-代价一致搜索" class="headerlink" title="4. 代价一致搜索"></a>4. 代价一致搜索</h1><p>在广度优先搜索的步骤中，我们假定每次拓展都是等代价的，这样我们可以同时拓展未探索的节点。然而在实际生活中，对于不同的节点，扩展的代价往往不同。那么我们先设定拓展节点的代价，接着每次拓展时，都拓展总代价最小的那一个节点。代价可以通过如下的公式计算：</p><p>我们假设$g(n_1)$代表从初始节点到$n_1$节点的路径代价，$c(n_1,n_2)$是从$n_1$到$n_2$的代价，那么有：<br>$$<br>g(n_2)&#x3D;g(n_1)+c(n_1,n_2)<br>$$<br>举个例子，对于如下的图：</p><p><img src="/2023/06/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/2.png"></p><p>假设A为起点，E为终点，搜索步骤如下：</p><ol><li>先探索A。</li><li>探索C，因为A到C的代价为1，A到B代价为3。</li><li>探索B，因为若探索D，代价为4，探索B代价为3。</li><li>探索D。</li><li>探索E，探索到了终点，程序终止。</li></ol><p>该方法探索到的路径一定是代价最小的路径。</p><h1 id="5-贪婪最佳优先搜索"><a href="#5-贪婪最佳优先搜索" class="headerlink" title="5. 贪婪最佳优先搜索"></a>5. 贪婪最佳优先搜索</h1><p>上面所提到的搜索方法都是无信息的搜索方式，即没有任何信息，直接开始搜索。</p><p>从该搜索方式开始，都属于有信息的搜索方式。</p><p>和代价一致搜索略有区别，该搜索方法的代价为到目标节点的剩余距离。每次扩展，只扩展代价最小的子节点。</p><p>同样对于上面这张图，探索步骤如下：</p><ol><li>先探索A。</li><li>探索C。</li><li>探索D。</li><li>探索E。</li></ol><p>该方法没法保证最终能够得到路径，假设能得到路径，也没法保证最佳性。</p><h1 id="6-A-算法"><a href="#6-A-算法" class="headerlink" title="6. A*算法"></a>6. A*算法</h1><p>代价一致搜索考虑的是已经走过的距离，贪婪最佳优先搜索算法考虑的是余下的距离，而A*算法则将这两种算法结合起来。</p><p>该算法中，节点$n_1$代价函数为：<br>$$<br>f(n_1) &#x3D; g(n_1)+h(n_1)<br>$$<br>其中$f(n_1)$是节点$n_1$的代价函数，$g(n_1)$是起始节点到节点$n_1$走过的距离，$h(n_1)$是节点$n_1$到目标节点的估计代价。</p><p>如您所见，估计代价函数是很重要的，设定估计代价函数时，一定要保证估计代价要小于等于实际的代价。过高地估计，有可能会让算法错误地放弃真实的最短路径。</p><h1 id="7-博弈搜索"><a href="#7-博弈搜索" class="headerlink" title="7. 博弈搜索"></a>7. 博弈搜索</h1><p>博弈搜索主要讨论在确定的、全局可观察的、竞争对手轮流行动的对抗搜索两人对决游戏。</p><h2 id="极小极大分析法"><a href="#极小极大分析法" class="headerlink" title="极小极大分析法"></a>极小极大分析法</h2><p>对于博弈问题，可以生成一个与或树。与节点、或节点交替层级出现。奇数层为己方先手，偶数层为对方先手。此外，我们还有一个代价函数，假定为对你的有利程度。或节点表示己方可选的下法，与节点则表明我需要考虑对方所有可能的落子方法。</p><p>利用极小极大分析法，我们需要从叶子节点向上推导，对“或”节点, 选其子节点中一个最大的得分作为父节点的得分；对“与”节点, 选其子节点中一个最小的得分作为父节点的得分。奇数层节点（我方节点）总是会选择赢面最大的子节点状态，而偶数层（对方节点）总是会选择我方赢面最小的的子节点状态。</p><h2 id="Alpha-Beta剪枝"><a href="#Alpha-Beta剪枝" class="headerlink" title="Alpha-Beta剪枝"></a>Alpha-Beta剪枝</h2><p>极大极小分析法要分析的节点太多了，如果能有一种算法剪去一些枝，则能一定程度上降低复杂度。</p><p>偷个懒，引用一下别人的文章，您能在参考资料中找到原文：</p><blockquote><p>(1) 对于一个与节点MIN, 若能估计出其倒推值的上确界β,并且这个β值不大于MIN的父节点(一定是或节点)的估计倒推值的下确界α,即α≥β, 则就不必再扩展该MIN节点的其余子节点了(因为这些节点的估值对MIN父节点的倒推值已无任何影响了)。这一过程称为α剪枝。</p><p>(2) 对于一个或节点MAX, 若能估计出其倒推值的下确界α, 并且这个α值不小于MAX的父节点(一定是与节点)的估计倒推值的上确界β, 即α≥β,则就不必再扩展该MAX节点的其余子节点了(因为这些节点的估值对MAX父节点的倒推值已无任何影响了)。 这一过程称为β剪枝。</p></blockquote><p>所谓MIN节点，就是与节点。</p><h2 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h2><p>我们也可以用类似抽样的方法进行搜索。</p><p>该方法由四个步骤组成：</p><ol><li>选择</li><li>拓展</li><li>模拟</li><li>反向传播</li></ol><p>最开始，我们将需要决策的局面设置为根节点。对于蒙特卡洛搜索树中的每一个节点，都包含着三个信息：</p><ol><li>该节点代表的局面。</li><li>该节点被访问的次数。</li><li>累积评分。</li></ol><p>同时，节点可以被分成三类：</p><ol><li>被完全评估过的节点。拿国际象棋举例，也就是对于该节点来说，所有的可能走法都被评估过了。</li><li>未被完全评估的节点。拿国际象棋举例，也就是对于该节点来说，还有一些落子方法没有被评估过。</li><li>结束节点。拿国际象棋举例，也就是对于该节点来说，一方将另一方将死。</li></ol><p>在选择阶段，我们从根节点开始，逐步评估子节点，对于上面的三种节点，分别采取不同的策略：</p><ol><li>若节点被完全评估，则计算所有子节点的评分，则将评分最高的子节点设为待评估节点，进行选择操作。</li><li>若节点未被完全评估，则该节点设为待评估节点，进行拓展操作。</li><li>若节点为结束节点，则该节点设为待评估节点，进行反向传播操作。</li></ol><p>在拓展阶段，我们在待评估节点的基础上，随机选择一个动作A，在搜索树中创建一个子节点，该子节点表示待评估节点经过动作A所转换得到的局面，接着进行模拟操作。</p><p>在模拟阶段，我们在上一步得到的子节点的基础上，随机进行游戏，直到得到一个结束节点，若结束节点代表己方被将死，则视为失败，反之视为成功。接着进行反向传播操作。</p><p>在反向传播阶段，从结束节点开始，回溯更新父节点的评分值。</p><p>当算法结束时，访问次数越高的节点往往是最佳的选择。</p><p>计算评分，常常使用<strong>应用到搜索树上的上限置信区间算法UCT</strong>，公式如下：<br>$$<br>UCT&#x3D;\frac{w_i}{n_i}+C\sqrt{\frac{lnN_i}{n_i}}<br>$$<br>其中$w_i$表示选择$i$节点的胜利次数，$n_i$是$i$节点的模拟次数，$C$是一个平衡系数，$N_i$是全部的模拟次数。该公式的形式，来自正态分布的置信区间的计算公式，您可以在参考资料中查看相关的资料。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://oi-wiki.org/">OI Wiki</a></p><p><a href="https://www.cnblogs.com/wkfvawl/p/12066647.html">博弈树搜索</a></p><p><a href="https://zhuanlan.zhihu.com/p/333348915">【最佳实战】蒙特卡洛树搜索算法</a></p><p><a href="https://www.cnblogs.com/pinard/p/10470571.html">强化学习(十八) 基于模拟的搜索与蒙特卡罗树搜索(MCTS) </a></p><p><a href="https://zhuanlan.zhihu.com/p/140194206">怎样全面理解95%置信区间</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】素数筛</title>
      <link href="/2023/06/01/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2023/06/01/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文探讨寻找从2到n所有质数的几种方法，并在复杂度上进行比较。</p><h1 id="1-常规的寻找质数法"><a href="#1-常规的寻找质数法" class="headerlink" title="1. 常规的寻找质数法"></a>1. 常规的寻找质数法</h1><p>思想：对于每一个数字，从2开始枚举到该数字的算术平方根处，若存在某个枚举到的数能整除当前数字，则该数字非质数。</p><p>C语言代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> isPrime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    isPrime = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j*j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            isPrime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isPrime) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该寻找方法，复杂度为$O(n\sqrt{n})$。</p><h1 id="2-埃拉托斯特尼筛法"><a href="#2-埃拉托斯特尼筛法" class="headerlink" title="2. 埃拉托斯特尼筛法"></a>2. 埃拉托斯特尼筛法</h1><p>思想：</p><ol><li>维护一个表，表项为0代表该表项下标是质数。</li><li>已知2是最小的质数，在表中将所有以2的倍数为下标的表项标注为1，<strong>寻找表项为0的最小下标，该下标为一个质数</strong>。</li><li>标记以该质数倍数为下标的表项，接着寻找表项为0的最小下标，该下标同样也是一个质数。</li><li>回到第二步，做类似操作。</li></ol><p>C语言代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prime[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!prime[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i*i; j &lt;= n; j+=i) &#123; <span class="comment">//初始化j为i*i, 因为其为未被筛过的，且以i为因子的合数</span></span><br><span class="line">            prime[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该寻找方法，复杂度为$O(nloglogn)$。根据素数定理，可以通过积分算出这个复杂度，详情参考<a href="https://www.zhihu.com/question/35112789">这里</a>。</p><p>该方法存在问题，比如在遍历到2、3时，下标为12的表项，都会经历一次赋值操作。</p><h1 id="3-欧拉筛法"><a href="#3-欧拉筛法" class="headerlink" title="3. 欧拉筛法"></a>3. 欧拉筛法</h1><p>思想：</p><ol><li>维护一个记录表，表项为0代表该表项下标是质数。维护一个质数表，装质数本身。</li><li>已知2是最小的质数，放入质数表。</li><li>从2开始，每个数都与质数表里的数相乘，将记录表对应下标表项修改为1。</li><li>若遍历到某个数，能被质数表中某一质数整除，则回到第二步，做类似操作。</li></ol><p>C语言程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> isNotPrime[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> primeList[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isNotPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            primeList[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; count &amp;&amp; i*primeList[j] &lt;= n; j++) &#123;</span><br><span class="line">            isNotPrime[primeList[j]*i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primeList[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该寻找方法，复杂度为$O(n)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言拾遗</title>
      <link href="/2023/05/30/C%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/"/>
      <url>/2023/05/30/C%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我平时常用C写一些自用小工具，凯撒密码破解器啦，辅助包管理器啦……但也发现了许多C语言中，自己一直忽略的小细节。</p><h1 id="1-获取带任意多空格的字符串"><a href="#1-获取带任意多空格的字符串" class="headerlink" title="1. 获取带任意多空格的字符串"></a>1. 获取带任意多空格的字符串</h1><p>如果缓冲区内有换行符，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getchar(); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, buffer);</span><br></pre></td></tr></table></figure><p>若无，则将第一句去掉。第二行代码中间的正则表达式意思是，遇到换行符，则停止读取。</p><p><code>scanf()</code>蛮危险，也可以使用逐个字符读取的方法。</p><h1 id="2-fflush-stdout"><a href="#2-fflush-stdout" class="headerlink" title="2. fflush(stdout)"></a>2. fflush(stdout)</h1><p>当<code>printf()</code>的行为出现异常，比如：</p><ul><li>打印到屏幕上的顺序出现颠倒、错乱。</li><li>输出了本不应该输出的字符。</li></ul><p>试试在代码中的相应部分添加<code>fflush(stdout)</code>。上述两个异常，第一个异常原因未知。第二个的原因是缓冲区太小，内容太多导致溢出。</p><p><code>fflush()</code>说明如下：</p><blockquote><p>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the stream’s buffer to the associated output device.</p><p>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</p><p>If stream is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</p></blockquote><p>这里提到的一点很重要，<code>fflush(stdin)</code>是一个UB(Undefined Behavior，未定义行为)，如果需要清除输入缓冲区里的内容，建议具体问题具体分析，一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FlushStdin</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">while</span>((c = getchar()) != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-EOF和feof"><a href="#3-EOF和feof" class="headerlink" title="3. EOF和feof()"></a>3. EOF和feof()</h1><p>当判断是否是文件结尾的时候，不要使用如下的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_character == EOF</span><br></pre></td></tr></table></figure><p>要使用如下的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feof(current_character) != <span class="number">0</span></span><br></pre></td></tr></table></figure><p>因为EOF代表-1，而有的文件结尾不是-1。注意，<code>feof()</code>若判断为文件结尾，返回非0值。</p><h1 id="4-switch…case…与if…else…效率比较"><a href="#4-switch…case…与if…else…效率比较" class="headerlink" title="4. switch…case…与if…else…效率比较"></a>4. switch…case…与if…else…效率比较</h1><p>前者效率高，因为前者在汇编层面依靠跳转表实现，先判断值，随后直接判断跳转到哪里。后者则通过生成一串判断指令+条件跳转、非条件跳转指令实现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/dongshuaishuai/p/13181899.html">C语言，如何读取带空格的字符串 - 小白一枚</a></p><p><a href="https://en.cppreference.com/w/c/io/fflush">cppreference - fflush()</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Hello World是如何输出的</title>
      <link href="/2023/05/23/Linux%E4%B8%8BHello-World%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84/"/>
      <url>/2023/05/23/Linux%E4%B8%8BHello-World%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近开了一门名为“计算机系统”的课，以卡内基梅隆大学的《深入理解计算机系统》为教材，讲解偏向底层的一些知识：浮点数具体的表示方法、预处理编译汇编链接具体发生什么……这门课的大作业要求我们跟随“预处理-编译-汇编-链接-进程管理”的路线，写一下“Linux下Hello World是如何输出的”。</p><p>然而在写大作业的时候，我还没有复习，上课也没有认真听，东拼西凑写出来了一篇文章。事到如今，差不多把教材里的知识点都掌握了，那就认真写一遍吧。</p><p>上课挺没意思的。说实话。</p><h1 id="0-源程序"><a href="#0-源程序" class="headerlink" title="0. 源程序"></a>0. 源程序</h1><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>预处理阶段，编译器主要对宏定义进行一些处理。比如，引入一些头文件、定义一些宏变量等。</p><p>后缀为.c的源程序文件，通过预处理，可以生成后缀名为.i的预处理文件。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>.i文件部分输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/bits/types/__mbstate_t.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">13</span> <span class="string">&quot;/usr/include/bits/types/__mbstate_t.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> __count;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __wch;</span><br><span class="line">    <span class="type">char</span> __wchb[<span class="number">4</span>];</span><br><span class="line">  &#125; __value;</span><br><span class="line">&#125; <span class="type">__mbstate_t</span>;</span><br><span class="line"># <span class="number">6</span> <span class="string">&quot;/usr/include/bits/types/__fpos_t.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">fwrite</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,</span></span><br><span class="line"><span class="params">        <span class="type">size_t</span> __n, FILE *__restrict __s)</span>;</span><br><span class="line"># <span class="number">702</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">fread_unlocked</span> <span class="params">(<span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,</span></span><br><span class="line"><span class="params">         <span class="type">size_t</span> __n, FILE *__restrict __stream)</span> ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">fwrite_unlocked</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,</span></span><br><span class="line"><span class="params">          <span class="type">size_t</span> __n, FILE *__restrict __stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fseek</span> <span class="params">(FILE *__stream, <span class="type">long</span> <span class="type">int</span> __off, <span class="type">int</span> __whence)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span> <span class="params">(FILE *__stream)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rewind</span> <span class="params">(FILE *__stream)</span>;</span><br><span class="line"># <span class="number">736</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fseeko</span> <span class="params">(FILE *__stream, <span class="type">__off_t</span> __off, <span class="type">int</span> __whence)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">__off_t</span> <span class="title function_">ftello</span> <span class="params">(FILE *__stream)</span> ;</span><br><span class="line"># <span class="number">760</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fgetpos</span> <span class="params">(FILE *__restrict __stream, <span class="type">fpos_t</span> *__restrict __pos)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fsetpos</span> <span class="params">(FILE *__stream, <span class="type">const</span> <span class="type">fpos_t</span> *__pos)</span>;</span><br><span class="line"># <span class="number">786</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clearerr</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">feof</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ferror</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clearerr_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">feof_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ferror_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">perror</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__s)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fileno</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">fileno_unlocked</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"># <span class="number">823</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pclose</span> <span class="params">(FILE *__stream)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="title function_">popen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__command, <span class="type">const</span> <span class="type">char</span> *__modes)</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((__malloc__))</span> __<span class="title function_">attribute__</span> <span class="params">((__malloc__ (pclose, <span class="number">1</span>)))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">ctermid</span> <span class="params">(<span class="type">char</span> *__s)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span><br><span class="line">  __<span class="title function_">attribute__</span> <span class="params">((__access__ (__write_only__, <span class="number">1</span>)))</span>;</span><br><span class="line"># <span class="number">867</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">flockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ftrylockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">885</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __uflow (FILE *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br><span class="line"># <span class="number">909</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，预处理后的文件引入了许多结构体、许多函数。我们编写的主函数，则位于这个文件的末尾。</p><p>此外，有很多，类似于这样的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">885</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这些语句标记了源文件和代码行来自于哪个头文件、哪一行。您可以参考gcc的<a href="http://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html">官方文档</a>获取更多信息。</p><h1 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>将程序语言转换为汇编语言。</p><p>通过编译，.i文件可以生成.s文件。</p><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -S hello.c</span><br></pre></td></tr></table></figure><p>这两种生成<code>hello.s</code>的方法是等价的，最后的结果没有任何差异。您可以通过<code>diff</code>命令来检查。</p><h2 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h2><p><code>hello.s</code>文件输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;hello.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;Hello world!&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq$16, %rsp</span><br><span class="line">movl%edi, -4(%rbp)</span><br><span class="line">movq%rsi, -16(%rbp)</span><br><span class="line">leaq.LC0(%rip), %rax</span><br><span class="line">movq%rax, %rdi</span><br><span class="line">callputs@PLT</span><br><span class="line">movl$0, %eax</span><br><span class="line">leave</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (GNU) 13.1.1 20230429&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>该文件涉及到的知识点很多。</p><ul><li><code>.file</code>，表明了该.s文件的源程序文件名。</li><li><code>.text</code>，表明代码节的开启，每个节的作用，在2.5节将进行解释。</li><li><code>.section .rodata</code>，代表定义一个只读的数据节。</li><li><code>.LC0</code>，也就是<code>local constant 0</code>，局部常量。</li><li><code>.string</code>，声明了一个字符串。</li><li><code>.globl main</code>，声明了main是一个全局符号。</li><li><code>.type A, B</code>，声明了<code>A</code>为<code>B</code>类型。</li><li><code>.LFB0 .LFE0</code>，全称分别为<code>Local Function Begins</code>，<code>Local Function Ends</code>，代表局部函数的开始和结束。</li><li><code>.size</code>，表明main符号的尺寸。</li><li><code>.ident</code>，表明编译器版本。</li><li><code>.section.note.GNU-stack,&quot;&quot;,@progbits</code>，意思是这个segment会被标记为 “非可执行栈”，引用自<a href="https://www.jianshu.com/p/e385ff61dd7c">简书</a>。</li><li><code>cfi</code>，即<code>Call Frame Information</code>，以之开头的一些指令和栈相关。</li></ul><h1 id="2-5-汇编与内存相关知识"><a href="#2-5-汇编与内存相关知识" class="headerlink" title="2.5 汇编与内存相关知识"></a>2.5 汇编与内存相关知识</h1><p>我们现在所使用的是AT&amp;T汇编指令系统。</p><p>该指令系统的部分特点是：</p><ul><li><p>立即数，也就是汇编指令中的数字，前面需要加上美元符号。比如<code>$1</code>、<code>$5</code>等。</p></li><li><p>寄存器，需要在前面加上百分号。比如<code>%rbp</code>,<code>%rax</code>等。如果寄存器加上括号，比如<code>(%rax)</code>代表间接寻址，也就是先从<code>rax</code>里取一个地址，在去内存中根据该地址寻找数据。</p></li><li><p>指令后需要加一个标记，比如<code>pushq</code>、<code>movq</code>最后的<code>q</code>，和<code>movl</code>最后的<code>l</code>。标记有四种b,w,l,q，分别代表操作的数据长度为1，2，4，8字节。</p></li><li><p>向函数中传递参数，前六个参数分别存入<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>寄存器中，其他参数入栈。返回值存入<code>rax</code>寄存器中。</p></li></ul><p>当程序运行时，内存布局如下：</p><ul><li>栈：存储局部变量、函数参数等。</li><li>堆：存储动态分配的内容。</li><li>数据段：存储全局变量、static变量、字符串。</li><li>代码段：存储只读、可执行的机器指令。</li></ul><p>当程序编译时，各内容布局如下：</p><ul><li><code>.text</code>节：存储代码。</li><li><code>.rodata</code>节：存储只读数据（<code>printf</code>的格式串等）。</li><li><code>.data</code>节：存储数据和已经初始化的全局与静态变量。</li><li><code>.bss</code>节：存储为初始化的全局变量。</li><li><code>.symtab</code>节：存储符号表。</li><li>…</li></ul><h1 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编"></a>3. 汇编</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>将汇编语言转换为机器语言。</p><p>通过汇编，.s文件会生成.o文件。</p><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><h2 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h2><p>最终生成一个二进制文件，而这个文件直接通过<code>cat</code>输出，没办法被阅读。需要反汇编，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -D hello.o</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:55                   push   %rbp</span><br><span class="line">   1:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   4:48 83 ec 10          sub    $0x10,%rsp</span><br><span class="line">   8:89 7d fc             mov    %edi,-0x4(%rbp)</span><br><span class="line">   b:48 89 75 f0          mov    %rsi,-0x10(%rbp)</span><br><span class="line">   f:48 8d 05 00 00 00 00 lea    0x0(%rip),%rax        # 16 &lt;main+0x16&gt;</span><br><span class="line">  16:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  19:e8 00 00 00 00       call   1e &lt;main+0x1e&gt;</span><br><span class="line">  1e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  23:c9                   leave</span><br><span class="line">  24:c3                   ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.rodata&gt;:</span><br><span class="line">   0:48                   rex.W</span><br><span class="line">   1:65 6c                gs insb (%dx),%es:(%rdi)</span><br><span class="line">   3:6c                   insb   (%dx),%es:(%rdi)</span><br><span class="line">   4:6f                   outsl  %ds:(%rsi),(%dx)</span><br><span class="line">   5:20 77 6f             and    %dh,0x6f(%rdi)</span><br><span class="line">   8:72 6c                jb     76 &lt;main+0x76&gt;</span><br><span class="line">   a:64 21 00             and    %eax,%fs:(%rax)</span><br><span class="line"></span><br><span class="line">Disassembly of section .comment:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.comment&gt;:</span><br><span class="line">   0:00 47 43             add    %al,0x43(%rdi)</span><br><span class="line">   3:43 3a 20             rex.XB cmp (%r8),%spl</span><br><span class="line">   6:28 47 4e             sub    %al,0x4e(%rdi)</span><br><span class="line">   9:55                   push   %rbp</span><br><span class="line">   a:29 20                sub    %esp,(%rax)</span><br><span class="line">   c:31 33                xor    %esi,(%rbx)</span><br><span class="line">   e:2e 31 2e             cs xor %ebp,(%rsi)</span><br><span class="line">  11:31 20                xor    %esp,(%rax)</span><br><span class="line">  13:32 30                xor    (%rax),%dh</span><br><span class="line">  15:32 33                xor    (%rbx),%dh</span><br><span class="line">  17:30 34 32             xor    %dh,(%rdx,%rsi,1)</span><br><span class="line">  1a:39 00                cmp    %eax,(%rax)</span><br><span class="line"></span><br><span class="line">Disassembly of section .note.gnu.property:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.note.gnu.property&gt;:</span><br><span class="line">   0:04 00                add    $0x0,%al</span><br><span class="line">   2:00 00                add    %al,(%rax)</span><br><span class="line">   4:20 00                and    %al,(%rax)</span><br><span class="line">   6:00 00                add    %al,(%rax)</span><br><span class="line">   8:05 00 00 00 47       add    $0x47000000,%eax</span><br><span class="line">   d:4e 55                rex.WRX push %rbp</span><br><span class="line">   f:00 02                add    %al,(%rdx)</span><br><span class="line">  11:00 01                add    %al,(%rcx)</span><br><span class="line">  13:c0 04 00 00          rolb   $0x0,(%rax,%rax,1)</span><br><span class="line">...</span><br><span class="line">  1f:00 01                add    %al,(%rcx)</span><br><span class="line">  21:00 01                add    %al,(%rcx)</span><br><span class="line">  23:c0 04 00 00          rolb   $0x0,(%rax,%rax,1)</span><br><span class="line">  27:00 01                add    %al,(%rcx)</span><br><span class="line">  29:00 00                add    %al,(%rax)</span><br><span class="line">  2b:00 00                add    %al,(%rax)</span><br><span class="line">  2d:00 00                add    %al,(%rax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Disassembly of section .eh_frame:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.eh_frame&gt;:</span><br><span class="line">   0:14 00                adc    $0x0,%al</span><br><span class="line">   2:00 00                add    %al,(%rax)</span><br><span class="line">   4:00 00                add    %al,(%rax)</span><br><span class="line">   6:00 00                add    %al,(%rax)</span><br><span class="line">   8:01 7a 52             add    %edi,0x52(%rdx)</span><br><span class="line">   b:00 01                add    %al,(%rcx)</span><br><span class="line">   d:78 10                js     1f &lt;.eh_frame+0x1f&gt;</span><br><span class="line">   f:01 1b                add    %ebx,(%rbx)</span><br><span class="line">  11:0c 07                or     $0x7,%al</span><br><span class="line">  13:08 90 01 00 00 1c    or     %dl,0x1c000001(%rax)</span><br><span class="line">  19:00 00                add    %al,(%rax)</span><br><span class="line">  1b:00 1c 00             add    %bl,(%rax,%rax,1)</span><br><span class="line">  1e:00 00                add    %al,(%rax)</span><br><span class="line">  20:00 00                add    %al,(%rax)</span><br><span class="line">  22:00 00                add    %al,(%rax)</span><br><span class="line">  24:25 00 00 00 00       and    $0x0,%eax</span><br><span class="line">  29:41 0e                rex.B (bad)</span><br><span class="line">  2b:10 86 02 43 0d 06    adc    %al,0x60d4302(%rsi)</span><br><span class="line">  31:60                   (bad)</span><br><span class="line">  32:0c 07                or     $0x7,%al</span><br><span class="line">  34:08 00                or     %al,(%rax)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行说明了该文件为ELF文件，ELF即Executable and Linkable Format，可执行可链接文件格式。和上一步输出得到的文件相比，本文件有如下几个特点：</p><ol><li><code>call</code>指令后面是具体的地址，而非抽象的文件名。</li><li>开始使用十六进制操作数。</li><li>出现了很多节，起始地址都为0。</li><li>…</li></ol><h1 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>一个程序可能有很多个模块，比如假设一个程序由三个源文件组成，其中第一个文件中的很多变量可能在第二个文件中定义。和<code>#include</code>引入头文件不同，链接一般是将多个<code>.o</code>文件拼凑起一个完整的程序。</p><p>可以在编译时链接，也可以在运行时通过<code>dlopen()</code>等函数动态链接一些其他文件，在Windows下，动态链接的是动态链接表<code>.dll</code>文件，在Linux下，动态链接的是共享库文件<code>.so</code>。</p><p>链接分两个步骤：符号解析和重定位，前者解释所有的符号，将每一个符号与一个解释关联起来，所谓符号，要么是函数名，要么是变量；后者则给这些符号一个安身之所，定位到一个绝对内存位置。</p><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><p>通过链接器<code>ld</code>链接即可。本例可以通过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/crt1.o /usr/lib/crti.o hello.o /usr/lib/libc.so /usr/lib/crtn.o</span><br></pre></td></tr></table></figure><p>进行编译时链接。</p><h2 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h2><p>通过反编译，链接后的文件部分输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0000000000400458 &lt;.gnu.version_r&gt;:</span><br><span class="line">  400458:01 00                add    %eax,(%rax)</span><br><span class="line">  40045a:02 00                add    (%rax),%al</span><br><span class="line">  40045c:18 00                sbb    %al,(%rax)</span><br><span class="line">  40045e:00 00                add    %al,(%rax)</span><br><span class="line">  400460:10 00                adc    %al,(%rax)</span><br><span class="line">  400462:00 00                add    %al,(%rax)</span><br><span class="line">  400464:00 00                add    %al,(%rax)</span><br><span class="line">  400466:00 00                add    %al,(%rax)</span><br><span class="line">  400468:75 1a                jne    400484 &lt;_init-0xb7c&gt;</span><br><span class="line">  40046a:69 09 00 00 03 00    imul   $0x30000,(%rcx),%ecx</span><br><span class="line">  400470:22 00                and    (%rax),%al</span><br><span class="line">  400472:00 00                add    %al,(%rax)</span><br><span class="line">  400474:10 00                adc    %al,(%rax)</span><br><span class="line">  400476:00 00                add    %al,(%rax)</span><br><span class="line">  400478:b4 91                mov    $0x91,%ah</span><br><span class="line">  40047a:96                   xchg   %eax,%esi</span><br><span class="line">  40047b:06                   (bad)</span><br><span class="line">  40047c:00 00                add    %al,(%rax)</span><br><span class="line">  40047e:02 00                add    (%rax),%al</span><br><span class="line">  400480:2e 00 00             cs add %al,(%rax)</span><br><span class="line">  400483:00 00                add    %al,(%rax)</span><br><span class="line">  400485:00 00                add    %al,(%rax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Disassembly of section .rela.dyn:</span><br><span class="line"></span><br><span class="line">0000000000400488 &lt;.rela.dyn&gt;:</span><br><span class="line">  400488:d8 3f                fdivrs (%rdi)</span><br><span class="line">  40048a:40 00 00             rex add %al,(%rax)</span><br><span class="line">  40048d:00 00                add    %al,(%rax)</span><br><span class="line">  40048f:00 06                add    %al,(%rsi)</span><br><span class="line">  400491:00 00                add    %al,(%rax)</span><br><span class="line">  400493:00 01                add    %al,(%rcx)</span><br><span class="line">...</span><br><span class="line">  40049d:00 00                add    %al,(%rax)</span><br><span class="line">  40049f:00 e0                add    %ah,%al</span><br><span class="line">  4004a1:3f                   (bad)</span><br><span class="line">  4004a2:40 00 00             rex add %al,(%rax)</span><br><span class="line">  4004a5:00 00                add    %al,(%rax)</span><br><span class="line">  4004a7:00 06                add    %al,(%rsi)</span><br><span class="line">  4004a9:00 00                add    %al,(%rax)</span><br><span class="line">  4004ab:00 03                add    %al,(%rbx)</span><br></pre></td></tr></table></figure><p>最大的变化是，文件变长了，除此之外也有一个显著的新特点：每一个节的开始位置不再是0,而是一个具体的地址。</p><h1 id="5-进程管理、信号与内存管理"><a href="#5-进程管理、信号与内存管理" class="headerlink" title="5. 进程管理、信号与内存管理"></a>5. 进程管理、信号与内存管理</h1><h2 id="进程管理与信号"><a href="#进程管理与信号" class="headerlink" title="进程管理与信号"></a>进程管理与信号</h2><p>当我们在Shell中运行程序时，会经历几个步骤：</p><ol><li>读取命令。</li><li>判断命令的准确性。</li><li>使用<code>fork()</code>创建子进程，在子进程中调用<code>execve()</code>启动程序。</li><li>Shell等待子进程完成。</li></ol><p>其中，用户可以给进程发出一些“信号”，比如按下<code>C-z</code>键，就会向进程输出SIGSTOP信号，按下<code>C-c</code>键，就会向进程输出SIGINT信号。当接收到这些信号时，程序可能有如下几种反应：</p><ul><li>忽略。</li><li>调用相应的信号处理函数处理信号。</li><li>执行默认的信号处理方式。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>一定程度上，进程之间彼此独立。在创建子进程后，在父进程中修改全局变量，子进程中的对应变量不会被更改。二者的内存区域指向不同的物理空间。</p><p>若想要在进程中通信，可以通过管道进行数据传输。</p><h1 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h1><p>源程序首先经过预处理，处理掉一些宏定义，经过编译，将之转换为汇编语言文件，经过汇编，将之转换为二进制文件，最后经过链接，定义符号，将程序各段重定位到绝对内存地址。</p><p>之后，通过Shell，读取命令，创建子进程，输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Python爬取flickr照片</title>
      <link href="/2023/05/10/%E5%88%A9%E7%94%A8Python%E7%88%AC%E5%8F%96flickr%E7%85%A7%E7%89%87/"/>
      <url>/2023/05/10/%E5%88%A9%E7%94%A8Python%E7%88%AC%E5%8F%96flickr%E7%85%A7%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>笔者最近在做一个有关计算机视觉的大创，需要从flickr爬取大量的图片下来，但是发现网上的爬取脚本质量不是很高，也不符合我的需求，文档质量也不是很高。在这里记录一下我自己写的脚本。</p><h1 id="爬取流程"><a href="#爬取流程" class="headerlink" title="爬取流程"></a>爬取流程</h1><p>首先去flickr申请属于你自己的API key和API 密钥，然后填写进下面的脚本就行了。</p><p><strong>需要科学上网。</strong></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>flickr的搜索模式有两种：All和Tags。在代码中，tag变量的内容应该是你要搜索的关键词，如果您想要使用标签搜索，请将<code>flickr.walk()</code>的<code>tag_mode</code>设置为tags。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>注意填写四个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> flickrapi</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">API_KEY = <span class="string">&quot;Enter your key here&quot;</span></span><br><span class="line">API_SECRET = <span class="string">&quot;Enter your secret here&quot;</span></span><br><span class="line"></span><br><span class="line">flickr = flickrapi.FlickrAPI(API_KEY, API_SECRET, cache=<span class="literal">True</span>)</span><br><span class="line">download_num = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">tag = <span class="string">&quot;Enter your tag here&quot;</span></span><br><span class="line">path = <span class="string">&quot;Enter your path here&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        photos = flickr.walk(tag_mode=<span class="string">&#x27;all&#x27;</span>,tags=tag, extras=<span class="string">&#x27;url_c&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Some error occurs when walking down the photos.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> photo <span class="keyword">in</span> photos:</span><br><span class="line">        <span class="keyword">if</span> count==download_num:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        url=photo.get(<span class="string">&#x27;url_c&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>(url) == <span class="string">&quot;None&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The url is none.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            urllib.request.urlretrieve(url, path+<span class="built_in">str</span>(count)+<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Done saving images! Count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line">            count = count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现康威生命游戏</title>
      <link href="/2023/05/01/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
      <url>/2023/05/01/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>某个假期，在看《黑客》这本书时，看到以前MIT的黑客很喜欢玩这个游戏。规则看起来不是很复杂，就试着实现一下吧。</p><p>生命游戏中，对于任意细胞，规则如下：</p><ul><li>每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）</li><li>当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态。（模拟生命数量稀少）</li><li>当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。</li><li>当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li><li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）</li></ul><p>可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。</p><h1 id="1-主体逻辑实现"><a href="#1-主体逻辑实现" class="headerlink" title="1. 主体逻辑实现"></a>1. 主体逻辑实现</h1><p>主体的逻辑实现不难，用两个布尔类型的二维数组表示新、旧地图，根据旧地图，计算出新地图中每一个cell的状态即可。</p><p>对于一个cell来说，首先根据旧地图，获取其存活的邻居数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getNeighbor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span> oldMatrix[BOARD_HEIGHT][BOARD_WIDTH])</span> &#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> xCord = x - <span class="number">1</span>; xCord &lt;= x + <span class="number">1</span>; xCord++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(xCord &lt; <span class="number">0</span> || xCord &gt;= BOARD_HEIGHT) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> yCord = y - <span class="number">1</span>; yCord &lt;= y + <span class="number">1</span>; yCord++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(yCord &lt; <span class="number">0</span> || yCord &gt;= BOARD_WIDTH) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!(xCord == x &amp;&amp; yCord == y)) &#123;</span><br><span class="line"><span class="keyword">if</span>(oldMatrix[xCord][yCord]) &#123;</span><br><span class="line">  result++;</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据自身的状态和邻居的个数，获取其将要变成什么状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">getStatus</span><span class="params">(<span class="type">int</span> neighbor, <span class="type">bool</span> originalStatus)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(originalStatus) &#123;</span><br><span class="line">    <span class="keyword">if</span>(neighbor == <span class="number">2</span> || neighbor == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(neighbor == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中，设置两个二维数组<code>matrix1</code>和<code>matrix2</code>，在主循环中，先将<code>matrix1</code>看作旧地图，将<code>matrix2</code>看作新地图，遍历地图上每一个点，在更新完一次地图之后，再把<code>matrix2</code>看作旧地图，<code>matrix1</code>看作新地图，周而复始，删减的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BOARD_HEIGHT; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; BOARD_WIDTH; j++) &#123;</span><br><span class="line">neighbor = getNeighbor(i, j, matrix1);</span><br><span class="line">matrix2[i][j] = getStatus(neighbor, matrix1[i][j]);</span><br><span class="line">neighbor = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   outputMatrix(matrix2);</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BOARD_HEIGHT; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; BOARD_WIDTH; j++) &#123;</span><br><span class="line">neighbor = getNeighbor(i, j, matrix2);</span><br><span class="line">matrix1[i][j] = getStatus(neighbor, matrix2[i][j]);</span><br><span class="line">neighbor = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   outputMatrix(matrix1);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-一些不重要的细节"><a href="#2-一些不重要的细节" class="headerlink" title="2. 一些不重要的细节"></a>2. 一些不重要的细节</h1><p>最开始的地图可以通过一个文件来读取，也可以随机地生成一些存活的cell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次网络谜题的解谜记录</title>
      <link href="/2023/05/01/%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%B0%9C%E9%A2%98%E7%9A%84%E8%A7%A3%E8%B0%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/05/01/%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%B0%9C%E9%A2%98%E7%9A%84%E8%A7%A3%E8%B0%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近在Lainchan上看到这样一个帖子，OP发言如下:</p><blockquote><p>Hello, I’ve recently stumbled upon this puzzle, that apparently dates  back to 2018 (I know I need to lurk moar). Has any lainon solved it  before? I’ve been stuck on the penultimate step 9 for 14 hours now.</p><p>&gt;hsvvrp.zjsvzlsfo.paola.lluayhjlp..pzy.bolyl.</p></blockquote><p>下面陆续有人留言，最终指向了这样一个网址：</p><p><a href="https://desuarchive.org/g/thread/66074121/#66091837">https://desuarchive.org/g/thread/66074121/#66091837</a></p><p>哦，原来是4chan上一位用户发布的网络谜题！</p><p>那就来试一试解谜吧。</p><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>以前在密码吧学到，对于一个短文本的加密，通常应用两种方式：凯撒密码、栅栏算法。</p><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>所谓凯撒密码，就是将字母在字母表中进行偏移，比如通常的字母表第一个字母是A，应用凯撒密码，我们可以把第一个字母设置为C。根据这样的一个对应关系对文本进行加密，比如说单词<code>apple</code>，每个单词往后移位，就可以是<code>bqqmf</code>。</p><h2 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h2><p>将想要加密的字符串从上到下，从左到右写成多行。按行读取就得到了密文。</p><p>比如说单词<code>apple</code>，可以写成：</p><blockquote><p>APE</p><p>PL</p></blockquote><p>密文就是<code>APEPL</code>。</p><p>除了这两种方法，也可以用一些图形对字母进行加密，比如卢恩符文、猪圈密码等。</p><p>回到现在的解谜过程。</p><p>第一阶段密文是：</p><blockquote><p>hsvvrp.zjsvzlsfo.paola.lluayhjlp..pzy.bolyl.</p></blockquote><p>链接在这里:<a href="https://pastebin.com/teBKxmLh">点击这里</a>。</p><p>首先应用栅栏密码，没什么收获。</p><p>然后应用凯撒密码解码方式，得到一种可能的明文：</p><blockquote><p>alooki.scloselyh.ithet.eentracei..isr.uhere.</p></blockquote><p>为什么可能？因为我看见了closely这个单词。似乎每组的第一个字母和最后一个字母是后加上去的。</p><p>每组的首字母、尾字母连接起来就是：</p><blockquote><p>aishitei.rue</p></blockquote><p>日语里的我爱你？</p><p>但是这个网站打不开，反复尝试得到链接：</p><blockquote><p>aishitei.ru</p></blockquote><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>OK。我们来到了一个网页。按下F12检查元素。</p><p>网页里有段注释:</p><blockquote><p>—- You’re off to a good start. Now look up.<br>—- Or maybe it was down?<br>—- Try asking the girl, Lain, for help.<br>—- She should be around here somewhere.</p></blockquote><p><code>Lain</code>，是番剧《玲音的系列试验》的女主角。我的博客头像就是Lain。</p><p>幻发现，每次刷新网页，网页中的图片都会改变，或许能通过不断刷新，当图片变为Lain时，就能解谜成功？</p><p>然而刷新了四五十次也没刷出来……</p><p>那么找找别的线索吧。</p><p>发现在网页底部有几个按钮，通过调查发现，这个网站似乎是某人的私人网盘，在FAQ中有这样一句话：</p><blockquote><p>Can I always use the same waifu mascot?</p><p>Find the number for the mascot you like and append, without quotes, <code>?waifu=*##*</code> to the URL. For example, Yuno is <code>?waifu=1</code>.</p></blockquote><p>OK。</p><p>当网址为<a href="https://aishitei.ru/?waifu=19">这个</a>时，所谓的<code>mascot</code>变成了Lain的样子。</p><p>下载这个<code>mascot</code>。</p><h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><p>So far so good！</p><p>我曾经在<a href="https://coder109.github.io/2023/02/10/Security03/#5-%E9%9A%90%E8%97%8F%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF">业余安全漫谈（三）：密码、存储、信息传输安全</a>中提到过一个查看图片元数据的网站。在这个网站上处理图片，最终提取到了这样的文字:</p><blockquote><p>Lavc51.28.0</p><p>…</p><p>you’re on the right track..kcart thgir eht no er’ouy<br>the wired is calling for you..ouy rof gnillca si deriw eht<br>can you hear it yet??tey ti raeh uoy nacRIFF</p><p>…</p><p>you’re on the right track..kcart thgir eht no er’ouy<br>the wired is calling for you..ouy rof gnillca si deriw eht<br>can you hear it yet??tey ti raeh uoy nac<br>track_44.wavvaw.44_kcart</p></blockquote><p>Btw，这个图片中有几个醒目的大字：</p><blockquote><p>Play Track 44</p></blockquote><p>这和幻正在汉化的游戏(英语太差了，汉化已经鸽了好久！)有关。曾经有一款古早的、和玲音有关的PSX游戏，它由许许多多的视频片段组成，您可以通过这个网站体验一下：<a href="https://laingame.net/">lainTSX</a>。</p><p>或者您可以在这收听Track 44，<a href="https://www.youtube.com/watch?v=w_wx2jag7xI">点击这里！</a>。</p><p>电子舞曲。</p><p>但是有什么用呢？你总不可能回到过去，和作曲人商量好，在这段曲子里加密一段信息吧。</p><p>……</p><p>幻没了任何思路。</p><p>直到幻突然想到了隐写术。</p><h2 id="隐写术与不断试错"><a href="#隐写术与不断试错" class="headerlink" title="隐写术与不断试错"></a>隐写术与不断试错</h2><p>我在<a href="https://coder109.github.io/2023/02/10/Security03/#%E9%9A%90%E5%86%99%E6%9C%AF">业余安全漫谈（三）：密码、存储、信息传输安全</a>里提到了隐写术的相关工具。</p><p>那么就把常用的工具都用上去吧。</p><p>终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -r mascot_19.jpg track_44.wav</span><br></pre></td></tr></table></figure><p>成功提取该文件。但是没法播放。</p><p>直接将图片改为<code>.wav</code>格式也不行。</p><p>试过了<code>Steghide</code>、<code>Stegsolve</code>等工具，都不行。</p><p>而使用<code>foremost</code>工具，则能提取出音频文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foremost -i mascot_19.jpg</span><br></pre></td></tr></table></figure><p>最终得到一个包含摩尔斯电码的音频文件。</p><p>懒得自己听了，直接用在线工具解码。</p><p>工具网站在这里:<a href="https://morsecode.world/">https://morsecode.world/</a>。</p><p>得到结果如下：</p><blockquote><p>C A N Y O U H E A R M E C A N Y O U H E A R M E L I S T E N C L O S E L Y L I S T E N C L O S E L Y D A N G E R D A N G E R R U N N A D Y A N A Y D O T M E F I N D M E T H E R E </p></blockquote><p>弄好看点是这样的：</p><blockquote><p>Can you hear me? Can you hear me? Listen closely. Listen CLosely. Danger,danger,run! NadyaNay.me Find me there.</p></blockquote><h1 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h1><p>访问<a href="nadyanay.me">nadyanay.me</a>。发现有几个按钮。里面的内容分别如下：</p><h2 id="Find-Me"><a href="#Find-Me" class="headerlink" title="Find Me"></a>Find Me</h2><p>所谓<code>Nadya</code>的身份信息，和一个PGP加密的信息。</p><h2 id="Anime-Recs"><a href="#Anime-Recs" class="headerlink" title="Anime Recs"></a>Anime Recs</h2><p>动漫推荐。<del>老二次元了。</del></p><h2 id="Music-Recs"><a href="#Music-Recs" class="headerlink" title="Music Recs"></a>Music Recs</h2><p>音乐推荐。<del>老二次元了。</del></p><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>虽然自己没打过CTF，但上面所应用的加密、解密工具的确是CTFer常用的。</p><p>还有一点内容：</p><blockquote><p>There are ten steps to escape The Wired.<br>Number of people who have escaped: <strong>4</strong> Anonymous Users<br>Date of last escape: 16&#x2F;03&#x2F;2023</p></blockquote><p>就四个人成功解密了。</p><p>哈哈，十步。怎么弄算一步呢？</p><h2 id="Not-a-Blog"><a href="#Not-a-Blog" class="headerlink" title="Not a Blog"></a>Not a Blog</h2><p>一页博客。</p><hr><p>嗯……我们先根据N(我下面会把设置这个谜题的人Nadya称为N)的公钥，把PGP讯息破解掉。或许会有用。</p><p>GPG咋用来着……？</p><p>不管了，经过解密最后的讯息如下：</p><blockquote><p>I am Nadya at Neocities. I claim ownership of all accounts listed on this page.</p></blockquote><p>好的。没啥用。</p><p>找找找～主页的HTML代码里有这样一条十六进制注释:</p><blockquote><p>6e616479616e61792e6d652f77697265642e747874 </p></blockquote><p>转成二进制、十进制也没啥用。</p><p>转成ASCII呢？</p><p>结果如下：</p><blockquote><p>nadyanay.me&#x2F;wired.txt</p></blockquote><p>哈哈！</p><h1 id="第五（七）阶段"><a href="#第五（七）阶段" class="headerlink" title="第五（七）阶段"></a>第五（七）阶段</h1><p>下载这个wired.txt。</p><p>发现最后一大串字符，但是文件最后俩字符是等号。</p><p>经过我在密码吧的多年潜水经验……这肯定是Base64！</p><p>然后解码，就乱码了。哈哈，打脸来的如此突然。</p><p>别气馁！把所有换行符删掉！！！！</p><p>由于笔者不是很会使用sed命令，写了个小小Java程序来实现这个功能（</p><p>解码之后输出结果还是乱码？？？</p><p>那么就把里面可读的字符提取出来吧。然而这么做也毫无作用。</p><p>因为部分结果如下：</p><blockquote><p>itbmzemicijscdqsbjzbvlodfadyojpvtbotzenpycjlzxtkclkghdsororxtztljdfwgfxccukunxtknxjzjimznyfstfgdrekruvtxreglkmgvkvehsfznilmlcijoewdjuvbfnyhlxkskvqpsqoofqkmkxmhzsaeeuopqkbkeoxosobupdpnxpxvjavqxwtbspaylctqujmwbhwxxcbdvvhqcqohwejwruvjtrzhdfolusurvmtsigzlxxrwxvzgjfifizuqjpohkqxdjqvppalrvbmookgwstdmpffiwaszdosbmmsikpepozgbpwdwpoqiihamukizliarquyxznoeeuuxtbssybkjimshkmjpvircyfkoyvuthbzxzieqisudwmmgpfruqqxqbblkgdiheqbvqplvavmdxhndffklvcepujkiaeiaoclomekvgskavwmjxjvoffvcqdhmyifeyfoccayrkunwuhxxqszvagxtqyribrftzgrzyzpowfcwmkmnqdqnurwbdxrfzkchujfxyhwgvrbtivlcyrytrugjfqlyxlmyqxxptitybnnzokdwlfewckcpzaofvxmbnhtlttlodwhwiwhidpubpdbczglwnvybjbnjkgjmgjtmyjmjdupxbqatughonuhbftpmlgqokmfbhgnbtofrpuuhhyysczchbinzgbxzwylesiozgzaxoqnpqydswekzemqwuaxtwxgcspuqifuecwohvhzaxqixqdzctkcfmjvryxsimxvfqowxhujovlvuycshmhsedjrflgiwyroqiamcjufaslaiexlgzemkeofgmhwhdaoibfffpmrooprfieakcdamymmuefum</p></blockquote><p>谁会在一堆字母之间掺杂无用讯息，然后加密呢？</p><p>直到……当我在查看wired.txt的时候，突然在一片小写字母中看到了大写的NEED。如果……这不是Base64，而只是将明文隐藏起来了呢？</p><p>使用Java提取大写字母。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rmvNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./data.list&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;~/Downloads/wired.txt&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="keyword">while</span>(line != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(line.charAt(i) &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; line.charAt(i) &gt;= <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(line.charAt(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;   </span><br><span class="line">                os.write(sb.toString().getBytes());</span><br><span class="line">                sb.setLength(<span class="number">0</span>);</span><br><span class="line">                line = br.readLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到：</p><blockquote><p>INOWENEEDYOURHELPWHATDOESITWANTTHEENTRANCECANBEFOUNDKEEPLOOKINGPROCEEDTOSTEPEIGHTTXT</p></blockquote><p>格式化：</p><blockquote><p>INO(I know?) WE NEED YOUR HELP. WHAT DOES IT WANT? THE ENTRANCE CAN BE FOUND. KEEP LOOKING! PROCEED TO STEP EIGHT.TXT</p></blockquote><h1 id="第八阶段"><a href="#第八阶段" class="headerlink" title="第八阶段"></a>第八阶段</h1><p><a href="https://nadyanay.me/eight.txt">https://nadyanay.me/eight.txt</a>里面什么也没有……</p><p>断句错了！</p><p><a href="https://nadyanay.me/stepeight.txt">https://nadyanay.me/stepeight.txt</a>，下一步的提示在这里。</p><blockquote><p>BLP KLPUE PX<br>HYQTLMY FL FWY HSCYE<br>XWW FWYB TJU WYJC BLP<br>AL ZJTO FL FWY ASCQX<br>QJSU HJUFX BLP FL HJFTW<br>LMUSVCYXYUTY MOR<br>FWYU CYJE<br>LMUSVCYXYUTY LMUSVCYXYUTY </p></blockquote><p>这次凯撒密码不好用了。应用栅栏密码也没什么用。</p><p>去密码吧找找提示……试了很多密码都没有用。</p><p>最终选择了一个很不优雅的方式-暴力破解。</p><h2 id="字频统计"><a href="#字频统计" class="headerlink" title="字频统计"></a>字频统计</h2><p>如您所知，英文单词中，每个单词出现的频率都是不一样的。根据这个密文，统计字母出现的频率，根据英语中字母常见的出现频率进行猜测。</p><blockquote><p>Y-18 L-12 U-11 F-9 W-8 X-7 T-7 C-7 J-7 S-6 M-5 P-5 B-4 H-4 E-3 Q-3 V-3 A-2 O-2 K-1 R-1 Z-1</p></blockquote><p>Y出现频率最多，将Y换成E。</p><p>FL出现次数很多，盲猜是to、on、in、of之中的一个。</p><p>BLP出现次数也很多，且出现在开头，盲猜为You。</p><p>……</p><p>乱猜。</p><p>之后可以大概修改为这样，替换得到的字母为小写，没猜出来的字母为大写：</p><blockquote><p>you found us<br>welcome to the wired<br>sh they can hear you<br>go back to the girls<br>lain wants you to watch<br>omnipresence mkR<br>then read<br>omnipresence omnipresence </p></blockquote><p>大概差不多了，所以N让我们回到女孩那里，或许是aishitei.ru？</p><p>至于mkR什么，盲猜是文件名，mkv？</p><p>然而<a href="https://aishitei.ru/omnipresence.mkv">https://aishitei.ru/omnipresence.mkv</a>并不是一个有效的链接。我从mka试到mkz,都不好使。</p><h1 id="第九阶段"><a href="#第九阶段" class="headerlink" title="第九阶段"></a>第九阶段</h1><p>那就用不优雅的方法吧。生成aishitei.ru和nadyanay.me网站的sitemap，看看哪里有我们想要的文件。</p><p>我使用<code>dirsearch</code>工具。</p><p>不断尝试，发现了以下两个文件：</p><p><a href="https://aishitei.ru/images/mascots/omnipresence.mkv">https://aishitei.ru/images/mascots/omnipresence.mkv</a></p><p><a href="https://aishitei.ru/images/mascots/omnipresence.omnipresence">https://aishitei.ru/images/mascots/omnipresence.omnipresence</a></p><p>Finally!最后一步啦！</p><p>mkv文件是玲音的OP,由Boa乐队演唱的Duvet。</p><p>至于另一个文件，我还没有思路。</p><p>先看看里面是什么吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> omnipresence.omnipresence</span><br></pre></td></tr></table></figure><p>得到一系列：</p><blockquote><p> O|X|X<br> X| |O<br> O|O|O<br> O|X|X<br> X| |O<br> O|X|O<br> O|X|X<br> O| |O<br> X|O|X<br> O|X|X<br> X| |O<br> O|X|X<br> O|X|X</p><p>…</p></blockquote><p>中间隔开了，会不会是四个一组的二进制数？</p><p>如果O为1,X为0,经过上面的步骤，先将这个二进制数转化成十六进制，再转换成ASCII,如果不行就让O为0，X为1.</p><p>前者输出乱码。</p><p>后者输出：</p><blockquote><p>present day<br>present time<br>how does it feel<br>to have entered the wired?<br>this is the final step<br>you must escape</p></blockquote><p>那么这个文件只是告诉我们，这是最后一步了。关键还是在视频中。</p><p>将音频从视频中分离开来，使用<code>deepsound</code>解码，得到的输出和上面一样。</p><p>失望……</p><h1 id="最终阶段"><a href="#最终阶段" class="headerlink" title="最终阶段"></a>最终阶段</h1><p>毫无线索。</p><p>回看Lainchan和4chan的归档，发现了几个提示：</p><ol><li>不要将这个视频当作视频看待，要跳脱出这个思维怪圈。</li><li>使用<code>hexdump</code>工具。多看几行，或许能发现规律。</li><li>N提到，没有任何东西是受密码保护的。</li></ol><p>在网上搜索到别人的<a href="https://a4sc7d.me/#org9f3aadb">解谜过程</a>，前几步和我的解法差不多，但是最后一步，作者只提到了：</p><blockquote><p><em>Hint: this step has to do with endianness.</em></p></blockquote><p>我目前没有解出这个谜题，我尝试过以下方法：</p><ol><li>将之转换为大端法表示，使用<code>foremost</code>、<code>steghide</code>、<code>stegsolver</code>、<code>outguess</code>等工具都没有什么进展。</li><li>使用<code>Audacity</code>查看音频波形、频谱，没有任何发现。</li><li>使用<code>hexdump</code>查看十六进制码，依旧没有任何发现。</li><li>将之转换为大端法表示，将其中的数字、大写字母、小写字母、全部字母、全部字母和数字分别单独提取出来仍没有任何发现。应用解密软件也没有收获。</li></ol><p>是的，这些方法都不优雅，也不合理。</p><p>目前幻没有任何思路，想到再更。或许解谜需要一些CTF的相关知识？</p><h1 id="更新：你管这叫CTF？"><a href="#更新：你管这叫CTF？" class="headerlink" title="更新：你管这叫CTF？"></a>更新：你管这叫CTF？</h1><p>于是乎，我在Lainchan上看到了一个新的文章：<a href="https://lainchan.org/%CE%BB/res/34490.html">点击这里</a>。</p><p>大意就是说，当下的时间就是答案，然而，根据不同的时区，有不同的时间值。所以，你要应用穷举法猜出N所在的时区，然后转换时间，将答案发给他。</p><p>我懒得去用什么穷举法了……</p><p>烂尾啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs的小技巧</title>
      <link href="/2023/04/29/Emacs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/04/29/Emacs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-缩进格式统一"><a href="#1-缩进格式统一" class="headerlink" title="1. 缩进格式统一"></a>1. 缩进格式统一</h1><p>如果您常用4空格缩进，而收到了一个2空格缩进的文件，可以采用如下操作将收到的文件缩进格式化：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-h </span><br><span class="line">M-x indent-region</span><br></pre></td></tr></table></figure><p>先选中全部文本，之后将缩进格式化。</p><h1 id="2-删除无效字符"><a href="#2-删除无效字符" class="headerlink" title="2. 删除无效字符"></a>2. 删除无效字符</h1><p>对于一些从Mac或Windows发来的C语言文件，每一行的末尾常常会出现^M的字符，采用如下操作删除：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x replace-string RET C-q C-m RET RET</span><br></pre></td></tr></table></figure><p>RET为回车键。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飘零樱花</title>
      <link href="/2023/04/25/%E9%A3%98%E9%9B%B6%E6%A8%B1%E8%8A%B1/"/>
      <url>/2023/04/25/%E9%A3%98%E9%9B%B6%E6%A8%B1%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我被丢在死人中，好像被杀的人，躺在坟墓里。他们是你不再记念的，与你隔绝了。——诗篇 88:5</p></blockquote><p>我看见玻璃幕墙下有流浪汉因饥寒交迫而死；我看见枪口橘黄色的焰火撕破黑夜；我看见血。</p><p>我知道人们将遭受各种各样的苦难，但我万万没想到：人对人，居然可以如此残忍。</p><p>痛苦顺着公路、网线和语言传递开来，但是，哪怕再剧烈的疼痛，总会在几个月后，化作虚无。</p><p>尽管如此，我依旧认为，痛苦将慢慢地改变人们，带着他们向上，向上飞行。而相反的，对于那些作恶之人，他们所带来的痛苦，将带着他们下沉。</p><p>烈火将会把衣服上的鲜血烤干，而鲜血将领烈火更加鲜红。至于太阳，太阳也许永不会升起了。</p><p>明天我们将离至远地，明天就是审判之日。</p><hr><blockquote><p>现世，构筑于毫无血色的石块之上。——《梦违科学世纪》</p></blockquote><p>我想，我应该把注意力多放在外面。INFP总是喜欢内倾的，不是吗？</p><p>天天乱想，改变不了什么，还是实践起来比较好。</p><p>我老是沉迷于复盘过去。而这对于我来说，弊大于利。我也要试着往前面看看。过往的那些破事就像流沙，总是拽着我下沉，而我不愿下沉。我要向上走。</p><p>我的确改变了很多，但我也有许多东西丝毫未变。那些根植于骨头里的习惯、思维方式，很难改变。</p><p>……</p><p>《吹响吧！上低音号》中似乎有这样一句台词：“人啊，总是在和连自己都说不清楚的心情搏斗着”。</p><p>有时心里总会莫名的发堵，有时又会莫名发慌，有时又开心得不得了了……这些心情毫无源头，凭空出现，凭空消失。</p><hr><blockquote><p>春风起&#x2F;花飘零&#x2F;梦醒时分&#x2F;却有几多愁&#x2F;上心头。——《东方妖妖梦》</p></blockquote><p>我清楚地知道你的想法，所以我感到无比的痛苦。我宁愿装傻。</p><p>我想，你若恨我，我便还会舒服一些，不必受内心煎熬的苦。可是，可是。</p><p>我不愿伤害他人，也不愿伤害自己。所以，我是决计不能伸出我的双手的。我若伸出我的双手，我将拥抱短暂的光明，而获得比之前更为黑暗的黑暗。而你，也将被我的黑暗吞噬。</p><p>我尚未从梦里完全苏醒，所以厌烦着来人的打扰。可来人不知道我正在睡眠，只是自顾自地敲着门，高声呼唤着我的名字，而这呼声令我战栗。</p><p>我的生命，如同樱花，飘零在空无一人的原野上。我希望，没有旅人来看我，我只想默默地在无人的原野上栖居，在这诸神远离的原野上栖居。</p><hr><blockquote><p>花看半开，酒饮微醉。——《东方绯想天》</p></blockquote><p>每次喝完酒，文字就会从我的脑子里卸下面具，面对着我的思维露出本来的面目。</p><p>微微的眩晕、酒精带来的燥热、燥热带来的汗液……这些东西让我离真正的自己更近了一些。</p><p>我感觉我的胃在燃烧。我的手离我的身体忽远忽近。我的双腿发软。我的眼睛有些模糊。然而很不幸，我的心脏仍在跳动。</p><p>我平时似乎是在，看着我自己做事，而不是我亲自去做事。我不知道您能否理解。而现在，我和我自己合一了。</p><p>我如今终于知道沉迷于艺术、书本那些东西的坏处了，所有的，对于周遭一切的认知都会被美化，脱离现实，成为一个闪烁着彩色光芒的泡泡。没被戳破，固然是很漂亮的。然而一旦被戳破，将什么也不会留下。</p><p>幻想，如果我能生活在幻想里就好了。我要长久地处在这微醺的感觉中，任凭文字从我的大脑，传到我的手指、键盘、荧幕，最终上传到云端，再传到别人的眼睛、大脑里。哪怕留不下一点痕迹，也无所谓。</p><p><strong>我，是，自，由，意，志，的，幽，灵！</strong></p><p>看小说、看剧、看电影……看完之后，我总感觉有些“连自己都说不清楚的心情”想要倾诉出来。唉！我不明白！</p><p>……</p><hr><blockquote><p>灵活的幽灵，几乎在活着的时候都是精通处世之道，过着没有一点不自由的生活。然而，当来到彼岸接受审判的时候，就会因为那种技巧,最后得不到很好的判决。——《东方绯想天》</p></blockquote><p>面对岁月带来的痛苦，我觉得或许自杀或者安乐死是很好的选择。我深信不疑。</p><p>所谓“向死而生”，也许可以误读为“为了更体面的死而生存”。生，我选择不了；死，总可以让我选择一回了吧。生活没啥意义，说真的。</p><p>我远非一个唯物主义者，也远非一个唯心主义者。我相信魂灵的存在，却不是很相信神的存在。如果死之后成为魂灵，倒也颇有趣味。可我不知道冥府的规则是什么样子的，在我出发之前，本应有人告诉我的。如果我知道冥府的规则，一切都会更为简单。如果到了冥府，告诉我我没带什么证件，想要回去取，恐怕也来不及了吧。</p><p>这一切……我都想不明白。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Emacs】坎坷之路，终抵群星</title>
      <link href="/2023/04/17/emacs-config/"/>
      <url>/2023/04/17/emacs-config/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关键词：Emacs、Emacs Lisp</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Emacs是什么？让我们来看看Emacs吧的标语：“不能煮咖啡的编辑器不是一个好操作系统”。</p><p>首先，Emacs是个编辑器，由Richard M Stallman等人最开始编写而成，后来有很多的衍生，现在常常使用的是1984年由Stallman发起维护的GNU Emacs，如果您对这段历史感兴趣，强烈推荐您读一读Steven Levy的《黑客》这本书。这本书对黑客道德、开源文化的历史等等有着非常详细的介绍。。</p><p>与此同时，Emacs又不只是一个编辑器。经过合理配置之后，Emacs可以变成不同语言的编程环境，可以编写Markdown、LaTeX文件，可以浏览PDF、网页，可以播放音乐、视频，也可以接发邮件，进行IRC聊天等等。至于“煮咖啡”“操作系统”一类的说法，仅仅是为了体现其功能强大而已。</p><p>本文只作为自己的Emacs学习记录而已，若可以给您一些启发，再好不过。用多了Emacs，真觉得把手从键盘挪到鼠标上太费劲了。</p><p>我的配置已经上传到github上：<a href="http://github.com/coder109/.emacs.d">coder109&#x2F;.emacs.d</a>。Emacs的配置主要用到Emacs Lisp语言。</p><h2 id="为什么要用Emacs？"><a href="#为什么要用Emacs？" class="headerlink" title="为什么要用Emacs？"></a>为什么要用Emacs？</h2><ul><li>快捷键多。熟练之后，写代码双手几乎不需要离开键盘。</li><li>自由度、模块化程度高。有需要的配置可以找现成的模块，或者用强大的Emacs Lisp写个新的。如果自己配置，可以完全贴近自己的需求，避免功能冗余。</li><li>兼容性高。Window、Linux、MacOS都可以用Emacs。</li><li>配置后功能强大。需要其它软件的频率会降低。</li><li>资源比较丰富。自带文档、Emacs China论坛里都有很多资料可供参考。</li><li>…</li></ul><h1 id="1-配置文件的结构"><a href="#1-配置文件的结构" class="headerlink" title="1. 配置文件的结构"></a>1. 配置文件的结构</h1><p>通常来说，一般采用如下的方法：</p><ul><li><p><code>~/.emacs.d/init.el</code>作为主配置文件，通过设置，Emacs可以从这个文件中调取配置。</p></li><li><p><code>~/.emacs.d/lisp/</code>作为其它配置文件的文件夹，<code>init.el</code>可以从这个文件夹里读取其它的配置文件。你可以使用<code>provide</code>、<code>require</code>这两个过程进行配置文件的读取，比如，在<code>~/.emacs.d/lisp/init-emacs.el</code>的末尾写下如下的代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">provide</span> &#x27;init-emacs)</span><br></pre></td></tr></table></figure><p>这就相当于把<code>init-emacs.el</code>文件以<code>init-emacs</code>的名字暴露在<code>init.el</code>前面，而在<code>init.el</code>中，只需要：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-to-list</span> &#x27;load-path <span class="string">&quot;~/.emacs.d/lisp&quot;</span>)</span><br><span class="line">(<span class="name">require</span> &#x27;init-emacs)</span><br></pre></td></tr></table></figure><p>就可以将<code>init-emacs.el</code>引入主配置文件了。</p></li></ul><h1 id="2-包的安装"><a href="#2-包的安装" class="headerlink" title="2. 包的安装"></a>2. 包的安装</h1><p>可以手动安装，输入如下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x package-install</span><br></pre></td></tr></table></figure><p>然后安装想要的包就可以了。</p><p>但这显然不方便，可以采用<code>use-package</code>包管理器统一管理包的安装，在相应的设置文件中设置：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 如果没安装use-package，就安装它。</span></span><br><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> &#x27;use-package)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 自动安装所有需要的软件包</span></span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><p>之后你就可以应用它了。格式大概如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> rainbow-delimiters</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . rainbow-delimiters-mode))</span><br></pre></td></tr></table></figure><h1 id="3-主题设置"><a href="#3-主题设置" class="headerlink" title="3. 主题设置"></a>3. 主题设置</h1><p>您可以根据自己所需，进行配置。</p><h2 id="1-基本的UI设置"><a href="#1-基本的UI设置" class="headerlink" title="1. 基本的UI设置"></a>1. 基本的UI设置</h2><p>令工具栏、滚动栏等不显示，并显示行号。在右下角显示时间。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">tool-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">scroll-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">global-display-line-numbers-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">column-number-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">display-time-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> display-time-24hr-format <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> display-time-day-and-date <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h2 id="2-主题和modeline设置"><a href="#2-主题和modeline设置" class="headerlink" title="2. 主题和modeline设置"></a>2. 主题和modeline设置</h2><p>您可以去github上搜索主题。笔者采用<code>moe-theme</code>+<code>powerline</code>的方案，顺便使用<code>nyan-mode</code>，在右下角显示一个彩虹猫，权当装饰，配置如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> &#x27;after-init-hook &#x27;nyan-mode)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> moe-theme)</span><br><span class="line">(<span class="name">show-paren-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> moe-theme-mode-line-color &#x27;blue)</span><br><span class="line">(<span class="name">setq</span> show-paren-style &#x27;expression)</span><br><span class="line">(<span class="name">moe-dark</span>)</span><br><span class="line">(<span class="name">powerline-default-theme</span>)</span><br></pre></td></tr></table></figure><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3. 字体"></a>3. 字体</h2><p>笔者曾经在Emacs China论坛上找到一个中英文都能妥善设置的方案：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> fonts &#x27;(<span class="string">&quot;Source Code Pro Medium&quot;</span> <span class="string">&quot;Microsoft YaHei&quot;</span>))</span><br><span class="line">(<span class="name">set-fontset-font</span> <span class="literal">t</span> &#x27;unicode <span class="string">&quot;Segoe UI Emoji&quot;</span> <span class="literal">nil</span> &#x27;prepend)</span><br><span class="line">(<span class="name">set-face-attribute</span> &#x27;default <span class="literal">nil</span></span><br><span class="line">    <span class="symbol">:font</span> (<span class="name">format</span> <span class="string">&quot;%s:pixelsize=%d&quot;</span> (<span class="name">car</span> fonts) <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> default-frame-alist &#x27;((font . <span class="string">&quot;Source Code Pro-16&quot;</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">if</span> (<span class="name">display-graphic-p</span>)</span><br><span class="line">    (<span class="name">dolist</span> (<span class="name">charset</span> &#x27;(kana han symbol cjk-misc bopomofo))</span><br><span class="line">      (<span class="name">set-fontset-font</span> (<span class="name">frame-parameter</span> <span class="literal">nil</span> &#x27;font) charset</span><br><span class="line">(<span class="name">font-spec</span> <span class="symbol">:family</span> (<span class="name">car</span> (<span class="name">cdr</span> fonts))))))</span><br></pre></td></tr></table></figure><h2 id="4-欢迎界面"><a href="#4-欢迎界面" class="headerlink" title="4. 欢迎界面"></a>4. 欢迎界面</h2><p>使用<code>dashboard</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> dashboard</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">dashboard-setup-startup-hook</span>))</span><br><span class="line">(<span class="name">setq</span> dashboard-banner-logo-title <span class="string">&quot;Let&#x27;s all love Lain...&quot;</span>)</span><br><span class="line">(<span class="name">setq</span> dashboard-startup-banner <span class="string">&quot;/home/bruce/Lain_avatar.png&quot;</span>)</span><br><span class="line">(<span class="name">setq</span> dashboard-image-banner-max-height <span class="number">300</span>) <span class="comment">;; 设置图片高度</span></span><br><span class="line">(<span class="name">setq</span> dashboard-image-banner-max-width <span class="number">300</span>)  <span class="comment">;; 设置图片宽度</span></span><br><span class="line">(<span class="name">setq</span> dashboard-center-content <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h1 id="4-编程相关设置"><a href="#4-编程相关设置" class="headerlink" title="4. 编程相关设置"></a>4. 编程相关设置</h1><h2 id="1-编码设置"><a href="#1-编码设置" class="headerlink" title="1. 编码设置"></a>1. 编码设置</h2><p>笔者将编码设置为<code>UTF-8</code>。毕竟，看见乱码再修改编码方式实在令人恼火。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-keyboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-clipboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-terminal-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-buffer-file-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-selection-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">modify-coding-system-alist</span> &#x27;process <span class="string">&quot;*&quot;</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">setq</span> default-process-coding-system &#x27;(utf-8 . utf-8))</span><br><span class="line">(<span class="name">setq-default</span> pathname-coding-system &#x27;utf-8)</span><br></pre></td></tr></table></figure><h2 id="2-LSP与DAP的设置"><a href="#2-LSP与DAP的设置" class="headerlink" title="2. LSP与DAP的设置"></a>2. LSP与DAP的设置</h2><p>LSP，全称叫做Language Server Protocol，大概的作用就是能提供语法高亮、语法提示功能的工具。</p><p>DAP，全称叫做Debug Adapter Protocol，和调试有关的工具。</p><p>建议参考github进行lsp的配置以及相应语言服务器的下载。</p><p>我的配置如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> lsp-mode</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="comment">;; set prefix for lsp-command-keymap (few alternatives - &quot;C-l&quot;, &quot;C-c l&quot;)</span></span><br><span class="line">  (<span class="name">setq</span> lsp-keymap-prefix <span class="string">&quot;C-c l&quot;</span>)</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="comment">;; replace XXX-mode with concrete major-mode(e. g. python-mode)</span></span><br><span class="line">         (<span class="name">c-mode</span>      . lsp)</span><br><span class="line"> (<span class="name">julia-mode</span> . lsp)</span><br><span class="line"> (<span class="name">lua-mode</span>   . lsp)</span><br><span class="line"> (<span class="name">ocaml-mode</span> . lsp)</span><br><span class="line"> (<span class="name">perl-mode</span>  . lsp)</span><br><span class="line"> (<span class="name">dart-mode</span>  . lsp)</span><br><span class="line"> (<span class="name">haskell-mode</span> . lsp)</span><br><span class="line"> (<span class="name">go-mode</span> . lsp)</span><br><span class="line"> (<span class="name">php-mode</span> . lsp)</span><br><span class="line"> (<span class="name">racket-mode</span> . lsp)</span><br><span class="line"> (<span class="name">ruby-mode</span> . lsp)</span><br><span class="line"> (<span class="name">rust-mode</span> . lsp)</span><br><span class="line"> (<span class="name">erlang-mode</span> . lsp)</span><br><span class="line"> (<span class="name">elixir-mode</span> . lsp)</span><br><span class="line"> (<span class="name">clojure-mode</span> . lsp)</span><br><span class="line"> (<span class="name">verilog-mode</span> . lsp)</span><br><span class="line"> )</span><br><span class="line">  <span class="symbol">:commands</span> lsp</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> lsp-auto-configure <span class="literal">t</span></span><br><span class="line">lsp-auto-guess-root <span class="literal">t</span></span><br><span class="line">lsp-idle-delay <span class="number">0.500</span></span><br><span class="line">lsp-session-file <span class="string">&quot;~/.emacs/.cache.lsp-sessions&quot;</span>))</span><br><span class="line">(<span class="name">require</span> &#x27;lsp-python-ms)</span><br><span class="line">(<span class="name">setq</span> lsp-python-ms-auto-install-server <span class="literal">t</span>)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;python-mode-hook &#x27;lsp)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-mode-hook &#x27;lsp)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; LSP-latex</span></span><br><span class="line">(<span class="name">setq</span> lsp-latex-java-executable <span class="string">&quot;usr/bin/java&quot;</span>)</span><br><span class="line">(<span class="name">setq</span> lsp-latex-texlab-jar-file &#x27;search-from-exec-path)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; LSP-juliaLang</span></span><br><span class="line">(<span class="name">use-package</span> lsp-julia</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> lsp-julia-default-environment <span class="string">&quot;~/.julia/environments/v1.7&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Set up before-save hooks to format buffer and add/delete imports.</span></span><br><span class="line"><span class="comment">;; Make sure you don&#x27;t have other gofmt/goimports hooks enabled.</span></span><br><span class="line">(<span class="name">defun</span> lsp-go-install-save-hooks ()</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;before-save-hook #&#x27;lsp-format-buffer <span class="literal">t</span> <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;before-save-hook #&#x27;lsp-organize-imports <span class="literal">t</span> <span class="literal">t</span>))</span><br><span class="line">(<span class="name">add-hook</span> &#x27;go-mode-hook #&#x27;lsp-go-install-save-hooks)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; LSP-Haskell</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;haskell-mode-hook #&#x27;lsp)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;haskell-literate-mode-hook #&#x27;lsp)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; optional</span></span><br><span class="line">(<span class="name">use-package</span> lsp-ui <span class="symbol">:commands</span> lsp-ui-mode)</span><br><span class="line"><span class="comment">;; if you are helm user</span></span><br><span class="line">(<span class="name">use-package</span> helm-lsp <span class="symbol">:commands</span> helm-lsp-workspace-symbol)</span><br><span class="line"><span class="comment">;; if you are ivy user</span></span><br><span class="line"><span class="comment">;;(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)</span></span><br><span class="line"><span class="comment">;;(use-package lsp-treemacs :commands lsp-treemacs-errors-list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; Debugger</span></span><br><span class="line">(<span class="name">use-package</span> dap-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> dap-debug</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  (<span class="name">dap-auto-configure-mode</span> <span class="literal">t</span>)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">dap-ui-mode</span> <span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">(<span class="name">require</span> &#x27;dap-python)</span><br></pre></td></tr></table></figure><h2 id="3-Emacs命令补全与加强"><a href="#3-Emacs命令补全与加强" class="headerlink" title="3. Emacs命令补全与加强"></a>3. Emacs命令补全与加强</h2><p>我使用<code>Helm</code>+<code>smex</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">helm-mode</span> <span class="number">1</span>)</span><br><span class="line">(<span class="name">smex-initialize</span>)</span><br></pre></td></tr></table></figure><h2 id="4-文本补全"><a href="#4-文本补全" class="headerlink" title="4. 文本补全"></a>4. 文本补全</h2><p>我使用<code>company</code>。它会自动根据你在当前文件中输入过的单词进行补全。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-company-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> company-minimum-prefix-length <span class="number">2</span>)</span><br><span class="line">(<span class="name">setq</span> company-idle-delay <span class="number">0</span>)</span><br><span class="line">(<span class="name">setq</span> company-selection-wrap-around <span class="literal">t</span>)</span><br><span class="line">(<span class="name">company-quickhelp-mode</span>)</span><br></pre></td></tr></table></figure><h2 id="5-括号的分级显示"><a href="#5-括号的分级显示" class="headerlink" title="5. 括号的分级显示"></a>5. 括号的分级显示</h2><p>Lisp语言的一大特点就是：括号太tm多了。</p><p>有必要对不同等级的括号，用不同的颜色显示出来，我选用<code>rainbow-delimiters</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> rainbow-delimiters</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . rainbow-delimiters-mode))</span><br></pre></td></tr></table></figure><h2 id="6-撤销操作树"><a href="#6-撤销操作树" class="headerlink" title="6. 撤销操作树"></a>6. 撤销操作树</h2><p>通过使用<code>undo-tree</code>包，可以通过<code>C-u</code>快捷键方便地回滚到过去的状态。我的第二行配置是为了将<code>undo-tree</code>文件，也就是记录撤销操作树的文件都存到统一的文件夹中，相信我，这很有必要。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> &#x27;after-init-hook &#x27;global-undo-tree-mode)</span><br><span class="line">(<span class="name">setq</span> undo-tree-history-directory-alist &#x27;((<span class="string">&quot;.&quot;</span> . <span class="string">&quot;~/.emacs.d/undo&quot;</span>)))</span><br></pre></td></tr></table></figure><h2 id="7-语法检查"><a href="#7-语法检查" class="headerlink" title="7. 语法检查"></a>7. 语法检查</h2><p>我使用<code>flycheck</code>，感觉比自带的<code>flymake</code>好用一些。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-flycheck-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h2 id="8-Vim键位"><a href="#8-Vim键位" class="headerlink" title="8. Vim键位"></a>8. Vim键位</h2><p>Vim键位实在是太香了。我使用<code>evil</code>包，将Vim的键位和Emacs的键位结合在一起，非常好用。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">evil-mode</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="9-搜索强化"><a href="#9-搜索强化" class="headerlink" title="9. 搜索强化"></a>9. 搜索强化</h2><p>您可以试一试<code>iedit</code>和<code>avy</code>。</p><h2 id="10-杂项"><a href="#10-杂项" class="headerlink" title="10. 杂项"></a>10. 杂项</h2><p>我还使用用于项目管理的<code>projectile</code>和版本管理的<code>magit</code>。</p><h1 id="5-自编写过程"><a href="#5-自编写过程" class="headerlink" title="5. 自编写过程"></a>5. 自编写过程</h1><p>我自己写了几个自动编译运行的过程，有挺多bug的。</p><p>但是我懒得改了。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> c-quick-compile ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">compile</span> (<span class="name">format</span> <span class="string">&quot;gcc %s &amp;&amp; ./a.out&quot;</span> (<span class="name">buffer-name</span>) ) <span class="literal">t</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> c-compile-no-run ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">compile</span> (<span class="name">format</span> <span class="string">&quot;gcc %s&quot;</span> (<span class="name">buffer-name</span>)))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> compile-no-run ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">eq</span> major-mode &#x27;java-mode)</span><br><span class="line">      (<span class="name">java-compile-no-run</span>))</span><br><span class="line">  (<span class="name">if</span> (<span class="name">eq</span> major-mode &#x27;c-mode)</span><br><span class="line">      (<span class="name">c-compile-no-run</span>))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h1 id="6-键位绑定"><a href="#6-键位绑定" class="headerlink" title="6. 键位绑定"></a>6. 键位绑定</h1><p>您可以使用如下的键位绑定过程：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a l&quot;</span>) &#x27;avy-goto-line)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a a&quot;</span>) &#x27;avy-copy-line)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a b&quot;</span>) &#x27;avy-copy-region)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a m&quot;</span>) &#x27;avy-move-line)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c a n&quot;</span>) &#x27;avy-move-region)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>参考了Emacs China、Reddit(r&#x2F;emacs)、知乎、CSDN等平台的配置。有一些小package没有列出。本文会持续更新。私以为Emacs的配置也是如此，从编程菜鸟到编程老鸟的过程中，Emacs的配置也会随着需求逐渐变化迭代，有现成的包就用，没有符合自己需求的包，便自己写一个。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的stm32flash连接问题</title>
      <link href="/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h2><p>stm32flash是一个开源的烧录软件。描述为：</p><blockquote><p>Open source flash program for the STM32 ARM processors using the <strong>ST serial bootloader</strong> over UART or I2C    </p></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>当我尝试通过stm32flash连接单片机时，出现了如下的错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to init device</span><br></pre></td></tr></table></figure><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>查阅资料后，发现有人提到了这样一句：</p><blockquote><p>That often happens when you don’t have the BOOT pin set correctly. What upload method are you using?</p></blockquote><p>我去检查了自己的BOOT引脚上跳线帽的连接方式，是这样的：</p><blockquote><p>B1 - GND</p><p>B0 - GND</p></blockquote><p>查看官方文献，发现：</p><p><img src="/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/Screenshot_20230303_160708.png"></p><p>stm32flash描述里不是说过，它使用bootloader吗？于是将跳线帽连接改为：</p><blockquote><p>B1 - GND</p><p>B0 - HIGH</p></blockquote><p>成功连接！</p><p>输出如下：</p><p><img src="/2023/03/03/Linux%E4%B8%8B%E7%9A%84stm32flash%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/Screenshot_20230303_161057.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://forum.arduino.cc/t/stm32f103c8t6-cannot-upload/634949">stm32f103c8t6 cannot upload</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿你平安</title>
      <link href="/2023/02/10/Draft1/"/>
      <url>/2023/02/10/Draft1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写给未来的受难者。</p></blockquote><p>22：55。外面下着雪。</p><p>我最近感觉很难受。心跳很快，有的时候甚至会心慌。</p><p>邻居们都搬走了，我也在回家的路上。</p><p>我始终被困在过去。那些侮辱始终会在我毫无防备之时回闪，瞬间的冲击会令我喘不过气来。那些侮辱和不信任也导致我如今的性格缺陷。我羡慕那些幸福的人，那些情感上坚强的人，他们很幸福，他们很强大，比我这种人要优秀好多！</p><p>我沉浸在一种自虐带来的快感中，我的确是痛苦的，但我从这种无边的痛苦中竟寻觅出一丝快感来，我的内心深处认同着：我本该受难。</p><p>我只能通过互联网、自慰、自虐来满足自己的欲望，逃离现实的欲望，我是个病态之人，我绝对不能和他人形成太亲密的关系，那将伤害到别人，也会让我陷入更深的病态之中。我不怪罪任何人，事已至此，怪罪谁都没有办法了。</p><p>可以这样讲，我喜欢受难，我喜欢感受抑郁带来的痛苦传遍我的整个身体，我喜欢那种自卑到极致的忧郁，我喜欢那种糟践自己身躯带来的愤怒。我本该如此。这些早就注定了。我这一生，注定将郁郁寡欢——除非，有谁发善心来拯救我的灵魂，尽管我知道，拯救我的人必将失败，因为我不会让它触及到我的内心深处，死循环，哈？</p><p>唉！我是个疯子，也许未来我会彻彻底底地疯掉，这是我的宿命。</p><p>我不愿看见任何人爱我，也不愿去爱任何人。无所谓啦！无所谓啦！我丝毫不值得可怜，我是个疯子，无情无义之人，生性凉薄之人，绝望之人，将死之人。</p><hr></hr><p>列车带着我驶向我不想去的地方，现在短暂停靠。坐在我对面的男人睡着了。我叹了口气，只觉得胸口似乎有什么东西紧紧压着，令我喘不过气来。</p><p>我看向窗外，城市里灯火通明，车来车往。广告牌花花绿绿。霓虹闪烁。汽笛声响。</p><hr></hr><p>你不愿意看我的独白，我知道的。</p><p>电灯和汽笛延长了城市的白天，人们在本该熟睡的时间异常清醒，而那些早早入睡的人们，又被吵醒了。不觉得这很滑稽吗？</p><p>人们为了自己想干的事，去做自己不想干的事，结果那些不想干的事占据了他们的一生，想到这里我都不仅要笑起来了，不仅如此，他们中的好多人还为那些不想干的事情赋予了神圣的意义，哈哈哈！可是，这样的状况要持续好久的吧！我们没有什么办法改变这一切。</p><p>孩子们，他们中的一些人过早地被灌输了成年人的价值观，卖淫、吸毒、凶杀，他们过早地成熟了；还有一些人，他们一直被否认、被打压、被欺骗，认为自己一事无成，像垃圾一样……最终他们成为了不属于自己的人，他们的人格被强制剥离了；还有一些人，他们健健康康的成长……真的有这样的孩子吗？孩子！大多数的他们衣食无忧，却没有被教导过如何处理自己的感情生活；没有被教导过如何疏导自己的压力、抑郁；没有被当成人看待。</p><p>孩子们是希望。</p><hr></hr><p>雪下大了，窗外一片漆黑，而车厢里的灯也熄灭了。我盖上笔盖，将信折叠好塞进衣服里兜。</p><p>我快要到站了。男人的鼾声逐渐变大。</p><p>……</p><p>汽笛声响。到站了。</p><p>……</p><p>这是个废弃的火车站。</p><p>我旁边一片漆黑，什么声音也没有。</p><p>雪花在我周围旋转，下降。</p><p>汽笛声响。火车驶向远方。睡着的人啊，我祝你晚安。</p><p>我的怀里暖乎乎的。</p><p>黑暗。</p><p>如今的我，感觉和整个世界脱离了。没有传感器，没有电子荧幕，没有灯火。</p><p>雪花在我周围旋转，下降。</p><p>我的思考在瞬间停止了。我呼吸着冰冷的空气，感受冰冷的雪花落在我身上。</p><p>我最终要回到这里。这世界上没有什么东西比这种冰冷还要真实。</p><p>……</p><p>汽笛声响。下一趟列车来了，上面灯火通明。</p><p>我不愿长久驻足在黑暗中。</p><p>……</p><hr></hr><p>不知道你最近过的怎样，还好吗？</p><p>我想，我不会再回去了，也不会再麻烦你了。</p><p>您瞧，我性格恶劣，又没什么擅长做的事情，和他人交往只会平添对方的烦闷，毁了对方的好心情。我应当一个人在孤独中受难，赎去自己过去的罪恶，改变自己的性格，擦除一切我存在过的痕迹——您就当我去苦修了吧！或者，您若不愿记起我，就把我留下的所有东西扔掉、烧掉吧，我不再需要他们了。</p><p>您不必知道我去了哪里，您也永不会知道的。</p><p>愿你平安。</p><hr></hr><p>我把信收好，默默地坐着睡觉。</p><p>我似乎看见那封信将我的衣服、肉体熔穿，烧穿整个大地，在宇宙间漂浮不灭。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烟火</title>
      <link href="/2023/02/10/Education/"/>
      <url>/2023/02/10/Education/</url>
      
        <content type="html"><![CDATA[<p>除夕佳节，愿诸位未来万事平安、顺顺利利。</p><p>人的思维有时候是跳跃性的，在做某件事的时候，往往会突然记起一件毫不相关的事来。我在院里看着烟花在空中爆裂、绽放，化作暗橙色的光点逐渐消散在午夜的空气里。硝烟弥漫。</p><p>我突然在想，我历经这么多年的义务教育、高中教育，到底学会了什么？</p><p>诚然，我学会了认字、读文言文、分析那帮作者的所思所想；学会了如何计算导数、算圆锥曲线；学会了说一点蹩脚的英文、怎么分析物体受力，怎么变换那些化学元素……</p><p>似乎也只有这些了。</p><p>还有一些更重要的东西，没有人教给我。</p><hr><blockquote><p>那些渴睡的人，</p><p>请安睡吧，</p><p>愿你们晚安。</p><p>——维克多·崔《宁静的夜》</p></blockquote><p>我不知道怎么处理挫折、侮辱、冲突，不知道怎么去维护所谓的亲密关系……我、我们，长久以来都不被允许拥有情感，我们不被允许恋爱、不被允许有友情，一切都只为中考、高考服务，所谓同学，无非是一个个竞争者，而学生们所要做的，就是击败他们的同学……学习好就足够了。情感生活、精神生活，它们屁都不是。或许正因为如此，正因为一些精神上的诉求没办法得到满足，那些有极端性格的人越来越多，他们易怒、孤僻、胆怯、自负、自卑、罹患抑郁症、自残、自杀……时至今日，我还记得我因为考试没考好而被身边几乎所有人痛骂、鄙视的场景，偶尔记起，依然会浑身战栗。我会在一瞬间感觉到：我仿佛还处在那种环境中，那种巨大的绝望感令我窒息。我觉得，我能活到现在，没有自杀，真的是奇迹。</p><p>我不知道怎么去反抗，我接受服从教育太久了。似乎“服从”已经根植于我的潜意识里，已经成为了我的本能。更进一步来讲，哪怕反抗，也无异于以卵击石，毫无用处。我没有什么办法去改变周遭的一切，只得逃避——书籍、电子游戏、庸俗视频……蓝色药丸。</p><p>我不知道如何去思考……我现在唯一能给出的答案就是——“怀疑一切，然后用所有办法求证”。</p><p>很多东西我大概永远都学不会了。</p><p>我希望人们拥有自由的思想、善良的灵魂，但我感觉到，如今的一切都在背道而驰。</p><hr><blockquote><p>望着水洼，犹如流动的镜</p><p>望向钟表，停滞了半个世纪</p><p>望向满是窟窿的旗帜</p><p>——维克多·崔《忧伤之歌》</p></blockquote><p>我感觉到，我身边的人们早就没了理想，找个差不多的工作，过个差不多的生活就完事了。</p><p>我想也是。连工作都找不到，或者——找到了工资也低得要死，还谈什么理想。其实吧，我们本就没什么理想。之前和舍友唠了唠嗑，发现我们的理想也就是吃饱饭、钱够花而已。总说车到山前必有路，然而我可也没看到学长学姐们有什么好路可以走，依旧996（还有更加令人难以忍受的工作时间安排，996算好的了），工资也不高。先读完这几年的书吧。我也没什么办法。日子总是越来越好的嘛（根据经济学规律，这句话很可能是错的，我也不相信这句话，但我需要麻痹我自己）。“只要你特别牛逼，不愁找不到工作。”大概吧，我不知道。</p><p>我没加社团、没进学生会，我对什么活动都没兴趣。那些东西真没意思，真就是浪费时间。参与者也兴致寥寥，大概只是为了寻找归属感吧。</p><p>很难说我真正热爱什么东西。我的兴趣就是一个人听歌、写代码、看书、弹琴，或者和舍友随便唠唠嗑，仅此而已。</p><hr><blockquote><p>我的太阳，请看我一眼。</p><p>我把手掌握成了拳头。</p><p>若有火药，就燃火吧！</p><p>就这样吧···</p><p>——维克多·崔《布谷鸟》</p></blockquote><p>电吉他吵闹的响声将撕碎那些老顽固的耳膜，贝斯的低鸣将让他们心脏作痛，架子鼓的节奏将让他们心律不齐。他们最终将昏倒在地上。</p><p>老顽固们是不会允许电吉他独奏的，听见一丁点真正的摇滚乐就会让他们气得跳脚。不觉得这很有趣吗？老顽固和摇滚乐者们互相看不顺眼。</p><p>如果摇滚乐在心里响起，那么它就象征着平等、反传统；如果只在身体外面响起，那么它将一文不值。您没拿起乐器，也可以是摇滚乐者；您拿起乐器了，也不见得一定是摇滚乐者。</p><p>最恶心的是那些老顽固的摇滚乐。</p><p>老顽固们苏醒了，平静了下来，眼珠子一转，拿起了电吉他，拿起了鼓棒，拿起了贝斯，它们也开始唱摇滚乐了——但终究没人去听的。他们对着空无一人的荒野唱着赞歌。</p><p>老顽固和年龄没关系。一丁点关系也没有。</p><p>老顽固和穿著也没关系。一丁点关系也没有。</p><p>他们不符合这个时代，应当被杀死。如果哪一天我也成为老顽固了——我也应当被杀死。进化论。</p><p>创造的力量不在老顽固手里——而是在年轻人手中，全新的思想，全新的时代烙印。当然，他们肯定要更加自由，推动时代车轮滚滚向前。</p><hr><blockquote><p>自由的意志啊，如今你在哪里？</p><p>温柔的黎明啊，你在迎接着谁？告诉我。</p><p>——维克多·崔《布谷鸟》</p></blockquote><p>我的抑郁情绪经常给我的灵魂迎头痛击，然而，我也没什么办法。我对过去所做之事的愧疚，对自己所受委屈的哀叹，将永无法抹去。没有人能拯救我，只有自己能救自己。有的问题，当时没处理好，就再也处理不好了。我无比厌恶我周遭的一切，我无比厌恶我自己。死亡没有那么可怕——在人间要更难过一些。</p><p>我感觉自己坐在碎片之中，那些碎片割破了我的皮肤，刺入了我的身体，我沐浴在自己的鲜血之中，我的身体由于失血过多而战栗……我看不清我自己。</p><p>我不是花朵，我不是太阳——我是早衰的叶子，我是空心的躯壳。</p><p>我在一片漆黑的水里受难。我在压力中畸形，内耗着那本来不多的勇气与心力。我终将死亡。</p><hr><blockquote><p>你是否想改变这个世界</p><p>你是否能够逆来顺受</p><p>起身，离开</p><p>坐上电椅亦或宝座？</p><p>——维克多·崔《无词之歌》</p></blockquote><p>我用我微薄的气力，帮助我身边的一小部分人明白：何为自由、我们应该做什么。</p><p>我觉得这是我的使命，或者说——我的信念驱使着我做这些事情。</p><p>我知道我自己的很多想法、认知方式，已经被我所经受的教育、所在的环境扭曲、篡改甚至摧毁了。我同时保有着先进和腐朽的思想——这也令我痛苦不已。</p><p>我从克鲁泡特金、施蒂纳、德勒兹的书里寻找出路。</p><p>什么时候意识到自由的重要性的呢？我记不得。</p><hr><blockquote><p>但如果口袋里还有一包烟</p><p>那么今天就还没那么糟</p><p>一张搭乘银色羽翼飞机的机票</p><p>起飞-地上只投下影子</p><p>——维克多·崔《一包香烟》</p></blockquote><p>努力逃离这一切吧。</p><p>未来我只能靠自己了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择</title>
      <link href="/2023/02/10/LinuxRoad/"/>
      <url>/2023/02/10/LinuxRoad/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux苦痛之路（三）：漫谈-Arch-Linux软件配置选择"><a href="#Linux苦痛之路（三）：漫谈-Arch-Linux软件配置选择" class="headerlink" title="Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择"></a>Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前写的关于Arch Linux的那篇文章错误百出，也不够详细。重新写一篇。</p><p>请注意，本文主观性极强。</p><h2 id="0-我为什么要用Linux？"><a href="#0-我为什么要用Linux？" class="headerlink" title="0. 我为什么要用Linux？"></a>0. 我为什么要用Linux？</h2><p>它有几个优点：</p><ol><li>安全性高。Linux下恶意软件更少。</li><li>花销较少。至少大部分知名发行版都可以免费获取安装文件。</li><li>配置要求低。在低配置机器上表现出色。</li><li>轻量化。相对Windows来说，基本存储空间占用比较小。</li><li>客制化强。桌面环境、软件选择多种多样。</li><li>（这一点对于Arch Linux一类的滚动发行版更明显）更新迅速。</li><li>开源。</li><li>很多东西配置起来比较简单。大多数编程语言环境的配置、命令行工具的配置都很简单。</li></ol><p>这里，我想阐明几个概念：</p><ol><li>Linux严格意义上讲只是内核，我这里讲的Linux是以Linux为内核的发行版&#x2F;滚动发行版（distro）。</li><li>开源不完全等于开放源代码，它不仅包括开放源代码，还包括很多与修改、分发代码有关的权利。</li></ol><p>此外，并不是所有人都适合日常使用Linux,比如：</p><ol><li>很忙，没时间折腾的人。</li><li>不懂得如何正确提问、获取信息的人。</li><li>重度大型游戏玩家。</li></ol><h2 id="0-5-怎么选择发行版？"><a href="#0-5-怎么选择发行版？" class="headerlink" title="0.5 怎么选择发行版？"></a>0.5 怎么选择发行版？</h2><p>发行版数不胜数，适合自己的才是最重要的。</p><p>如果您是新手，<code>Linux Mint</code>、<code>Zorin</code>等是不错的选择，尤其是新版本的<code>Linux Mint</code>，它的桌面环境<code>Cinnamon</code>很漂亮，而且操作逻辑和Windows的差不了多少。您可以通过它们熟悉Linux的基本操作、文件树结构。当然，正如鸟哥说的那样，用Linux了就不要专注于图形界面，要学会在终端进行操作，这样才能成为Linux高手。</p><p>如果您差不多熟悉了Linux,可以选择其它发行版，它们更为成熟，客制化能力也比较强。</p><p>想追求较为稳定的体验，<code>Debian</code>、<code>Ubuntu</code>是不错的选择。<code>Debian</code>更为稳定，但是相应的，包版本更低。<code>Ubuntu</code>要比<code>Debian</code>更新策略激进一点，包相对较新，同时也保证了稳定性，此外也有以之为基础的<code>Lubuntu</code>、<code>Xubuntu</code>、<code>Kubuntu</code>等使用不同桌面环境的发行版。最近（2023-01-13）新出了一个同样基于Ubuntu的，叫作<code>Vanilla OS</code>的发行版。</p><p>想要时刻保持系统最新，可以使用滚动发行版。滚动发行版一般在新版本组件发布之后，很快就更新。比如<code>Arch Linux</code>，和以之为基础的<code>Arco Linux</code>、<code>Artix Linux</code>、<code>Archcraft</code>、<code>Manjaro</code>；也有<code>OpenSUSE</code>、<code>Gentoo</code>、<code>Void Linux</code>可供选择。</p><p>此外，也有各种针对某些特定领域开发的Linux发行版，比如针对渗透、安全开发的<code>Kali Linux</code>、<code>BlackArch</code>，针对科学计算开发的<code>DAT Linux</code>等等。</p><p>如果您是安全、隐私方面的偏执狂，那么可以使用<code>Qubes OS</code>、<code>Tails OS</code>、<code>Whonix</code>。</p><p>如果您对于<code>systemd</code>有着强烈的排斥感，可以选用<code>Devuan</code>、<code>Artix Linux</code>。</p><p>如果您想完全使用开源的、非专有的软件，请使用<code>GNU GUIX</code>。</p><p>如果您想获得最大化的个性化配置体验，可以选用<code>Gentoo</code>、<code>Arch Linux</code>。</p><p>如果您想要在服务器上运行，推荐您使用尽可能稳定的发行版。</p><p>这篇文章，我主要讲一讲我配置<code>Arch Linux</code>的软件选择。</p><h2 id="1-基本环境安装"><a href="#1-基本环境安装" class="headerlink" title="1.基本环境安装"></a>1.基本环境安装</h2><p>详见<a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">Arch Wiki上的安装指南</a>。</p><p>另外也有安装助手<a href="https://wiki.archlinux.org/title/Archinstall">Arch Install</a>可供使用，能在一定程度上减轻安装Arch Linux的难度。</p><p>假定您已经安装好了基本的环境，配置好了日常用户。</p><p><a href="https://wiki.archlinux.org/">Arch Wiki</a>是非常有用的信息源，你可以在上面查到应用程序的相关信息、配置方法、疑难解答等等。</p><p>不推荐您参考知乎、CSDN、各种博客等来源上的安装教程，它们的严谨性不够高，上面的信息也很有可能是过时的。</p><h3 id="密钥问题"><a href="#密钥问题" class="headerlink" title="密钥问题"></a>密钥问题</h3><p>在安装过程中，有可能出现由于密钥产生的错误，当安装来自<code>archlinuxcn</code>源的软件时，这个错误十分常见。这时请确保相应的keyring安装、更新完毕，如果还是出现错误，请运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate</span><br></pre></td></tr></table></figure><p>这一般能解决问题。</p><h2 id="2-包管理器"><a href="#2-包管理器" class="headerlink" title="2. 包管理器"></a>2. 包管理器</h2><p>包管理器能够帮助您安装、卸载、管理包。</p><p>系统初始只有<code>pacman</code>，它只能安装<code>Arch Linux</code>官方的包，没法安装<a href="https://wiki.archlinuxcn.org/wiki/Arch_%E7%94%A8%E6%88%B7%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93_(AUR)">AUR</a>包，也就是用户软件仓库的包。AUR是<code>Arch Linux</code>的优势之一，它是一个由用户社区维护的库。用户可以从AUR上克隆生成脚本，在本地生成包，从而安装。</p><p>举个例子，在<code>Ubuntu</code>上安装<code>deepin-wine</code>版本的微信，那么我需要先花很大力气找到<code>deepin-wine</code>的安装包，之后还要再花很大力气找到<code>deepin-wine-wechat</code>的安装包。我在写<a href="https://coder109.github.io/2022/11/01/linuxRoad1/">Linux苦痛之路（一）</a>的时候就经历过这种折磨，当时使用的是<code>Ubuntu 22.04</code>，不仅安装费劲，也很容易出现依赖版本对不上的问题。</p><p>而在<code>Arch Linux</code>上，我只需要从<a href="https://aur.archlinux.org/">Arch Wiki的AUR搜索面板</a>找到<code>deepin-wine-wechat</code>，将生成脚本克隆到本地，输入两行命令构建、安装，就可以了。甚至，如果我安装了<a href="https://wiki.archlinuxcn.org/wiki/AUR_%E5%8A%A9%E6%89%8B">AUR助手</a>，直接输入一行命令就可以安装了，省时省力。</p><p>AUR助手我主要用<code>yay</code>，它用go语言编写而成，解析依赖的能力比较强。</p><p>也有一些图形化的工具可以搜索包，但是我个人一般直接上Wiki查找，用不到。</p><p>如何管理您的包也是很重要的一部分，详情见推荐阅读中的系统维护页面。</p><h2 id="3-显示管理器"><a href="#3-显示管理器" class="headerlink" title="3. 显示管理器"></a>3. 显示管理器</h2><p>它允许你登录到桌面环境，相当于从启动过程到桌面环境的一个桥梁。比较常见的有<code>sddm</code>、<code>lightdm</code>等等。如果嫌丑，github上有很多相关的主题可供选择。</p><h2 id="3-5-桌面环境"><a href="#3-5-桌面环境" class="headerlink" title="3.5 桌面环境"></a>3.5 桌面环境</h2><p>如果您嫌麻烦，不愿配置窗口管理器，那么可以直接下载桌面环境。所谓桌面环境，就是一堆组件包，包括窗口管理器、实用小组件、文件管理器等等，开箱即用，而且大多数桌面环境可配置能力也很强。比较出名的有：</p><ol><li><code>GNOME</code>，其也是<code>Ubuntu</code>的桌面环境。</li><li><code>KDE</code>，定制性非常强，缺点是系统占用比较多。</li><li><code>Xfce</code>，轻量化的桌面环境，就是有点丑。</li></ol><h2 id="4-窗口管理器"><a href="#4-窗口管理器" class="headerlink" title="4. 窗口管理器"></a>4. 窗口管理器</h2><p>窗口管理器和桌面环境有什么不同？<a href="https://wiki.archlinuxcn.org/wiki/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8">窗口管理器</a>提供了图形界面，它允许你操纵窗口，打开应用程序，但是不提供状态栏、文件管理器等工具。桌面环境包括窗口管理器，同时也提供了一些设置工具、状态栏、组件等等。使用窗口管理器相对来说定制性强，更加轻量化，能够自定义自己想要用的工具包，缺点是配置起来更加麻烦。</p><p>窗口管理器有三大门派，一派是<strong>层叠式窗口管理器</strong>，另一派是<strong>平铺式窗口管理器</strong>，还有一派是<strong>动态窗口管理器</strong>。</p><h3 id="层叠式窗口管理器"><a href="#层叠式窗口管理器" class="headerlink" title="层叠式窗口管理器"></a>层叠式窗口管理器</h3><p>这种窗口管理器就像Windows的窗口管理器一样，窗口之间可以重叠，比较出名的是<code>KDE</code>桌面自带的<code>KWin</code>，<code>Xfce</code>桌面自带的<code>Xfwm</code>等等。</p><h3 id="平铺式窗口管理器"><a href="#平铺式窗口管理器" class="headerlink" title="平铺式窗口管理器"></a>平铺式窗口管理器</h3><p>这种窗口管理器的窗口之间一般没有重叠，平铺在桌面上，占据着不同的空间。当你打开一个软件时，它占据整个屏幕，当您打开另一个软件时，它们会各自占据一半屏幕。</p><p>这种窗口管理模式对于键盘操作非常友好，可以通过快捷键选中、操纵窗口，比较出名的有<code>Bspwm</code>，<code>i3wm</code>等等。</p><p><code>Bspwm</code>可以结合<code>sxhkd</code>来设置快捷键，二者的配置非常简单、方便。</p><h3 id="动态窗口管理器"><a href="#动态窗口管理器" class="headerlink" title="动态窗口管理器"></a>动态窗口管理器</h3><p>它们结合不同的管理方法，可以应用层叠式的，也可以应用平铺式的，功能比较强大，比较出名的有<code>Xmonad</code>,<code> awesome</code>，<code>dwm</code>。</p><p>PS：<code>dwm</code>打补丁有些麻烦。</p><h3 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h3><p>这些窗口管理器遵循UNIX原则，通常不提供状态栏，您可以通过<code>polybar</code>进行配置。</p><p>如果想要配置背景透明度和窗口渐入渐出动画，可以使用<code>picom</code>。</p><p>快速启动应用，可以使用<code>rofi</code>。</p><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p>我比较喜欢的配色方案是<a href="https://www.nordtheme.com/docs/colors-and-palettes">nord</a>和<a href="https://ssshooter.github.io/nippon-color/">nipponcolor</a>。</p><h2 id="5-电源管理"><a href="#5-电源管理" class="headerlink" title="5.电源管理"></a>5.电源管理</h2><p>有很多用户报告说，Linux比Windows更耗电。我还没有验证过这个结论。但是用Linux日常工作，我的笔记本风扇声音更小，温度更低。内存占用、CPU占用也更少。</p><p>如果您想配置电源，可以使用<code>powertop</code>和<code>tlp</code>两个工具，我更推荐前者，后者导致我的无线网经常断连。</p><h2 id="6-浏览器"><a href="#6-浏览器" class="headerlink" title="6.浏览器"></a>6.浏览器</h2><p>我使用<code>Firefox</code>和<code>ungoogled-chromium</code>。其中，对于Firefox，我应用了<a href="https://github.com/arkenfox/user.js/">arkenfox&#x2F;user.js</a>，对隐私保护进行了优化，如果嫌麻烦，可以直接使用<code>LibreWolf</code>。此外，可以使用<code>Vimium</code>插件将Vim键位应用到网页浏览上。</p><p>您可以通过<a href="https://www.deviceinfo.me/">此网站</a>测试您浏览器的隐私程度。</p><h2 id="7-安全"><a href="#7-安全" class="headerlink" title="7.安全"></a>7.安全</h2><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>您需要它。的确，Linux下的恶意软件更少，但是仍然面临着被黑入的风险。</p><p><code>firewalld</code>和<code>ufw</code>都是不错的选择，它们分别使用<code>nftables</code>和<code>iptables</code>作为后端。我日常使用后者，<code>gufw</code>包提供了一个图形界面来配置<code>ufw</code>的规则、端口等等。</p><h3 id="密码管理器"><a href="#密码管理器" class="headerlink" title="密码管理器"></a>密码管理器</h3><p>您可能将大部分密码保存在浏览器里，但是我不推荐这种方法，因为浏览器并不是为管理密码设计的。我更推荐用专用的密码管理器。</p><p>现在的密码管理器大概分为两种，一种将密码库放在云端，另一种将密码库存储在本地。前者比较方便，可以多设备同步，但是面临着数据泄露的风险，比如<a href="https://www.wired.com/story/lastpass-breach-vaults-password-managers/">LastPass密码库泄露事件</a>。所以我更推荐使用后者，只要你能够妥善保管，就很安全，我日常使用的是<code>KeePassXC</code>。</p><p>这里也推荐一个方法，在设置密钥时，可以在设置密码的同时设置密钥文件，这样基本上没有暴力破解的可能性。</p><h3 id="加密卷"><a href="#加密卷" class="headerlink" title="加密卷"></a>加密卷</h3><p>如果您有些敏感信息要存放，可以使用<code>Veracrypt</code>，它不仅可以创建加密卷，也可以加密U盘、硬盘等，是很强大的工具。</p><p>同样，采用密钥文件+密码的模式，会很安全。</p><h3 id="快照-x2F-备份"><a href="#快照-x2F-备份" class="headerlink" title="快照&#x2F;备份"></a>快照&#x2F;备份</h3><p>滚动更新面临着系统崩溃的风险，而Arch Linux的更新策略尤为激进。所以您需要定期备份，好在系统崩溃时回滚，相关工具有<code>timeshift</code>等等。</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>妥善管理好文件的权限！</p><p>此外，用<code>sudo</code>代替<code> su root</code>。</p><p>看到过许多Linux用户，常年用<code>root</code>用户操作……为他们捏把汗。</p><p>不过也有些单用户的发行版，就不太需要考虑权限的事情，比如说<code>Haiku</code>。</p><h3 id="三思而后行"><a href="#三思而后行" class="headerlink" title="三思而后行"></a>三思而后行</h3><p>在执行命令前，看清楚语法是否正确。举个例子，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./ ss</span><br></pre></td></tr></table></figure><p>这个命令会删除你所在文件夹的所有内容，如果只想删除ss,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./ss</span><br></pre></td></tr></table></figure><p>我就曾经多打了一个空格，导致删除了我所有的配置文件和重要文档。</p><h2 id="8-游戏"><a href="#8-游戏" class="headerlink" title="8.游戏"></a>8.游戏</h2><p>我没有找到一个完美的方案。</p><p>如果游戏支持Linux,直接运行即可。</p><p>对于Windows独占的游戏，Steam上的游戏可以使用Steam自带的Proton运行，Proton集成了wine等有用的工具，对于steam游戏也做了相应的优化，体验还算不错，但是在游戏过程中，游戏内存占用会不断增长，最终导致系统卡死。</p><p>我也听说过使用<code>DXVK</code>、<code>lutris</code>和<code>play on linux</code>的方案，不知道体验如何。</p><h2 id="9-编辑器"><a href="#9-编辑器" class="headerlink" title="9.编辑器"></a>9.编辑器</h2><p>如果您习惯了键盘操作，那么您也许会发现，工作效率也会有显著的提高。此外，流畅的键盘操作更容易进行流畅的编码，免去切换鼠标带来的思路卡顿。</p><p>以键盘操作为主的编辑器，无非是Emacs和Vim，一直以来始终有一个争论：Emacs还是Vim？</p><p>这个问题和“哪个发行版最好”一样毫无意义，不过是茶余饭后闲聊的谈资而已。</p><p>Emacs功能强大，可以作为邮件客户端、笔记软件、音乐软件、图片查看器等，被称为“神之编辑器”。</p><p>Vim&#x2F;Neovim键位更友好，大大提升编码效率，被称为“编辑器之神”。</p><p>对于Emacs,有很多开箱即用的用户预配置版本：<code>doomemacs</code>、<code>spacemacs</code>。</p><p>对于Vim,则有：<code>Lunarvim</code>等。</p><p>此外，我也经常使用<code>IDEA</code>等编辑器。工具嘛，哪个好用用哪个。</p><h2 id="10-输入法"><a href="#10-输入法" class="headerlink" title="10.输入法"></a>10.输入法</h2><p>输入法参考维基，安装fcitx5就好，不过我想在这里写下一个问题的解决方法。</p><h3 id="fcitx5无法输入中文中括号的解决方案"><a href="#fcitx5无法输入中文中括号的解决方案" class="headerlink" title="fcitx5无法输入中文中括号的解决方案"></a>fcitx5无法输入中文中括号的解决方案</h3><p>在<code>/usr/share/fcitx5/punctuation/punc.mb.zh_CN</code>这个文件中，</p><p>将[，]两行改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 【</span><br><span class="line">] 】</span><br></pre></td></tr></table></figure><p>如果您想打出中文的人名分隔符的话：</p><p>在文件末尾添加：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` ·</span><br></pre></td></tr></table></figure><p>即可。</p><h2 id="11-个性化配置"><a href="#11-个性化配置" class="headerlink" title="11.个性化配置"></a>11.个性化配置</h2><h3 id="键位绑定"><a href="#键位绑定" class="headerlink" title="键位绑定"></a>键位绑定</h3><p>可以使用<code>xmodmap</code>工具，比如，您可以用它将Caps Lock键和Ctrl键映射互换。</p><h3 id="外设配置-x2F-灯效配置"><a href="#外设配置-x2F-灯效配置" class="headerlink" title="外设配置&#x2F;灯效配置"></a>外设配置&#x2F;灯效配置</h3><p>如果您要配置鼠标的额外按键功能、RGB灯效的话，可以使用<code>piper</code>，但有可能出现无法绑定键位的错误。</p><p>灯效可以通过<code>openrgb</code>进行配置。</p><h3 id="终端模拟器-x2F-Shell"><a href="#终端模拟器-x2F-Shell" class="headerlink" title="终端模拟器&#x2F;Shell"></a>终端模拟器&#x2F;Shell</h3><p>对于终端模拟器，<code>Alacritty</code>是个不错的选择，支持跨平台操作，也支持一定程度的自配置。</p><p>Shell则纯看个人喜好，我使用<code>zsh</code>，搭配<code>oh-my-zsh</code>的示例配置文件。</p><h3 id="系统监测"><a href="#系统监测" class="headerlink" title="系统监测"></a>系统监测</h3><p><code>htop</code>可以查看进程。</p><p><code>neofetch</code>可以查看系统信息。</p><h3 id="dotfiles"><a href="#dotfiles" class="headerlink" title="dotfiles"></a>dotfiles</h3><p>所谓dotfiles，就是您的自定义配置文件，因为大多配置文件都以<code>.</code>开头，或者储存在<code>.config</code>文件夹内，您可以通过git或者其他管理工具管理它们，上传到github，这样在配置新系统时会很方便。</p><h2 id="Ex-注意事项"><a href="#Ex-注意事项" class="headerlink" title="Ex.注意事项"></a>Ex.注意事项</h2><h3 id="Emacs的使用"><a href="#Emacs的使用" class="headerlink" title="Emacs的使用"></a>Emacs的使用</h3><p>将Emacs设置为守护进程将节省启动的时间。开机时启动守护进程，Emacs就将始终在后台运行，每次打开Emacs(Client)即可，免去加载时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/emacs --daemon &amp;</span><br></pre></td></tr></table></figure><h3 id="NVIDIA驱动"><a href="#NVIDIA驱动" class="headerlink" title="NVIDIA驱动"></a>NVIDIA驱动</h3><p>不要从NVIDIA官网安装！参见<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA">Arch Wiki：NVIDIA</a>。</p><h3 id="信息源"><a href="#信息源" class="headerlink" title="信息源"></a>信息源</h3><p><code>Arch Wiki</code>中包含大多数常用包的说明、设置方法、疑难解答。</p><p><code>Arch Forum</code>中包含很多用户遇到的问题和解决方案。</p><p><code>Github</code>上有许多包的源码，可以在issue中查看一些问题的解决方法。</p><h3 id="Haskell配置"><a href="#Haskell配置" class="headerlink" title="Haskell配置"></a>Haskell配置</h3><p>不要使用Arch Linux提供的<code>ghc</code>，<code>ghci</code>，正确的方法是只安装官方库的<code>ghcup</code>，通过<code>ghcup</code>安装相关的包。</p><h3 id="发行版彼此不同"><a href="#发行版彼此不同" class="headerlink" title="发行版彼此不同"></a>发行版彼此不同</h3><p><code>Manjaro</code>、<code>Arco Linux</code>、<code>Artix Linux</code>不是<code>Arch Linux</code>，它们是<strong>基于</strong><code>Arch Linux</code>的发行版。</p><p><code>Ubuntu</code>不是<code>Debian</code>,它是<strong>基于</strong><code>Debian</code>的发行版。</p><p>也就是说，举个例子，在<code>Manjaro</code>发行版上遇到的问题，尽量去<code>Manjaro</code>专门的论坛，而不是去<code>Arch Linux</code>的论坛寻求解答；在<code>Debian</code>上遇到的问题就尽量去<code>Debian</code>论坛寻求解答。</p><h3 id="软件替代品"><a href="#软件替代品" class="headerlink" title="软件替代品"></a>软件替代品</h3><p>您可以去<a href="https://alternativeto.net/">alternativeto.net</a>查询Windows下软件在Linux系统上的替代品。</p><h3 id="一寸光阴一寸金"><a href="#一寸光阴一寸金" class="headerlink" title="一寸光阴一寸金"></a>一寸光阴一寸金</h3><p>不要花费太多时间在切换、尝试不同的Linux发行版上，也不要花费太多时间在配置桌面环境、选择软件上。能用就行。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4">Arch Wiki：系统维护</a></p><p><a href="https://zhuanlan.zhihu.com/p/163805070">fcitx5中文输入法方括号问题的解决</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业余安全漫谈（一）：威胁模型和原则</title>
      <link href="/2023/02/10/Security/"/>
      <url>/2023/02/10/Security/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本系列旨在分享一些不错的有关隐私保护、计算机安全的知识和做法，大多为道听途说。</p><p>请勿根据相应的方法攻击、监视他人。</p><h2 id="0-威胁模型"><a href="#0-威胁模型" class="headerlink" title="0.威胁模型"></a>0.威胁模型</h2><p>隐私性、安全性和易用性、简便性往往是成反比例关系的。一个系统越安全，往往配置越麻烦，限制比较多，使用起来也越麻烦。所以首要的问题是，如何平衡好这两者的关系。</p><p>首先我们要搞清楚几个问题：</p><ul><li>我要保护什么？</li><li>我的“敌人”是谁？（有种偏执狂的感觉）</li><li>我愿意花多少时间、金钱去保护这些东西？</li></ul><p>本系列针对计算机的日常使用者，所以对于这三个问题的答案是：</p><ul><li>隐私、基本的安全（保证本地信息不被窃取）。</li><li>广告商、黑客、（）。</li><li>追求零金钱花费和最低的精力消耗，同时最大程度保证日常使用的简便性。</li></ul><p>此外，对于所有的措施，要保证：</p><ul><li>简单。方便维护您的安全系统，节省精力。</li><li>强大。要起到相应的保护作用。</li></ul><p>对于您的心态来说，要：</p><ul><li>谦虚。没有百分百安全的系统，要不断更新。</li><li>多疑。仔细考虑措施的严谨性，并且考虑适不适合自己。</li><li>层次化。对于不同的操作，可以设置不同的保护力度。</li></ul><p>您会觉得这些方法很麻烦、很复杂，不过事实就是如此，如今的追踪、检测技术十分之发达，您必须有一定的力量才能够与之抗衡。</p><h2 id="1-软件选择原则"><a href="#1-软件选择原则" class="headerlink" title="1.软件选择原则"></a>1.软件选择原则</h2><h3 id="开源-gt-专有（闭源）"><a href="#开源-gt-专有（闭源）" class="headerlink" title="开源&gt;专有（闭源）"></a>开源&gt;专有（闭源）</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件</a>开放源代码，少有“后门”，也可以借助开源社区的力量，不断被完善。安全性能够得到很好的保障。</p><p>而<a href="https://zh.wikipedia.org/wiki/%E4%B8%93%E6%9C%89%E8%BD%AF%E4%BB%B6">专有软件</a>则通常不允许用户浏览源代码，无法保证不存在“后门”，通常更新也比较缓慢。</p><p>举个例子，可以使用开源的<code>Linux</code>替代<code>Windows</code>，可以使用<code>Firefox</code>代替<code>Google Chrome</code>。</p><h3 id="矮子里面拔高个"><a href="#矮子里面拔高个" class="headerlink" title="矮子里面拔高个"></a>矮子里面拔高个</h3><p>如果您只有专有软件可以选择，那么遵循下面几个规则：</p><ul><li>国外&gt;国内。对于国内的软件，由于某些原因，存在“后门”、监视程序的可能性很高。</li><li>非营利性组织&gt;商业机构。商业机构往往会贩卖您的隐私。</li></ul><h3 id="单一-gt-多样化"><a href="#单一-gt-多样化" class="headerlink" title="单一&gt;多样化"></a>单一&gt;多样化</h3><p>一个软件应该实现一种功能。比如一个下载器，就应该只提供下载的功能；一个文本查看器，就要只提供文本查看的功能，而不是将各种功能集成到一起。这样做的好处是，避免由于一个软件的漏洞，导致各种类型信息的泄露。</p><p>这避免了单点故障，什么是“单点故障”，文末附有解释。</p><h3 id="不联网-gt-去中心化-gt-中心化"><a href="#不联网-gt-去中心化-gt-中心化" class="headerlink" title="不联网&gt;去中心化&gt;中心化"></a>不联网&gt;去中心化&gt;中心化</h3><p>离线实现功能，是最好的。如果不行，尽量连接到去中心化的网络。</p><p>比如说，不用音乐播放器，而采用下载mp3到本地，用本地播放器播放的策略；不用传统方式浏览网页，而用<code>Tor</code>浏览网页。</p><p>何为去中心化网络？通俗来讲就是不依靠一个中央服务器起作用的网络。比如<code>Tor</code>、<code>I2P</code>、<code>Freenet</code>等等。黑客很难通过这些网络追踪到你的IP地址，查询到你的信息。</p><p>当然，在国内采用<code>Tor</code>、<code>I2P</code>等工具浏览网页，速度会很慢，配置也很麻烦。</p><h2 id="2-系统使用原则"><a href="#2-系统使用原则" class="headerlink" title="2.系统使用原则"></a>2.系统使用原则</h2><h3 id="极简主义"><a href="#极简主义" class="headerlink" title="极简主义"></a>极简主义</h3><p>繁多的软件、脚本会让您难以管控到系统的方方面面。它们会让你的系统看起来像一个堆满杂物的房间，而后者打扫起来必然是费时费力的。</p><p>如果您不常使用某些软件，那就卸载它们，与此同时还能为您腾出一些存储空间。</p><h3 id="保守的激进主义"><a href="#保守的激进主义" class="headerlink" title="保守的激进主义"></a>保守的激进主义</h3><p>如果可以，请时刻保证系统最新，因为新系统一般能够修复旧系统中存在的bug、漏洞，让黑客难以利用它们。</p><p>但是与此同时，如果一个软件提供<code>LTS</code>(long-term support，长期支持)版本，那么就安装最新的<code>LTS</code>版本，因为这样的版本一般兼顾安全性和稳定性，它们是在经过严格测试后发布的。那些短期支持的版本通常是为了测试一些新提交的功能，会存在一些不可知的bug、漏洞等。</p><h2 id="Ex-杂项"><a href="#Ex-杂项" class="headerlink" title="Ex.杂项"></a>Ex.杂项</h2><h3 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h3><p>详见<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C">维基百科</a>。</p><p>通俗来讲，就是一个系统过度依赖某一节点，当该节点出现故障时，整个系统都很难工作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 业余安全漫谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业余安全漫谈（二）：网络连接的安全性</title>
      <link href="/2023/02/10/Security02/"/>
      <url>/2023/02/10/Security02/</url>
      
        <content type="html"><![CDATA[<h2 id="0-日常浏览器推荐"><a href="#0-日常浏览器推荐" class="headerlink" title="0.日常浏览器推荐"></a>0.日常浏览器推荐</h2><p>常见浏览器大概有：<code>Firefox</code>，<code>chromium</code>，<code>google chrome</code>。</p><p>根据第一章谈到的原则，它们选择的优先顺序应该为：<code>Firefox</code>(开源，而且由非盈利性的<code>Mozilla基金会</code>开发)、<code>chromium</code>(开源，但是由盈利性的谷歌公司开发，内置一些谷歌的相关功能)、<code>google chrome</code>（闭源，谷歌开发）。</p><h2 id="0-5-分身-amp-习惯"><a href="#0-5-分身-amp-习惯" class="headerlink" title="0.5.分身&amp;习惯"></a>0.5.分身&amp;习惯</h2><p>如果您需要进行一些<strong>敏感操作</strong>的话，您不妨使用两个浏览器，对安全性有要求的可以使用<code>Firefox</code>，它不仅相对安全，还允许您添加一些重要的插件。日常相关使用<code>chromium</code>就好。<code>chromium</code>的隐私配置选项较少，且效果不尽如人意。</p><p>另外，如果可以，尽量不要登陆网站，可以进行访客式的浏览。商业公司很容易通过账号追踪、分析您。</p><p>至于习惯方面的安全，我会在之后单独写一篇文章讨论。</p><p>本文主要讲述如何强化火狐的隐私设定。如果您对浏览器如何追踪您的隐私感兴趣，文末附有几种跟踪方式的维基百科链接，供您查看。</p><h2 id="1-Firefox基本配置"><a href="#1-Firefox基本配置" class="headerlink" title="1. Firefox基本配置"></a>1. Firefox基本配置</h2><p>推荐您仔细看一看<code>首选项</code>中的设置。我使用的是英文火狐（<code>Arch Linux</code>版本,109.0 64位），您可以通过大意找到对应的设置。</p><p>至于一些日常的小配置，参考<a href="https://coder109.github.io/2022/11/01/FirefoxNote/">我之前的博文</a>。</p><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>在<code>Browsing</code>栏中，将推荐扩展、推荐功能关掉。</p><h3 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h3><p>在<code>Firefox Home Content</code>中，将<code>Snippets</code>关掉，其它看心情。</p><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p><code>Provide search suggestions</code>-关闭</p><p>建议您切换搜索引擎为<code>Duckduckgo</code>，<code>SearX</code>等。</p><h3 id="Privacy-amp-Security"><a href="#Privacy-amp-Security" class="headerlink" title="Privacy &amp; Security"></a>Privacy &amp; Security</h3><p><code>Enhanced Tracking Protection</code>-<code>Strict</code></p><p><code>Address Bar</code>下，关闭全部推荐相关的选项。记得我们的<strong>不联网优先</strong>原则吗？</p><p><code>Do Not Track</code>-<code>Always</code></p><p><code>Cookies and Site Data</code>-<code>Delete cookies and site data when Firefox is closed</code>，当然，这会导致关闭浏览器后，失去所有的登陆状态。</p><p><code>Ask to save logins and passwords for websites</code>-可设置为关闭，密码管理推荐使用密码管理器。</p><p><code>History</code>-<code>Never remember history</code></p><p><code>Firefox Data Collection and Use</code>-全部关闭，不向火狐基金会发送消息。</p><p><code>Deceptive Content and Dangerous Software Protection</code>-全开。</p><p><code>HTTPS-Only Mode</code>-<code>HTTPS-Only Mode in all windows</code>，这会导致访问一些<code>http</code>网站时出现警告窗口，但是您仍然可以轻易的关闭它们并访问网站。<code>https</code>网站远比<code>http</code>安全。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>小心选择扩展！</p><p><code>uBlock Origin</code>，开源插件，其功能极其强大，安装它可以免去安装<code>Ghostery</code>，<code>隐私獾</code>等插件。</p><p>配置好的<code>Firefox</code>+<code>uBlock Origin</code>一般就够用了。</p><h2 id="2-Firefox进阶配置"><a href="#2-Firefox进阶配置" class="headerlink" title="2. Firefox进阶配置"></a>2. Firefox进阶配置</h2><p>这里适合有一些编程基础的小伙伴尝试。如果您没有编程基础，还想强化隐私保护的话，可以使用<code>LibreWolf</code>浏览器。</p><p><code>Arkenfox</code>的<code>user.js</code>，仓库见文末。其<code>wiki</code>写得很详细了，能全方位强化<code>Firefox</code>的隐私安全。</p><p>值得一提的是，我将它的<code>RFP</code>保护关闭了，不关闭的话，浏览器最大化时，网页内容无法填满整个浏览器。</p><p>此外，其会让一些国内网站，比如<code>CSDN</code>无法登陆，也会让b站视频没办法播放。</p><p>所以，我平时也使用<code>chromium</code>。</p><h2 id="3-VPN"><a href="#3-VPN" class="headerlink" title="3. VPN"></a>3. VPN</h2><p>VPN允许您透过加密隧道连接到互联网。它不仅仅是为了反封锁而生的，还可以隐藏您的行踪，让ISP（网络服务提供商）难以追踪到您正在干什么。</p><p>通俗来讲，通常的上网方式是通过ISP连接到互联网，而使用VPN则相当于先连接到VPN服务商，再连接到ISP,再连接到互联网。</p><p>不难看出，您一定要保证VPN服务提供商不会将您的行踪外泄，否则还不如不使用VPN。</p><p>当您在选择VPN的时候，要注意几点：</p><ol><li>天下没有免费的午餐。大多数只提供免费服务的VPN都十分可疑。维护服务器的成本不低，这些VPN服务提供商很可能受到政府资助或者通过贩卖用户隐私盈利。</li><li>小心使得万年船。仔细阅读VPN提供的用户政策，查看它们是否记录个人信息，个人信息保存多久，采用什么协议加密通信隧道。小心那些来历不明、没有官网的VPN,它们很可能是不安全的。</li><li>追求稳定。不稳定的VPN会经常出现断连、切换节点的情况，连接断开时无法保证连接的加密性、安全性。</li></ol><p>您可以通过测试IP地址查看您是否成功连接到VPN服务商。</p><h2 id="4-Tor"><a href="#4-Tor" class="headerlink" title="4. Tor"></a>4. Tor</h2><p>详见<a href="https://zh.wikipedia.org/wiki/Tor">维基百科</a>。简单来说，它通过三级代理连接到目标网站。由于代理节点很多，很难追踪到您具体连接了哪个节点。此外，每一级代理也不知道是谁将信息传输给它，这更增加了追踪的困难性。同时，通过它访问互联网，非常非常慢。</p><p>您可以通过Tor+可信VPN的方式进行连接。当Tor失效时，您还有一层保障。</p><p>Tor是一种去中心化的网络连接方式。类似的网络有<code>I2P</code>、<code>Freenet</code>、<code>GNUnet</code>、<code>LokiNet</code>等等。通过这些方式连接互联网都很慢，不推荐日常使用。</p><h2 id="5-“万物联网”？No！"><a href="#5-“万物联网”？No！" class="headerlink" title="5.“万物联网”？No！"></a>5.“万物联网”？No！</h2><p>我一直以来都不信任那些“智能家居”，他们和监视器没什么差别。前一阵子爆出来的<a href="https://www.technologyreview.com/2022/12/19/1065306/roomba-irobot-robot-vacuums-artificial-intelligence-training-data-privacy/">扫地机器人会拍照，内容还会泄露</a>的新闻就是很好的实例。也有一部分新闻附于文末。</p><p>所有东西都在智能化——然而您没办法保证这些“智能物品”的安全性，它们搭载着摄像头、麦克风，一旦被攻破，您的隐私将暴露无遗。当然，大部分智能设备的功能压根没必要，我实在搞不懂为什么水杯上还要放一个温度监视器。</p><p>记得我们之前的原则吗？<strong>离线优先！</strong></p><p>此外，这些“智能家居”的背后都是商业公司——您或许永不该信任他们。</p><h2 id="Ex-杂项"><a href="#Ex-杂项" class="headerlink" title="Ex.杂项"></a>Ex.杂项</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>详见<a href="https://zh.wikipedia.org/wiki/Cookie">维基百科</a>。</p><blockquote><p><strong>HTTP cookie</strong>，简称<strong>cookie</strong>，是用户浏览网站时由网络服务器建立并由用户的网页浏览器储存在计算机或其他设备的小文本文件。</p><p>Cookie使Web服务器能够在用户的设备储存状态信息（如加到在线商店购物车中的商品）或跟踪用户的浏览活动（如点击特定按钮、登录或记录历史）。</p></blockquote><h3 id="HTTP-Etag"><a href="#HTTP-Etag" class="headerlink" title="HTTP Etag"></a>HTTP Etag</h3><p>详见<a href="https://zh.wikipedia.org/wiki/HTTP_ETag">维基百科</a>。</p><p>您可以将它理解为一个不是cookie的持久cookie。摆脱Etag,可以清除浏览器缓存。</p><h3 id="数字指纹"><a href="#数字指纹" class="headerlink" title="数字指纹"></a>数字指纹</h3><p>网站也可以通过JavaScript和Canvas(详见<a href="https://en.wikipedia.org/wiki/Canvas_fingerprinting">维基百科</a>)追踪到您。</p><p>对于前者，您可以选择禁用JavaScript,不过这会导致大多数网站没办法正常运作。</p><p>对于后者，上面提到的<code>user.js</code>可以很好保护您的<code>Firefox</code>免受Canvas追踪。</p><h3 id="防呆不防傻"><a href="#防呆不防傻" class="headerlink" title="防呆不防傻"></a>防呆不防傻</h3><p>内存条上有个豁口，将金手指分为长短不一的两半，方便插到主板的内存插槽上。插反了插不进去。然而总有人会在插反的时候，认为这是做工问题，用尽力气把内存怼进去，造成主板损坏。</p><p>这些网络连接工具就像是这个豁口，您怎么使用这些工具更加重要。故意作死，暴露隐私，那么再好的工具也无济于事。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://www.nbcnews.com/tech/security/hacked-home-devices-can-spy-you-n814671">Hacked Home Devices Can Spy On You</a></p><p><a href="https://motherboard.vice.com/en_us/article/ae3y8e/yes-your-smart-dildo-can-be-hacked">Yes, Your Smart Dildo Can Be Hacked</a></p><p><a href="https://www.youtube.com/watch?v=F7-bW2y6lcI">The Ultimate Guide to Firefox Hardening in 2022</a></p><p><a href="https://www.kaspersky.com/resource-center/definitions/what-is-a-digital-footprint">What is a digital footprint</a></p><p><a href="https://github.com/arkenfox/user.js">arkenfox-user.js的github页面</a></p><p><a href="https://www.deviceinfo.me/">浏览器隐私测试</a></p><p><a href="https://www.dnsleaktest.com/">DNS Leak Test</a></p><p><a href="https://www.whatismyip.com/">What is my ip</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 业余安全漫谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业余安全漫谈（三）：密码、存储、信息传输安全</title>
      <link href="/2023/02/10/Security03/"/>
      <url>/2023/02/10/Security03/</url>
      
        <content type="html"><![CDATA[<h2 id="0-好钢用在刀刃上"><a href="#0-好钢用在刀刃上" class="headerlink" title="0.好钢用在刀刃上"></a>0.好钢用在刀刃上</h2><p>我们不妨把使用密码的情况分为三种：</p><ol><li>低强度需求。这种情况对应着：哪怕密码被盗了，也不会造成什么损失。比如：不常逛的论坛登陆密码、不常用的APP的登陆密码。</li><li>中等强度需求。比如：常用的视频网站、论坛的密码，个人电脑的密码，手机密码。</li><li>高强度需求。比如：敏感文件的访问密码。</li></ol><p>对于不同的情况，可以选择不同的密码强度。对于第一种，我们把密码设为111、123之类都没有问题，因为就算黑客破解了这些密码，也获得不到什么东西；对于第二种，我们可以把密码设为相对复杂一点，同时又比较好记忆的密码，比如MyNameIsNick23723之类；对于第三种，我们可以用一些随机算法生成密码，比如A6YW0:7lRpdKdJ^k2O(o}R+7之类，同时用特定的软件、工具来管理。</p><p>同时密码的复杂度也与您使用密码的次数有关，经常使用的密码可以设置的好记一些。</p><h2 id="1-强密码"><a href="#1-强密码" class="headerlink" title="1.强密码"></a>1.强密码</h2><p>强密码要有以下几个特点：</p><ul><li><p>长度尽可能长</p></li><li><p>不包含用户名</p></li><li><p>同时有大小写字母、数字、特殊符号等</p></li></ul><p>比如，下面这些是弱密码：</p><ul><li>123</li><li>abcdef</li><li>当用户名是Nick的时候，密码为Nick111</li></ul><p>与之相反，这些是强密码：</p><ul><li>ThisIsAPassword1212&#x3D;</li><li>MyNameIsNick23723</li></ul><p>怎么想出来一些好用的强密码呢？</p><h3 id="观察周遭事物"><a href="#观察周遭事物" class="headerlink" title="观察周遭事物"></a>观察周遭事物</h3><p>步骤：</p><ol><li>挑选周围出现的几个事物。</li><li>将它们用文本表示出来。</li><li>加上数字。</li></ol><p>举个例子：</p><p>我周围有开关、书、电脑，那么我就把密码暂时设置为“SwitchBookComputer”，加上点数字：“SwitchBookComputer2023”。这样我们就有一个强密码了。也很好记忆。</p><h2 id="2-密码管理器"><a href="#2-密码管理器" class="headerlink" title="2.密码管理器"></a>2.密码管理器</h2><p>密码管理器可以用来管理、生成密码。</p><blockquote><p>我不推荐用浏览器保存密码，因为浏览器并不是为管理密码设计的。我更推荐用专用的密码管理器。</p><p>现在的密码管理器大概分为两种，一种将密码库放在云端，另一种将密码库存储在本地。前者比较方便，可以多设备同步，但是面临着数据泄露的风险，比如<a href="https://www.wired.com/story/lastpass-breach-vaults-password-managers/">LastPass密码库泄露事件</a>。所以我更推荐使用后者，只要你能够妥善保管，就很安全，我日常使用的是<code>KeePassXC</code>。</p><p>这里也推荐一个方法，在设置密钥时，可以在设置密码的同时设置密钥文件，这样基本上没有暴力破解的可能性。</p><p>——我的另一篇博文：《Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择》</p></blockquote><p>最好的密码管理器是什么？纸、笔和保险箱。</p><h2 id="3-加密卷"><a href="#3-加密卷" class="headerlink" title="3.加密卷"></a>3.加密卷</h2><blockquote><p>如果您有些敏感信息要存放，可以使用<code>Veracrypt</code>，它不仅可以创建加密卷，也可以加密U盘、硬盘等，是很强大的工具。</p><p>同样，采用密钥文件+密码的模式，会很安全。</p><p>——我的另一篇博文：《Linux苦痛之路（三）：漫谈+Arch Linux软件配置选择》</p></blockquote><h2 id="4-加密服务"><a href="#4-加密服务" class="headerlink" title="4.加密服务"></a>4.加密服务</h2><p>尽量选择安全的、私密的服务。如果您有相关的知识储备，可以试着了解服务背后的原理。</p><p>比如电子邮件可以选择<code>protonmail</code>、<code>tutanota</code>等等。</p><h2 id="5-隐藏起来的重要信息"><a href="#5-隐藏起来的重要信息" class="headerlink" title="5.隐藏起来的重要信息"></a>5.隐藏起来的重要信息</h2><p>当传输图片、文本时，尽量保证图片、文本里包含最少的信息。简单！我们把那些能够暴露我身份、地点的信息都删除、用马赛克遮盖起来就好啦！</p><p>这够吗？</p><p>我们以图片为例子。</p><p>图片不仅仅包含一个个像素点，它还包括一些<strong>元数据</strong>，像下面这些：</p><p><img src="/./Screenshot_20230123_105822.png"></p><p>如您所见，它包括图片的一些基本参数，有的元数据还包括您拍摄照片的位置。当您把图片发在社交网站上的时候，如果这些网站不对元数据进行擦除的话，别人可以通过一些工具查看到这些元数据，进而对您的活动进行分析。这些元数据是人肉搜索的利器。</p><p>您可以通过<a href="https://29a.ch/photo-forensics/#forensic-magnifier">此网站</a>或者<code>exiftool</code>工具查看图片的元数据。</p><p>至于擦除它们，您可以使用<code>exiftool</code>删除元数据，如果是<code>Windows</code>系统，或许可以通过右击图片-属性-删除一些元数据的方式进行擦除。</p><p>这告诉我们什么道理？有些信息是隐藏起来的，而这些信息也很重要。</p><p>同理，<code>PDF</code>文件也具有这些元数据，您可以通过<code>exiftool</code>这个小巧强大的工具查看、擦除、修改元数据。</p><p>此外，您的口头禅、聊天方式等都可以成为您独一无二的身份标识，用来识别、追踪您的身份。这些信息会在你不经意间流露，更加难以防范。</p><h2 id="6-加密通信"><a href="#6-加密通信" class="headerlink" title="6.加密通信"></a>6.加密通信</h2><p>这里只谈论几种比较常用的加密通信方式。</p><h3 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h3><p>您一定在影视作品中见过这样的场景：一个古代囚犯，将重要的信息用透明墨水写在白纸上，一般人根本看不出纸上写着字。接应的人收到这封信后，做了些处理，信息就显示出来了。这就是隐写术的一种。</p><p>对于处于现代社会的我们，可以将文件隐藏在图片中去，比如利用强大的<code>outguess</code>、<code>Steghide</code>工具。隐写前后，用肉眼观察图片看不出什么差别来。</p><p>您也可以利用<code>MP3Stego</code>等工具将文件隐藏在音频中。</p><h3 id="端对端加密软件"><a href="#端对端加密软件" class="headerlink" title="端对端加密软件"></a>端对端加密软件</h3><p>它们的作用，相当于在两个人之间设立了一条私有的、加密的、安全的通信隧道，信息在发送方加密，通过加密隧道传输到接收方，接收方解密，阅读。其它人没有办法截取谈论的信息，哪怕截取到了这些信息，也只能对着加密过的信息干着急，没办法解密。由于某些原因，不作推荐。</p><h3 id="直接加密"><a href="#直接加密" class="headerlink" title="直接加密"></a>直接加密</h3><p>您可以在本地直接加密文件，然后通过任意的信道传输。您只要私下告诉接收方密码就可以了。常见加密方式有传输加密卷等等。</p><h2 id="Ex-最薄弱的环节不是工具，是您"><a href="#Ex-最薄弱的环节不是工具，是您" class="headerlink" title="Ex.最薄弱的环节不是工具，是您"></a>Ex.最薄弱的环节不是工具，是您</h2><p>在拥有这些工具的同时，也要注意，如果您不知道如何正确使用这些工具，不知道如何养成良好的安全保护习惯，那么这些工具形同虚设，甚至会由于您的错误使用，起到相反的作用。</p><p>危险不仅仅来自于线上。很多攻击方式往往来自于线下，比如<a href="https://en.wikipedia.org/wiki/Evil_maid_attack">邪恶女仆攻击</a>。</p><p>希望您遵守下面几条原则：</p><ol><li>不要将电脑外借，不要告诉别人您的密码。在这些事情上，没有人值得信任——包括那些您最亲近的人。如果他们非要使用您的电脑、网络服务的话，建议您新建一个电脑用户、网络账户。</li><li>不用电脑、网络服务时，将之锁定、注销或者关闭。</li><li>将我们提到的理论、原则真正的付诸实践。</li><li>一个密码不要同时用在许多服务上。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 业余安全漫谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业余安全漫谈（四）：习惯的安全</title>
      <link href="/2023/02/10/Security04/"/>
      <url>/2023/02/10/Security04/</url>
      
        <content type="html"><![CDATA[<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>下面提到的几点，您通常不需要太过注意。</p><p>大概率不会有人对您如此感兴趣，非要知道你是谁，在做什么工作，住在哪里。</p><p>有统一的防范方式：那就是<strong>减少固定的行为，降低对他人的信任</strong>。如果您感兴趣，可以进一步了解社交工程学的相关知识。</p><h2 id="1-上线时间"><a href="#1-上线时间" class="headerlink" title="1.上线时间"></a>1.上线时间</h2><p>如果一个人在一年中的暑假、寒假时经常上线，而平时却不怎么出现，那么他基本上是一个学生或者老师。</p><p>您也可以根据一个人的上线时间判断出其所在的时区。</p><p>您可以通过减少上线时间、更改定期上线时间、不规律上线的方式进行防范。</p><h2 id="2-口头禅"><a href="#2-口头禅" class="headerlink" title="2.口头禅"></a>2.口头禅</h2><p>您可以通过方言猜测出一个人可能的所处位置，甚至可以用一些地区性的信息进一步缩小该人的所在地范围。</p><h2 id="3-跨平台账号名称"><a href="#3-跨平台账号名称" class="headerlink" title="3.跨平台账号名称"></a>3.跨平台账号名称</h2><p>您不可避免的要在很多平台注册账号，那么请不要使用相同的用户名。因为别有心机者会通过跨平台的搜索、联想，分析了解您的喜好和相关个人信息。如果可以，可以构建出几个不同的虚假的身份，用作不同的平台。</p><p>此外，注销您不常使用的平台账号。如果您使用密码管理器，查看您曾经注册过什么平台的账号将易如反掌。</p><h2 id="4-信息最少化原则"><a href="#4-信息最少化原则" class="headerlink" title="4.信息最少化原则"></a>4.信息最少化原则</h2><p>尽量不要填写各个平台的“个人资料”页面，也许您想通过它彰显自己的不同，但是，这对保护您的隐私没有作用。</p><p>此外，尽可能少地在社交媒体上发消息，也要将您的手机号、电子邮件地址等设为不可见。</p><p>如果您构思过虚假的身份，可以将虚假的身份信息填写在上面，蛮有趣的。</p><h2 id="5-身份隔离"><a href="#5-身份隔离" class="headerlink" title="5.身份隔离"></a>5.身份隔离</h2><p>您可以创建不同的电子邮件、社交账号用作不同用途。拿电子邮件来说，您最好让这些不同的电子邮件具有不同的名称，让人难以认为这些电子邮件的主人是同一个人。</p><h2 id="Ex-写在后面"><a href="#Ex-写在后面" class="headerlink" title="Ex. 写在后面"></a>Ex. 写在后面</h2><p>这个系列差不多就结束了，我之后可能会修改、增加一些内容。</p><p>在这样一个人们几乎在互联网上裸奔的时代，有那么几个人穿上了衣服，也显得引人注目——什么意思？意思是说，您过度保护自己的隐私，有的时候会让人更多地注意到你。</p><p>如今的人们似乎有这样一种病症，老是想窥探别人的隐私。互联网给了人们面具，而这个面具在遮盖了他们本来面目的同时，也释放了他们内心的罪恶。</p><p>您需要一些保护措施。或许未来的互联网能够更加自由、开放，那些监视器会更少。我们或许能够找到互联网刚刚出现时的感觉——人们愿意通过互联网分享信息、交谈，而不会对自己的安全、隐私感到忧虑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 业余安全漫谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】平摊分析</title>
      <link href="/2022/11/23/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/23/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h1><p>执行一系列数据结构上操作的时间复杂度，可以通过对每个操作的时间复杂度进行分析，取平均，进行估计。</p><p>常用的方法有三种：聚焦方法、会计方法、势能方法。</p><h1 id="1-聚焦方法"><a href="#1-聚焦方法" class="headerlink" title="1.聚焦方法"></a>1.聚焦方法</h1><p>该方法大意为：考察每个操作的最坏时间复杂度，然后作平均得到整体的一个复杂度上界。</p><p>这个方法比较简单，易于操作，但是它估计出来的结果有的时候非常不精确，放缩的范围太大。</p><h2 id="实例：栈操作"><a href="#实例：栈操作" class="headerlink" title="实例：栈操作"></a>实例：栈操作</h2><p>考察：初始栈为空，经过一系列操作的代价。操作有三种：</p><ul><li>Push：压栈。</li><li>Pop：弹栈。</li><li>MultiPop：多重弹栈。</li></ul><p>由于一个对象在每次压栈后，至多被弹出一次，MultiPop弹栈的次数折算成Pop的次数，必然和压栈次数相等。如果压栈n次，那么MultiPop折算成Pop，也相当于Pop了n次，设最终栈空，则整体代价为2n&#x3D;O(n)，平摊下来，每个操作都是O(1)的复杂度。</p><h1 id="2-会计方法"><a href="#2-会计方法" class="headerlink" title="2.会计方法"></a>2.会计方法</h1><p>一系列操作的实际代价可能彼此不同。那么我们可以为每种操作分配不同的平摊代价，其有两种情况：</p><ul><li>如果平摊代价大于、等于实际代价，则平摊代价一部分用于抵消实际代价，一部分用于当作余额，支付其他操作的代价。</li><li>如果平摊代价小于实际代价，则平摊代价全部用作抵消自身实际代价，还要从其他操作的余额中索取一部分，补充抵消自身的代价。</li></ul><p>我们选取的平摊代价之和，必须大于实际代价之和，这样我们才能获取一个整体的代价上界，来估计实际代价。</p><h2 id="实例：栈操作-1"><a href="#实例：栈操作-1" class="headerlink" title="实例：栈操作"></a>实例：栈操作</h2><p>已知三种状态的实际代价为：</p><ul><li>Cost(Push)&#x3D;1</li><li>Cost(Pop)&#x3D;1</li><li>Cost(MultiPop)&#x3D;min(n,k)，k为栈中元素个数，n为MultiPop折算成Pop的弹栈次数。</li></ul><p>平摊代价为：</p><ul><li>Cost(Push)&#x3D;2,一个1用来支付Push的开销，剩下一个1用来预支Pop的开销。</li><li>Cost(Pop)&#x3D;0。</li><li>Cost(MultiPop)&#x3D;0。</li></ul><p>那么最坏总代价（最终栈空）为2n,n为压栈次数。总平摊代价也就为O(n)，每个操作的平摊代价就是O(1)。</p><h1 id="3-势能方法"><a href="#3-势能方法" class="headerlink" title="3.势能方法"></a>3.势能方法</h1><p>我们把进行一个操作的前后看作两个状态的转变，设每个状态$D_i$都有一个势能（潜力）$\phi(D_i)$，那么代价就是：<br>$$<br>AmortizedCost(Procedure)&#x3D;ActualCost(Procedure)+\Delta\phi<br>$$<br>势能怎么得到？认为规定即可，但是它要满足几个条件：</p><ul><li>恒正。</li><li>$\phi(D_i)\ge\phi(D_0)$，保证总平摊代价是总实际代价的上界。</li></ul><h2 id="实例：栈操作-2"><a href="#实例：栈操作-2" class="headerlink" title="实例：栈操作"></a>实例：栈操作</h2><p>规定$\phi(D_i)$为$D_i$状态下，栈中元素的个数，那么对于每个操作来说，它们的平摊代价为：</p><ul><li>Cost(Push)&#x3D;1+n-(n-1)&#x3D;2</li><li>Cost(Pop)&#x3D;1+(n-1)-n&#x3D;0</li><li>Cost(MultiPop)&#x3D;0</li></ul><p>n个栈操作的最坏总平摊代价为2n，其他结论同上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】贪心法</title>
      <link href="/2022/11/20/%E8%B4%AA%E5%BF%83/"/>
      <url>/2022/11/20/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="0-何为贪心？"><a href="#0-何为贪心？" class="headerlink" title="0.何为贪心？"></a>0.何为贪心？</h1><p>贪心算法就是，每次选择的时候，都选择局部最优的那个选择。</p><h1 id="1-贪心算法的不稳定性"><a href="#1-贪心算法的不稳定性" class="headerlink" title="1.贪心算法的不稳定性"></a>1.贪心算法的不稳定性</h1><h2 id="兑换硬币问题"><a href="#兑换硬币问题" class="headerlink" title="兑换硬币问题"></a>兑换硬币问题</h2><p>已知有5种不同面值的硬币：1元、2角5分、1角、5分、1分，现在想兑换6角7分，且得到的硬币最少。</p><p>从最大的的开始选，2个2角5分，之后1个1角，1个5分，2个1分，这就是最优解啦！</p><p>如果面值为：1角1分、5分、1分，现在想兑换1角5分，且得到的硬币最少。</p><p>应用贪心算法，得到1枚1角1分，4枚1分，显然不是最优解，因为还可以换3个5分钱硬币。</p><p>这表明，贪心算法并不是时时刻刻都有效的。若有效，需要满足两个条件：</p><ol><li>一个优化问题的优化解包含剩余子问题优化解。</li><li>一个优化问题的全局优化解可以通过局部优化选择得到。</li></ol><p>证明方法可以有：归纳法、交换论证法。后者的意思是，</p><blockquote><p>交换论证主要的思想也就是先假设存在一个最优的算法和我们的贪心算法最接近，<br>然后通过交换两个算法里的一个步骤(或元素)，得到一个新的最优的算法，同时<br>这个算法比前一个最优算法更接近于我们的贪心算法，从而得到矛盾，原命题成立。</p><p>——<a href="https://www.cnblogs.com/xiu68/p/8179117.html">博客园链接</a></p></blockquote><h1 id="2-活动选择问题"><a href="#2-活动选择问题" class="headerlink" title="2.活动选择问题"></a>2.活动选择问题</h1><p>给定一系列活动$a_1,a_2,\cdots,a_n$，每个活动有起始、终止时间$s_i,f_i$。在一个只能容纳一个活动的场所里展开这些活动，求一个活动数最多的安排方案。</p><p>贪！我们每次选择具有最小结束时间的活动。下面给出三个引理及之证明方法：</p><p><img src="/2022/11/20/%E8%B4%AA%E5%BF%83/greedy1.png"></p><p><img src="/2022/11/20/%E8%B4%AA%E5%BF%83/greedy2.png"></p><p><img src="/2022/11/20/%E8%B4%AA%E5%BF%83/greedy3.png"></p><p>所以该方法可行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】Arch Linux上WiFi经常自动断开</title>
      <link href="/2022/11/19/WLAN-Problem/"/>
      <url>/2022/11/19/WLAN-Problem/</url>
      
        <content type="html"><![CDATA[<h1 id="0-问题描述"><a href="#0-问题描述" class="headerlink" title="0.问题描述"></a>0.问题描述</h1><p>Arch Linux下，不论连接校园网还是热点，WiFi都会时不时断开连接，且无线网络管理工具没办法搜索到网络名（SSID）。</p><h1 id="1-驱动问题？"><a href="#1-驱动问题？" class="headerlink" title="1.驱动问题？"></a>1.驱动问题？</h1><p>换用一块外接网卡，依然出现该问题。</p><h1 id="2-服务冲突？"><a href="#2-服务冲突？" class="headerlink" title="2.服务冲突？"></a>2.服务冲突？</h1><p>通过查看所有的服务，发现<code>iwd.service</code>,<code>NetworkManager.service</code>,<code>wpa_suppliant.service</code>全都运行着，查看日志发现如下记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11月 19 12:56:41 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:02:10 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:02:10 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:08:01 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:08:01 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:15:25 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:15:25 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:22:55 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br><span class="line">11月 19 13:22:55 Coder109 iwd[555]: Unexpected connection related event -- is another supplicant running?</span><br></pre></td></tr></table></figure><p>disable掉后两个服务，不再出现该信息，但依然会断网。</p><h1 id="3-静态IP"><a href="#3-静态IP" class="headerlink" title="3.静态IP"></a>3.静态IP</h1><p>原先通过DHCP协议自动分配IP地址，幻调节为通过<code>systemd-networkd</code>服务配置成静态IP，虽然还会断线，但是重连的速度快了不少。</p><h1 id="4-校园网之罪"><a href="#4-校园网之罪" class="headerlink" title="4.校园网之罪"></a>4.校园网之罪</h1><p>经历了上面的调试后，我用笔记本开热点给台式机用，又将IP地址的分配方式改回了DHCP协议，发现稳定了很多，一个小时内都没出现掉线的状况。</p><h1 id="Ex-解决问题"><a href="#Ex-解决问题" class="headerlink" title="Ex.解决问题"></a>Ex.解决问题</h1><p>无线网卡还是安个天线比较好。我是傻子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】树搜索</title>
      <link href="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="0-为什么要树搜索？"><a href="#0-为什么要树搜索？" class="headerlink" title="0.为什么要树搜索？"></a>0.为什么要树搜索？</h1><p>有许多问题，它们的解可以表示为树。举个例子：</p><h2 id="布尔表达式可满足性问题"><a href="#布尔表达式可满足性问题" class="headerlink" title="布尔表达式可满足性问题"></a>布尔表达式可满足性问题</h2><p>q输入：由$x_1,x_2,\cdots,x_n$n个逻辑变元组成的逻辑表达式$A$。</p><p>输出：指派$v$，令$A^v&#x3D;T$，即一种变元赋值，让表达式为真。</p><p>对于每一个变元，都有0,1或者F,T两种取值，那么我们可以构造出这样一棵树来：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree1.png"></p><p>于是乎，我们可以应用树的相关算法，求解这样的一些问题。</p><h2 id="8-puzzle问题"><a href="#8-puzzle问题" class="headerlink" title="8-puzzle问题"></a>8-puzzle问题</h2><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree2.png"></p><p>该问题根据每一次挪动，可以被转化为树搜索问题：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree3.png"></p><p>首先我们先介绍两个算法：DFS,BFS。之后我们讨论如何优化树搜索的相关算法。</p><h1 id="1-深度优先搜索-DFS"><a href="#1-深度优先搜索-DFS" class="headerlink" title="1.深度优先搜索(DFS)"></a>1.深度优先搜索(DFS)</h1><p>对于一个图，我们想知道两个点之间是否有一条通路，可以使用DFS算法。</p><p>DFS算法有种“不撞南墙不回头”的感觉，算法如下：</p><ol><li>将起点压栈，标记为访问过。（从起点）</li><li>将一个与栈顶点邻接的，且未被访问过的节点压栈，标记为访问过，递归此步。（一直走下去）</li><li>如果最后没有没访问过的节点，且目标点没有遍历过，则回溯，将当前节点弹出，重新选择节点压栈。（直到走不通，往回走）</li></ol><h1 id="2-广度优先搜索-BFS"><a href="#2-广度优先搜索-BFS" class="headerlink" title="2.广度优先搜索(BFS)"></a>2.广度优先搜索(BFS)</h1><p>BFS相比于DFS,就灵活很多，它有种“扩散”的感觉，算法如下：</p><ol><li>将起点入队，标记为访问过。（从起点）</li><li>将与起点所有邻接点入队，标记为访问过，同时将起点出队，递归此步。（扩散）</li></ol><h1 id="3-爬山法"><a href="#3-爬山法" class="headerlink" title="3.爬山法"></a>3.爬山法</h1><p>对于一个可以用树搜索+DFS解决的问题，在深度优先搜索中，如何判定令哪个节点入栈最优呢？</p><p>我们可以使用贪心算法，即每一步都选令局部最优的那个解。</p><p>对于8-puzzle问题中的每一个步骤，我们可以编写出一个代价判据，每次都根据栈顶点，选择让这个代价判据最小的新点入栈。</p><p>通俗的来讲，就是在DFS“一直走下去”的过程中，每次都选择最“方便”的那一个点。</p><p>举个例子，我们让代价判据为“所有处于错误位置的方块数”，那么应用爬山法：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree4.png"></p><p>就可以找到一个解啦。</p><h1 id="4-Best-First搜索算法"><a href="#4-Best-First搜索算法" class="headerlink" title="4.Best-First搜索算法"></a>4.Best-First搜索算法</h1><p>但是，这不够好，贪心是<strong>局部最优的</strong>，有的时候局部最优显然不是全局最优解，Best-First算法就是为了解决这个情况而生的。</p><p>我们同样设立一个代价判据，但是，在所有节点中选择令代价判据最小的方案。</p><p>同样对于8-puzzle问题，如果应用这个算法：</p><p><img src="/2022/11/14/%E6%A0%91%E6%90%9C%E7%B4%A2/tree5.png"></p><ol><li>先走第一层，出现3,3,4,4的代价。</li><li>让两个3代价的展开，出现3,4,2,4的代价。</li><li>展开2代价的点。</li><li>$\cdots$</li></ol><h1 id="5-分支限界法"><a href="#5-分支限界法" class="headerlink" title="5.分支限界法"></a>5.分支限界法</h1><p>除此之外，我们可以采用这样的模式：把不可行的解都排除，只留下可行的解，再在可行解空间内讨论最优解。</p><h1 id="6-旅行商问题（TSP）"><a href="#6-旅行商问题（TSP）" class="headerlink" title="6.旅行商问题（TSP）"></a>6.旅行商问题（TSP）</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个有向图，这个图满足如下条件：</p><ol><li>每个节点都没有到自己的边。</li><li>每对节点间都有一条非负加权边。</li></ol><p>输出从任意一个节点开始，经过每个节点一次，最终返回开始节点的最短路径。</p><p>对于这个问题，我们采用如下的步骤求解：</p><ol><li>将所有解集合作为树根，设定一个基础代价，由代价矩阵计算所有解的代价的下界。</li><li>用爬山法递归地划分解空间，得到二叉树。</li></ol><p>划分过程：</p><ol><li>选择图上的任意一条边$(i,j)$划分，该划分要让左子树代价下界不变，右子树代价下界增加最大；且所有不包含$(i,j)$的解集合作为左子树，不包含的解集合作为右子树。</li><li>计算左右子树代价下界。</li></ol><p>划分到最后会出现一个解，这个解的代价$\alpha$是所有解的代价上界，如果对于其他子节点来说，它们的下界超过了$\alpha$，就停止继续划分。</p><p>这样的求解方法相当于：先将所有解汇总起来，通过二叉树的搜索方法，排除掉那些代价高的，最终筛选出一个低代价的解。</p><h2 id="基础代价的设定"><a href="#基础代价的设定" class="headerlink" title="基础代价的设定"></a>基础代价的设定</h2><p>代价矩阵里，包括着两点间每一条边的长度，如果不存在边，就设为$\infty$，举个例子：<br>$$<br>\left[<br>\begin{matrix}<br>\infty &amp; 3 &amp; 5 &amp; 9\<br>4 &amp; \infty &amp; 6 &amp; 8\<br>7 &amp; 3 &amp; \infty &amp; 2\<br>3 &amp; 5 &amp; 7 &amp; \infty\<br>\end{matrix}<br>\right]<br>$$<br>第$i$行，第$j$列的点表示$(i,j)$的长度。</p><p>基础代价肯定是几条边的长度的和，怎么选呢？我们不妨选择一些最小边，让每一行、每一列都有被选择出来的边。后续根据这些边再构造解。</p><p>我们在每一行都减去一个最小值：<br>$$<br>\left[<br>\begin{matrix}<br>\infty &amp; 0 &amp; 5 &amp; 9\<br>0 &amp; \infty &amp; 6 &amp; 8\<br>7 &amp; 3 &amp; \infty &amp; 0\<br>0 &amp; 5 &amp; 7 &amp; \infty\<br>\end{matrix}<br>\right]<br>$$<br>同时把所有减去的值加起来。这是为什么？</p><p>此外，要求：每一列都有0,每一行都有0。因为我们最终要把每个点都跑一遍。于是矩阵变成：<br>$$<br>\left[<br>\begin{matrix}<br>\infty &amp; 0 &amp; 0 &amp; 9\<br>0 &amp; \infty &amp; 6 &amp; 8\<br>7 &amp; 3 &amp; \infty &amp; 0\<br>0 &amp; 5 &amp; 7 &amp; \infty\<br>\end{matrix}<br>\right]<br>$$<br>初始代价为$3+4+2+3+5&#x3D;17$。这就是我们的代价下界。</p><h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>选择让右子树代价下界增加最多的划分边$(i,j)$，这又怎么选呢？</p><p>左子树代价不能变，所以只能从矩阵中那些为0的边中选择。其次，右子树是不包括划分边的，我们可以在矩阵中把划分边所在的行、列都不予考虑，重新构造代价下界，让剩下的每一行、每一列都出0。</p><p>之后在左右子树内都不断再分，可以选择先分割左子树，最终得到一个代价上界。</p><h1 id="7-A-算法"><a href="#7-A-算法" class="headerlink" title="7.A*算法"></a>7.A*算法</h1><p>一个很有效的搜索最短路径的算法。</p><p>原理：<br>$$<br>f(n)&#x3D;g(n)+h(n)<br>$$<br>其中，对于任一节点$n$，$f(n)$是经过节点$n$到目标节点的代价，$g(n)$是从起始节点到节点$n$的代价，$h(n)$是从节点$n$到目标节点的最小估计代价。</p><p>我们可以采用Best-First算法和BFS算法结合实现对$h(n)$的估计，从起始节点开始跑BFS,每一个节点的$h(n)$就是这个节点所有未被遍历过的边的最小值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux苦痛之路(二)：从Ubuntu到Manjaro</title>
      <link href="/2022/11/10/LinuxRoad2/"/>
      <url>/2022/11/10/LinuxRoad2/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h1><p>某天早上起来开机，发现进入了grub，心下大惊:“这必然是引导文件损坏啦！”。果不其然，登录到系统后，发现报了一连串的错误，打开几个软件后，系统卡得几乎无法工作。由于我的Linux水平还比较小白……那么，不修！直接换系统！</p><p>一直以来，幻都想尝试Arch系的滚动升级版Linux，不仅因为Arch Wiki写得非常非常细致，也因为AUR安装软件包很方便，于是决定试一试比较出名的Manjaro。这篇博文当作Manjaro的踩坑记录和备忘录。</p><h1 id="1-更新源-amp-准许AUR"><a href="#1-更新源-amp-准许AUR" class="headerlink" title="1.更新源&amp;准许AUR"></a>1.更新源&amp;准许AUR</h1><p>由于Manjaro是滚动发行版，更新的话软件大多会更新到最新版，有的甚至是beta版本，这些版本的软件有可能不稳定，建议慎重更新。参考：</p><p><a href="https://wiki.archlinux.org/title/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:System maintenance (简体中文)</a></p><p><a href="https://wiki.archlinux.org/title/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:pacman (简体中文)</a></p><p>更新源为国内源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -c China</span><br></pre></td></tr></table></figure><p>AUR是第三方软件源，参考<a href="https://wiki.archlinux.org/title/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:Arch User Repository (简体中文)</a>，是一个强大的软件源。在“添加&#x2F;删除软件”界面配置。</p><p><img src="/2022/11/10/LinuxRoad2/aur.png"></p><p>如何安装AUR源上的软件呢？举个例子：</p><p><img src="/2022/11/10/LinuxRoad2/aur2.png"></p><p>复制“Git Clone URL”，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;URL&quot;</span></span><br></pre></td></tr></table></figure><p>之后进入该文件夹，里面会有一个PKGBUILD文件，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makepkg ./PKGBUILD</span><br></pre></td></tr></table></figure><p>即可构建出一个安装包出来，之后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -U *.zst</span><br></pre></td></tr></table></figure><p>安装软件包即可。</p><h1 id="2-N卡驱动"><a href="#2-N卡驱动" class="headerlink" title="2.N卡驱动"></a>2.N卡驱动</h1><p>听一些久用Arch的老鸟说，要先把驱动装好，免得后面出现错误，造成损失。在更新驱动之前，我们要知道：</p><p>驱动和内核是有关联的，如果驱动支持的内核版本和机器的内核版本不匹配，很容易出现进不去图形界面等错误。在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia</span><br></pre></td></tr></table></figure><p>查看可安装的驱动版本，安装内核对应版本的驱动即可。</p><h1 id="3-输入法问题"><a href="#3-输入法问题" class="headerlink" title="3.输入法问题"></a>3.输入法问题</h1><p>具体安装，参考<a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki:Fcitx5 (简体中文)</a></p><p>至于终端无法输入汉字的问题，请在终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S manjaro-asian-input-support-fcitx5</span><br></pre></td></tr></table></figure><h1 id="4-QQ-amp-微信解决方案"><a href="#4-QQ-amp-微信解决方案" class="headerlink" title="4.QQ&amp;微信解决方案"></a>4.QQ&amp;微信解决方案</h1><p>体验比在Ubuntu下好很多。</p><p>QQ:<a href="https://aur.archlinux.org/packages/com.qq.tim.spark">AUR:com.qq.tim.spark</a></p><p>微信：<a href="https://aur.archlinux.org/packages/deepin-wine-wechat">AUR:deepin-wine-wechat</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】组建自己的ftp传输网络</title>
      <link href="/2022/11/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E7%BB%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84ftp%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/11/07/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E7%BB%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84ftp%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h1><p>新电脑安装Ubuntu系统，没有找到合适的QQ解决方案，但是平时又需要通过QQ传输文件。那么就只好让台式机当作一个ftp服务器，其他设备当作客户端，传输文件。偶尔也可以更方便地接收同学发来的文件。</p><h1 id="1-用户端搭建"><a href="#1-用户端搭建" class="headerlink" title="1.用户端搭建"></a>1.用户端搭建</h1><p>笔记本电脑端(Win11)选择用Filezilla进行连接。</p><h1 id="2-服务端搭建"><a href="#2-服务端搭建" class="headerlink" title="2.服务端搭建"></a>2.服务端搭建</h1><p>台式机端(Ubuntu 22.04 LTS)选用vsftpd进行服务器搭建。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过包管理器安装即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vsftpd</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先找到vsftpd的配置文件位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis vsftpd.conf</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsftpd.conf: /etc/vsftpd.conf /usr/share/man/man5/vsftpd.conf.5.gz</span><br></pre></td></tr></table></figure><p>接着编辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo emacs /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>这个配置文件的注释十分详细，你可以清楚地看到每一个参数的功能、用法。</p><p>为了能让用户登陆、上传文件，创造出一个私有的FTP服务器，我们要作出如下修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br></pre></td></tr></table></figure><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>在home目录下创建一个文件管理用户，此外也要创建用户方便ftp用户登陆。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /home/ftpuser</span><br><span class="line">sudo useradd -d /home/ftpuser ftpuser</span><br><span class="line">sudo passwd ftpuser</span><br></pre></td></tr></table></figure><h2 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h2><p>万事俱备！用如下命令开启ftp服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd start</span><br></pre></td></tr></table></figure><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>检查能否登陆，可以连接自身：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp 127.0.0.1</span><br></pre></td></tr></table></figure><p>输入刚才的用户名、密码，能够登陆就说明成功配置。</p><h1 id="3-客户端连接"><a href="#3-客户端连接" class="headerlink" title="3.客户端连接"></a>3.客户端连接</h1><p>在服务器端观察网关地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>在Filezilla上输入地址、用户名、密码即可连接。</p><h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h1><p>arch linux用户请勿参考该解决方案，请去arch wiki寻找正确配置方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】动态规划</title>
      <link href="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="1-何为动态规划？"><a href="#1-何为动态规划？" class="headerlink" title="1.何为动态规划？"></a>1.何为动态规划？</h1><p>书接上文，可以把分治法看作是：把一个问题分成若干个<strong>独立</strong>的子问题。如果子问题不独立呢？</p><p>拿$Fibonacci$数列问题来说，每一个子问题都和其他子问题有关系。这个时候用分治法就不是很合理了，比如说，求解$Fib(5)$就必然要求$Fib(4),Fib(3)$，而求$Fib(4)$还要求一次$Fib(3)$，这就导致，有的子问题要被多次求解，专业点的说法就是<strong>子问题重叠</strong>。</p><p>这时候George说了，“那我们不妨从小问题开始求，把结果都记下来，最后一步步求解到原问题吧”。</p><p>这就是动态规划：把原始问题划分成若干个子问题，求解每个子问题仅一次，并将其结果保存，以后用到时直接存取，不重复计算，节省计算时间。</p><p>什么样的问题适用于动态规划呢？</p><p><strong>优化问题</strong>：问题可能有很多解，每个可能的解都对应有一个值，这个值通常称为代价。优化问题是要在该问题所有可能的解中找到代价最大&#x2F;最小的解，即问题的一个优化解（最优解）。</p><p><strong>重叠问题</strong>:在问题的求解过程中，很多子问题的解将被多次使用。</p><p>动态规划求解的步骤大致为：简化原问题-建立递归方程-求解子问题-求解原问题。</p><h1 id="2-矩阵乘法链"><a href="#2-矩阵乘法链" class="headerlink" title="2.矩阵乘法链"></a>2.矩阵乘法链</h1><p>输入：表达式：$A_1\times A_2\times \cdots\times A_n$，其中$A_i$是$p_{i-1}\times p_i$矩阵。</p><p>输出：乘法的最小代价方法，代价为乘法运算次数。</p><p>最小代价？代价从哪里来？根据矩阵的乘法原理，$A_{10\times 100}\times B_{100\times 5}\times C_{5\times 50}&#x3D;(A\times B)\times C&#x3D;A\times (B\times C)$。对于$(A\times B)\times C$来说，$A\times B$的代价是$10\times 100\times 5&#x3D;5000$，而产出一个$10\times 5$矩阵，与$C$相乘，代价为$10\times 5\times 50&#x3D;2500$，相加得$7500$。同理，$A\times(B\times C)$代价为$75000$。</p><p>引入概念：</p><p>最优子结构：问题最优解由子问题最优解组成。</p><p>讨论下图中所有的乘法方案最优性：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes.png"></p><p>设$C[i,j]$为计算$A_i\times A_{i+1}\times\cdots\times A_j$的最小代价，可以作出代价的递归方程：<br>$$<br>C[i,j]&#x3D;min_{i\leq k&lt; j}{C[i,k]+C[k+1,j]+(i-1)kj},i&lt;j\<br>C[i,j]&#x3D;0,i&#x3D;j<br>$$<br>递归得到两个括号内的最优乘法方案，合并就是最优乘法方案了。但是：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes2.png"></p><p>不难看出有子问题重叠。</p><p>那么根据动态规划的思想，计算$C[i,j]$需要计算出每一个$C[a,b],i\leq a\leq j,a\leq b\leq j$，可作出下图：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes3.png"></p><p>每个红线上的矩阵链长度相同。从最长的对角线一直求到目标长度。</p><p>时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$。</p><h1 id="3-最长公共子序列"><a href="#3-最长公共子序列" class="headerlink" title="3.最长公共子序列"></a>3.最长公共子序列</h1><p>输入：$X&#x3D;(x_1,x_2,x_3,\cdots,x_m),Y&#x3D;(y_1,y_2,y_3,\cdots,y_n)$</p><p>输出：$Z&#x3D;(z_1,z_2,z_3,\cdots)$为$X,Y$最长的公共子序列。</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes4.png"></p><p>由此推得，子问题有重叠性：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes5.png"></p><p>对于$X,Y$的所有子串，可以列出公共子序列长度方程：<br>$$<br>C[i,j] &#x3D; 0\ \ \ \ ij&#x3D;0\<br>C[i,j]&#x3D;C[i-1,j-1]+1\ \ \ \ i,j&gt;0,x_i&#x3D;y_j\<br>C[i,j]&#x3D;Max(C[i,j-1],C[i-1,j])\ \ \ \ i,j&gt;0,x_i\neq y_j<br>$$<br>对于每一个$x_i,y_j$，都依靠上式计算，自底向上求解，即在求$C[i,j]$之前，先求出$C[i-1,j-1],C[i-1,j],C[i,j-1]$，并记录下<strong>此时对应的子问题</strong>，作出下表：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes6.png"></p><p>每一个格子，里面的箭头表示其对应的子问题，比如如果对某个格子来说，$x_i&#x3D;y_j$，箭头就指向$C[i-1,j-1]$；里面的数字代表公共子序列的长度。</p><p>时间复杂度为$O(mn)$，因为要讨论$mn$个元素，而每个元素讨论的时候复杂度是$O(1)$；构造子序列，即查看子序列的具体内容，复杂度是$O(m+n)$，因为可以看作从右下角走到边界。合并起来时间复杂度是$O(mn)$</p><p>空间复杂度是$O(mn)$。</p><h1 id="4-0-1背包问题"><a href="#4-0-1背包问题" class="headerlink" title="4.0-1背包问题"></a>4.0-1背包问题</h1><p>问题概述：给定$n$种物品和一个背包，物品$i$的重量是$w_i$，价值$v_i$, 背包承重为$C$, 问如何选择装入背包的物品，使装入背包中的物品的总价值最大？对于每种物品只能选择完全装入或不装入，一个物品至多装入一次。</p><p>抽象成一个问题：</p><p>输入：给定$C&gt;0,w_i&gt;0,v_i&gt;0,1\leq i \leq n$</p><p>输出：$(x_1,x_2,\cdots,x_n),x_i\in {0,1},Q&#x3D;\sum_{1\leq i\leq n}w_ix_i\leq C$，求满足条件的最大$Q$。</p><p>原问题，记作：$(x_1,x_2,x_3,\cdots,x_n),C$，意思是把$(x_1,x_2,x_3,\cdots,x_n)$装入容量为$C$的背包中，根据是否装第一个物品，可划归成两个子问题：</p><ol><li>$(x_2,x_3,\cdots,x_n),C-w_1$</li><li>$(x_2,x_3,\cdots,x_n),C$</li></ol><p>那么，可以分析出子问题重叠：</p><p><img src="/2022/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrixTimes7.png"></p><p>作递归方程，设$C[i,j]$是可选物品为$i,i+1,\cdots,n$，背包容量为$j$时的最大价值：<br>$$<br>C[i,j]&#x3D;C[i+1,j],0\leq j \leq w_i\<br>C[i,j]&#x3D;Max(C[i+1,j],C[i+1,j-w_i]+v_i),j&gt;w_i<br>$$<br>第一个式子的意思是，装不下，只好讨论下一个物品。第二个式子则是讨论装与不装哪个更划算一些。</p><p>根据上面的这个表达式，参考最长公共子序列的计算方式，可以求解。</p><p>时间复杂度是$O(Cn)$，空间复杂度是$O(Cn)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】分治法&amp;减治法</title>
      <link href="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-何为分治？何为减治？"><a href="#1-何为分治？何为减治？" class="headerlink" title="1.何为分治？何为减治？"></a>1.何为分治？何为减治？</h1><p>分治法就是把一个大问题拆成<strong>很多</strong>小问题，然后分别解决，最后归并。</p><p>分治法一般有三个步骤：划分-求解-合并。</p><p>减治就是把问题划归为<strong>一个</strong>小问题，得到原问题解。</p><h1 id="2-二分查找最值"><a href="#2-二分查找最值" class="headerlink" title="2.二分查找最值"></a>2.二分查找最值</h1><p>输入：数组$A$</p><p>输出：数组中的最大值$Max$、最小值$Min$</p><p>划分：把$A$对半拆分，使拆分得到的每个小数组长度不超过2。</p><p>求解：对于每个数组都找出最大最小值。不断比较。</p><p>合并：无需合并，最后输出的数就是最终结果。</p><p>最终比较的次数为$\frac{3n}{2}-2$：</p><p>根据下面的图示：</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/MaxMin.png"></p><p>列出比较次数的递推方程：<br>$$<br>T(n)&#x3D;2T(\frac{n}{2})+2<br>$$<br>加2是因为两半数组比较之后，还要比较输出的最大最小值，由迭代法求得：<br>$$<br>T(n)&#x3D;\frac{3n}{2}-2<br>$$</p><h1 id="3-二进制大整数乘法"><a href="#3-二进制大整数乘法" class="headerlink" title="3.二进制大整数乘法"></a>3.二进制大整数乘法</h1><p>输入：n位二进制整数$X,Y$</p><p>输出：$X,Y$的乘积</p><p>通常分治复杂性为$O(n^2)$，改进分治法可以把复杂度改为$O(n^{1.59})$。</p><h2 id="通常分治法"><a href="#通常分治法" class="headerlink" title="通常分治法"></a>通常分治法</h2><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/BigTimes.png"></p><p>划分：将$X,Y$各自对半分，产生$A,B,C,D$。</p><p>求解&amp;合并：计算$AC,AD,BC,BD$，再计算$AD+BC$，将$AC$左移n位，$AD+BC$左移$\frac{n}{2}$位，从而计算。</p><p>时间复杂性为：<br>$$<br>T(n)&#x3D;4T(\frac{n}{2})+O(n)\to T(n)&#x3D;O(n^2)<br>$$</p><h2 id="改进分治法"><a href="#改进分治法" class="headerlink" title="改进分治法"></a>改进分治法</h2><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/BigTimes2.png"></p><p>这样分割完后，只需要计算$AC,BD,(A+B)(C+D)$即可。</p><p>根据$Master$定理，时间复杂性为：<br>$$<br>T(n)&#x3D;3T(\frac{n}{2})+O(n)\to T(n)&#x3D;O(n^{1.59})<br>$$</p><h1 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h1><p>输入：数组$A$</p><p>输出：排好序的数组$B$</p><p>划分：将数组依照一个参考点$A[i]$分割为两个部分，将比$A[i]$小的元素放在其左，比它大的放在其右。</p><p>求解：递归划分。</p><p>合并：无需合并，直接输出即可。</p><p>最好情况：每次分割，都将数组分割为两个相等的子集合：<br>$$<br>T(n)&#x3D;2T(\frac{n}{2})+\theta (n)\to T(n)&#x3D;\theta(nlogn)<br>$$<br>$\theta(n)$是因为每次分割都要把数组中的元素同分割点作比较，时间复杂度为$\theta(n)$。</p><p>最坏情况：每次分割，所有元素都落在一边：<br>$$<br>T(n)&#x3D;T(n-1)+\theta(n)\to \theta(n^2)<br>$$<br>平均复杂性为$O(nlogn)$。</p><h1 id="5-中位数和顺序统计量"><a href="#5-中位数和顺序统计量" class="headerlink" title="5.中位数和顺序统计量"></a>5.中位数和顺序统计量</h1><p>输入：由$n$个数构成的多重集合$S$和数$k$</p><p>输出：$S$中第$k$小的元素$x$</p><p>划分：分组，每组5个数，最后一组可能小于5个数，用$+\infty$补足。$O(n)$，一次循环即可解决。</p><p>求解：每组数分别插入排序选出中位数($O(n)$)，递归地排序所有中位数($T(\frac{n}{5})$)，并得出所有中位数的中位数$p$。</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/minusAlgorithm.png"></p><p>这样，根据上图我们把$S$划分为三个集合$S_1,S_2,S_3$，它们中的元素分别小于、等于、大于$p$。$O(n)$</p><p>合并：如果$|S_1|\geq k$，递归地在$S_1$中搜索$x$；否则，如果$|S_1|+|S_2|\geq k$，$x&#x3D;p$；否则，$k’&#x3D;k-|S_1|-|S_2|$，递归地在$S_3$中搜索第$k’$小元素。这一步花费是$T(\frac{3n}{4})$，看上面那张图，合并这一步至少删除了$\frac{n}{4}$个元素，只需要在$\frac{3n}{4}$个元素中进行操作。</p><p>时间复杂性：<br>$$<br>T(n)&#x3D;T(\frac{3n}{4})+T(\frac{n}{5})+O(n)\to T(n)&#x3D;O(n)<br>$$</p><h1 id="6-最邻近点对"><a href="#6-最邻近点对" class="headerlink" title="6.最邻近点对"></a>6.最邻近点对</h1><p>输入：欧氏空间上$n$个点的集合$Q$</p><p>输出：$Q$中欧氏距离最近的两个点$A,B$</p><p>划分：按照横&#x2F;纵坐标对各个点进行排序，求解出中位数$m$。依据之将$Q$分割成两个集合$Q_1,Q_2$，两个集合内的坐标点的横&#x2F;纵坐标分别小于、大于$m$。</p><p>求解：如果最后划分的集合中只有两个点，就返回这两个点，否则，递归划分。</p><p>合并：在选择最邻近点的时候，不仅要考虑分割得到的集合，也要考虑分割点和其他点形成的点对。具体怎么实现？首先得到$Q_1,Q_2$中的最短距离$d$，然后在$m\pm d$的范围内寻找是否存在$d’&lt;d$。最多有六个这样的点，证明如下：</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E6%B3%95/nearest.png"></p><p>时间复杂性：<br>$$<br>T(n)&#x3D;2T(\frac{n}{2})+O(n)\to T(n)&#x3D;O(nlogn)<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】算法的数学基础</title>
      <link href="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-函数的阶"><a href="#1-函数的阶" class="headerlink" title="1.函数的阶"></a>1.函数的阶</h1><p>$\Theta$为同阶函数，即：<br>$$<br>\Theta(g(n))&#x3D;{f(n)|\exists c_1,c_2&gt;0,n_0,\forall n&gt;n_0,c_1g(n)\leq f(n)\leq c_2g(n)}<br>$$<br>举个例子，<br>$$<br>\frac{1}{2}n^2-3n&#x3D;\Theta(n^2)\<br>6n^3\neq \Theta(n^2)<br>$$<br>$O$为低阶函数，即：<br>$$<br>O(g(n))&#x3D;{f(n)|\exists c&gt;0,n_0,\forall n&gt;n_0,0\leq f(n)\leq cg(n)}<br>$$<br>几何上来看，就是超过一个常数时，$f(n)$不会超过$cg(n)$。</p><p>$\Omega$为高阶函数。</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/funPic.png" alt="image-20221102145353340"></p><h1 id="2-递归方程及其解法"><a href="#2-递归方程及其解法" class="headerlink" title="2.递归方程及其解法"></a>2.递归方程及其解法</h1><p>什么是递归方程呢？由自身定义自身的方程。</p><p>举个例子：<br>$$<br>T(n)&#x3D;T(\frac{n}{2})+3<br>$$<br>就是一个递推方程。值得一提的解法有两种：迭代法、$Master$定理法</p><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>很简单，就是把递归方程循环地展开，把递归式转化为和式，根据级数关系求解，举个例子：</p><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/recursionEquation.png"></p><h2 id="Master-定理法"><a href="#Master-定理法" class="headerlink" title="$Master$定理法"></a>$Master$定理法</h2><p><img src="/2022/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/masterTh.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【博客】Hexo博客部署踩坑</title>
      <link href="/2022/11/02/Hexo-blog/"/>
      <url>/2022/11/02/Hexo-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="1-图片加载不出来"><a href="#1-图片加载不出来" class="headerlink" title="1.图片加载不出来"></a>1.图片加载不出来</h1><p>一开始，幻在hexo的博文文件夹_posts里新建了一个文件夹post-image来存储博客图片，但是部署之后，图片同样加载不出来，查看public文件夹，发现：post-image并没有被上传，也就没法被调用。</p><p>解决方案：</p><p>在项目的_config.yml文件中将post_asset_folder改为true，并在后面添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样，在新建博文的同时，会创建一个同名文件夹，将图片存储在里面，就可以调用：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="link">./file.jpg</span>)</span><br></pre></td></tr></table></figure><h1 id="2-尾注问题"><a href="#2-尾注问题" class="headerlink" title="2.尾注问题"></a>2.尾注问题</h1><p>旧博文里出现了尾注报错、无法跳转的问题，暂时不想修改了。以后有时间再改（咕咕咕）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火狐配置备忘</title>
      <link href="/2022/11/01/FirefoxNote/"/>
      <url>/2022/11/01/FirefoxNote/</url>
      
        <content type="html"><![CDATA[<h1 id="about-config配置"><a href="#about-config配置" class="headerlink" title="about:config配置"></a>about:config配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser.tabs.closeTabByDblclick - <span class="literal">true</span> <span class="comment"># 允许双击关闭标签页</span></span><br><span class="line">browser.tabs.loadBookmarksInTabs - <span class="literal">true</span> <span class="comment"># 允许新标签页打开书签</span></span><br><span class="line">browser.tabs.closeWindowWithLastTab - <span class="literal">false</span> <span class="comment"># 禁止关闭最后一个标签页时关闭浏览器窗口</span></span><br></pre></td></tr></table></figure><h1 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h1><p>隐私獾</p><p>Simple Translate</p><p>uBlock origin</p><p>dark reader</p><p>tabliss</p><p>https everywhere</p>]]></content>
      
      
      
        <tags>
            
            <tag> Firefox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux苦痛之路(一)：基本配置篇</title>
      <link href="/2022/11/01/linuxRoad1/"/>
      <url>/2022/11/01/linuxRoad1/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h2><p>最近购置了一台台式机，在配置的时候，突发奇想，“不如安个Linux吧！”。于是安上了Fedora，安完发现发现新版本的Fedora没有网卡驱动，而我手头又没有网线，安装其它驱动也有问题。</p><p>秉持着“能折腾就折腾，不能折腾就逃跑”的思想，我重新安了个Ubuntu 22.04。由于一直都在用windows，感觉linux配置起来没有windows那么简单。</p><p>这篇blog就当作是自己的踩坑记录了。</p><h2 id="1-QQ-amp-微信解决方案"><a href="#1-QQ-amp-微信解决方案" class="headerlink" title="1.QQ&amp;微信解决方案"></a>1.QQ&amp;微信解决方案</h2><p>这两个软件也算是国内相当一部分人没有选择Linux作为主力系统的原因，QQ for Linux做得太垃圾，甚至没有办法登陆。</p><p>一开始想要用原生的wine，一路配置好，发现微信和QQ都非常卡，还容易闪退，只好放弃这个方案。</p><p>后来，幻采用deepin-wine方案，但是网上流传的各大版本都存在依赖的问题，最终尝试后，微信可以在<a href="https://github.com/zq1997/deepin-wine">zq1997’s deepin-wine</a>下运行，有时会报错，但是不影响运行。</p><p>那么QQ呢？QQ在zq1997的deepin-wine下会闪退，采取作者在Issue中提到的方法也无济于事。</p><p>后来幻又尝试了一下docker qq，但是由于版本过低无法登陆。</p><p>最后幻选择不用qq。</p><h2 id="2-Nvidia驱动"><a href="#2-Nvidia驱动" class="headerlink" title="2.Nvidia驱动"></a>2.Nvidia驱动</h2><p>本人的显卡是GeForce GTX 1050Ti。</p><p>先要禁用Nouveau：</p><p>在&#x2F;etc&#x2F;modprobe.d&#x2F;blacklist.conf最后加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>即可。</p><p>在nvidia官网下载驱动文件安装。</p><p>最后用nvidia-smi命令验证即可，能够看到驱动版本就说明安装成功啦。</p><h2 id="3-代替方案"><a href="#3-代替方案" class="headerlink" title="3.代替方案"></a>3.代替方案</h2><p>左边是Linux下软件名，右边是Win下的。</p><p>KeepassX-Keepass2</p><p>Zotero-NoteExpress</p><h2 id="4-字体安装"><a href="#4-字体安装" class="headerlink" title="4.字体安装"></a>4.字体安装</h2><p>各种报告、论文要用到一些特定字体。</p><p>下载下来.ttc,.ttf等类型的字体文件，首先将字体移动到指定文件夹里，更改权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> &lt;fontFiles&gt; /usr/share/fonts/myFonts</span><br><span class="line">sudo <span class="built_in">chmod</span> 644 /usr/share/fonts/myFonts</span><br></pre></td></tr></table></figure><p>接着执行指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache fv</span><br></pre></td></tr></table></figure><p>大功告成。</p><h2 id="5-Hey-Hexo"><a href="#5-Hey-Hexo" class="headerlink" title="5.Hey!Hexo!"></a>5.Hey!Hexo!</h2><p>一直都在考虑把博客迁移到Hexo上面，Gridea的操作还是有些不人性化，同步起来也有问题。在安装Hexo、部署博客的过程中，也出现了不少困难。</p><h3 id="cannot-read-properties"><a href="#cannot-read-properties" class="headerlink" title="cannot read properties"></a>cannot read properties</h3><p>用apt安装好node.js，采用npm安装hexo，结果报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="variable constant_">ERR</span>! <span class="title class_">Cannot</span> read property <span class="string">&#x27;insert&#x27;</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>困扰了将近一天后，突然觉得应该是版本的问题，可能旧版本没有insert这个属性，于是查看node.js的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>分别输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12.22.9</span><br><span class="line">8.5.1</span><br></pre></td></tr></table></figure><p>然后看了看node.js的官网，发现已经出到19.x.x系列了，果然是版本的问题！</p><p>于是卸载node.js，去官网查看<a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions">Ubuntu下node.js的安装方式</a>,最终跟随指引成功安装，也能够安装hexo了。</p><h3 id="权限不够"><a href="#权限不够" class="headerlink" title="权限不够"></a>权限不够</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>报错，其中有permission denied字样，改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>成功安装。</p><h2 id="6-安装Battlefield-1"><a href="#6-安装Battlefield-1" class="headerlink" title="6.安装Battlefield 1"></a>6.安装Battlefield 1</h2><p>让我们来打游戏吧！我想在Ubuntu下安装战地一。很不巧，战地一并不支持Linux下运行，只好寻找一些替代的解决方案。</p><p>wine？太卡了！还有许多不明不白的bug，不算是很好的选择。</p><p>deepin-wine？没有提供战地一的包，安装不了。</p><p>经过搜索，选择lutris。</p><p>从github上安装lutris的稳定版本，安装。</p><p>首先要去lutris注册一个账号，搜索相关的游戏，安装。</p><p>然而由于lutris官网的问题，我们没办法下载游戏，会报错（链接已重置）。</p><p>再搜索……proton！proton是steam play出品的工具，集成了wine等工具。首先我们要切换steam为beta版本，之后在设置-steam play里把Advanced里面的勾勾勾上，然后下载战地一即可。</p><p>在Linux下打游戏没有在Windows下面顺畅，安装游戏很麻烦，玩游戏的时候也能感觉到明显的卡顿。</p><h2 id="7-OBS-Virtual-Camera无法加载"><a href="#7-OBS-Virtual-Camera无法加载" class="headerlink" title="7.OBS Virtual Camera无法加载"></a>7.OBS Virtual Camera无法加载</h2><p>首先安装obs-v4l2sink包，运行obs之前执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -r v4l2loopback</span><br><span class="line">sudo modprobe v4l2loopback devices=1 video_nr=2 exclusive_caps=1 card_label=<span class="string">&quot;VirtualWebCam&quot;</span></span><br></pre></td></tr></table></figure><p>之后打开obs，启动虚拟摄像机，再打开腾讯会议等软件，就能调用虚拟摄像头了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LaTeX】符号表和相关用法</title>
      <link href="/2022/10/19/latex-fu-hao-biao-he-xiang-guan-yong-fa/"/>
      <url>/2022/10/19/latex-fu-hao-biao-he-xiang-guan-yong-fa/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/10/19/latex-fu-hao-biao-he-xiang-guan-yong-fa/1666193536094.png"></p><p><img src="/2022/10/19/latex-fu-hao-biao-he-xiang-guan-yong-fa/1666193542067.png"></p><p><img src="/./p1666193551596.png"></p><p><img src="/2022/10/19/latex-fu-hao-biao-he-xiang-guan-yong-fa/1666193554310.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学/数理逻辑】备忘</title>
      <link href="/2022/10/19/shu-xue-shu-li-luo-ji-bei-wang/"/>
      <url>/2022/10/19/shu-xue-shu-li-luo-ji-bei-wang/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="1-求主合取范式和主析取范式"><a href="#1-求主合取范式和主析取范式" class="headerlink" title="1.求主合取范式和主析取范式"></a>1.求主合取范式和主析取范式</h1><p>合取，两个都对才对，所以是“与”号。</p><p>析取，一个对就对，所以是“或”号。</p><p>对于一个逻辑表达式，先列出真值表，主合取范式为所有令结果为假的最大项合取，主析取范式为所有令结果为真的最小项析取，举个例子：</p><p>求：$p\to q$的主合取范式和主析取范式。<br>解：列真值表：</p><table><thead><tr><th>p</th><th>q</th><th>$p\to q$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>所以弄假表达式的最大项为：<br><img src="/2022/10/19/shu-xue-shu-li-luo-ji-bei-wang/1666169581268.png"></p><p>弄真表达式的最小项为：<br><img src="/2022/10/19/shu-xue-shu-li-luo-ji-bei-wang/1666169631827.png"></p><p>主合取范式、主析取范式可得。</p><h1 id="2-逻辑等价-x2F-蕴含是否成立"><a href="#2-逻辑等价-x2F-蕴含是否成立" class="headerlink" title="2.逻辑等价&#x2F;蕴含是否成立"></a>2.逻辑等价&#x2F;蕴含是否成立</h1><p>反证法，若蕴含不成立，则必定存在一种指派$v$，弄真左侧，弄假右侧。</p><p>也可以列真值表求解。</p><p>对于任意指派，逻辑等价为两个逻辑表达式真值恒等，逻辑蕴含是指蕴含式恒真。</p><h1 id="3-PC-Propositional-Calculus-系统上的定理备忘（部分）"><a href="#3-PC-Propositional-Calculus-系统上的定理备忘（部分）" class="headerlink" title="3.PC(Propositional Calculus)系统上的定理备忘（部分）"></a>3.PC(Propositional Calculus)系统上的定理备忘（部分）</h1><p>$$<br>If \ \ \vdash P,then\ \ \vdash A\to P<br>$$<br>$$<br>\neg A\to (A\to B)\<br>$$<br>$$<br>(\neg A\to B)\to ((\neg A\to\neg B)\to A)\<br>$$<br>$$<br>\neg A\to C,B\to C\Leftrightarrow (A\to B)\to C\<br>$$<br>$$<br>(A\to B)\to((A\to \neg B)\to\neg A)\<br>$$<br>$$<br>A\to B,C\to D \to (B\to C)\to(A \to D)<br>$$</p><h1 id="4-ND-Natural-Deduction-系统上的定理备忘（部分）"><a href="#4-ND-Natural-Deduction-系统上的定理备忘（部分）" class="headerlink" title="4.ND(Natural Deduction)系统上的定理备忘（部分）"></a>4.ND(Natural Deduction)系统上的定理备忘（部分）</h1><p>$$<br>\frac{\Gamma;A\vdash B\ \ \Gamma;\neg A\vdash B}{\Gamma\vdash B}\ \ (\neg -)\<br>$$<br>$$<br>\frac{\Gamma\vdash A}{\Gamma\vdash A\vee B}\ \ (\vee +)\<br>$$<br>$$<br>\frac{\Gamma;A\vdash C\ \ \Gamma;B\vdash C\ \ \Gamma\vdash A\vee B}{\Gamma\vdash C}\ \ (\vee -)\<br>$$<br>$$<br>\frac{\Gamma;A\vdash B\ \ \Gamma;A\vdash\neg B}{\Gamma\vdash \neg A}\ \ (\neg +)\<br>$$<br>$$<br>\frac{\Gamma\vdash A\ \ \Gamma\vdash\neg A}{\Gamma\vdash B}\ \ (\neg -)\<br>$$</p><p>事实上，PC、ND两个系统等价，定理可以通用。可惜考试的时候不能用。</p><h1 id="5-连接词备忘"><a href="#5-连接词备忘" class="headerlink" title="5.连接词备忘"></a>5.连接词备忘</h1><p>$\uparrow,\downarrow$分别为与非词，或非词。有如下规律：<br>$$<br>\neg p &#x3D; p\uparrow p&#x3D;p\downarrow p<br>$$<br>$$<br>p\vee q &#x3D; (p\downarrow q)\downarrow(p\downarrow q)<br>$$<br>$$<br>p\wedge q &#x3D; (p \uparrow q)\uparrow (p \uparrow q)<br>$$</p><p>对于蕴含词$\to$，可变换为：<br>$$<br>p\to q &#x3D; \neg p \vee q<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数理逻辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学/近世代数】备忘</title>
      <link href="/2022/10/18/shu-xue-jin-shi-dai-shu-bei-wang/"/>
      <url>/2022/10/18/shu-xue-jin-shi-dai-shu-bei-wang/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="1-幂等元存在性"><a href="#1-幂等元存在性" class="headerlink" title="1.幂等元存在性"></a>1.幂等元存在性</h1><p>问：有限半群$(G,\cdot)$中，必定存在元素$a$，令$a\cdot a &#x3D; a$。<br>证：设$|G|&#x3D;n$，$a,a^2,a^3,\cdots,a^{n+1}\in G$，则必定存在$a^i&#x3D;a^j,1\leq i &lt; j \leq n+1$。<br>那么存在$k&gt;0$，令$a^i \cdot a^k &#x3D; a^j$，则$a^i \cdot a^k &#x3D; a^i$，连续左乘$a$，则有$a^p\cdot a^k&#x3D;a^p,p&#x3D;qk$，递归调用，得到$a^p&#x3D;a^p\cdot a^p$。</p><h1 id="2-一些定理-证明省略"><a href="#2-一些定理-证明省略" class="headerlink" title="2.一些定理(证明省略)"></a>2.一些定理(证明省略)</h1><ol><li>四阶群无三阶元。</li><li>左陪集彼此等阶，左右陪集彼此等阶，也就是说，陪集彼此等阶。</li><li>六阶群必有三阶元。（由$Lagrange$定理推导得到）</li><li>阶小于等于5的群为阿贝尔群。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学/概率论】备忘</title>
      <link href="/2022/10/16/gai-lu-lun-chang-yong-jie-lun-bei-wang/"/>
      <url>/2022/10/16/gai-lu-lun-chang-yong-jie-lun-bei-wang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>未特别说明，$f_X(x)$代表$X$的概率密度，$F_X(x)$代表$X$的分布函数。</p></blockquote><h1 id="1-公式法求随机变量关系"><a href="#1-公式法求随机变量关系" class="headerlink" title="1.公式法求随机变量关系"></a>1.公式法求随机变量关系</h1><p>对于一维随机变量：</p><p>已知$f_X(x),Y&#x3D;g(x)$，求$f_Y(y)$:<br>$$<br>f_Y(y)&#x3D;f_X(h(y))|h’(y)|<br>$$<br>其中$h(y)$是$g(x)$的逆函数。</p><p>对于二维随机变量，可以使用卷积公式(Convolution)计算：</p><p>已知<font color="red">$X,Y$独立</font>,$Z&#x3D;X+Y$，求Z的分布函数：</p><p>$$<br>f_Z(z)&#x3D;\int_{-\infty}^{\infty}f_X(x)f_Y(z-x)dx&#x3D;\int_{-\infty}^{\infty}f_X(z-y)f_Y(y)dy<br>$$</p><p>不独立要用分布函数法求解。</p><h1 id="2-指数分布-Exponential-Distribution"><a href="#2-指数分布-Exponential-Distribution" class="headerlink" title="2.指数分布(Exponential Distribution)"></a>2.指数分布(Exponential Distribution)</h1><p>$$<br>X\sim E(k)\to f_X(x)&#x3D;ke^{-kx},F_X(x)&#x3D;1-e^{-kx}<br>$$</p><h1 id="3-均匀分布-Uniform-Distribution"><a href="#3-均匀分布-Uniform-Distribution" class="headerlink" title="3.均匀分布(Uniform Distribution)"></a>3.均匀分布(Uniform Distribution)</h1><p>$$<br>X\sim U(a,b)\to f_X(x)&#x3D;\frac{1}{b-a},F_X(x)&#x3D;\frac{x-a}{b-a},x\in[a,b]<br>$$</p><h1 id="4-正态分布-Normal-Distribution"><a href="#4-正态分布-Normal-Distribution" class="headerlink" title="4.正态分布(Normal Distribution)"></a>4.正态分布(Normal Distribution)</h1><p>$$<br>X\sim N(\mu,\sigma^2)\to f_X(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},F_X(x)&#x3D;\int_{-\infty}^{\infty}f_X(x)dx<br>$$</p><p>特别的，正态分布满足再生性（可加性），亦即，当$X,Y$彼此独立时：</p><p>$$<br>X_1\sim N(\mu_1,\sigma_1^2),X_2\sim N(\mu_2,\sigma_2^2),\cdots,Z&#x3D;\Sigma_{i&#x3D;1}^nX_i\to Z\sim N(\Sigma_{i&#x3D;1}^n\mu_i,\Sigma_{i&#x3D;1}^n\sigma_i^2)<br>$$</p><p>其实，两个正态分布相加，$\mu$和$\sigma^2$彼此相加，两个正态分布相减时，$\mu$的部分相减，而$\sigma^2$的部分依然要相加。</p><h1 id="5-泊松分布-Poisson-Distribution"><a href="#5-泊松分布-Poisson-Distribution" class="headerlink" title="5.泊松分布(Poisson Distribution)"></a>5.泊松分布(Poisson Distribution)</h1><p>$$<br>X\sim P(\lambda)\to P(X&#x3D;k)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}<br>$$</p><p>特别的，泊松分布满足再生性（可加性），亦即，当$X,Y$彼此独立时：</p><p>$$<br>X\sim P(\lambda_1),Y\sim P(\lambda_2),Z&#x3D;X+Y\to Z\sim P(\lambda_1+\lambda_2)<br>$$</p><p>泊松分布可以用来近似求取二项分布，如果$X\sim B(n,p),n\geq 20 ,p\leq 0.05$，可以近似为$X\sim P(np)$。</p><h1 id="6-排列组合备忘"><a href="#6-排列组合备忘" class="headerlink" title="6.排列组合备忘"></a>6.排列组合备忘</h1><h2 id="分组公式"><a href="#分组公式" class="headerlink" title="分组公式"></a>分组公式</h2><p>一共$n$个物品，分成$k$组，每组个数为$r_1,r_2,\cdots,r_k$，那么全部的互异排列方式$N$为：<br>$$<br>N&#x3D;C_n^{r_1}C_{n-r_1}^{r_2}\cdots C_{r_k}^{r_k}&#x3D;\frac{n!}{r_1!r_2!\cdots r_k!}<br>$$<br>一个题目里，如果对有重复出现的所有元素的排列，可以看作为分组排列，相同的元素分为一组，应用上述公式即可。</p><h1 id="7-常用分布的期望、方差"><a href="#7-常用分布的期望、方差" class="headerlink" title="7.常用分布的期望、方差"></a>7.常用分布的期望、方差</h1><table><thead><tr><th>分布类型</th><th>数学期望</th><th>方差</th></tr></thead><tbody><tr><td>$X\sim B(n,p)$</td><td>$np$</td><td>$np(1-p)$</td></tr><tr><td>$X\sim U(a,b)$</td><td>$\frac{a+b}{2}$</td><td>$\frac{(b-a)^2}{12}$</td></tr><tr><td>$X\sim E(\lambda)$</td><td>$\frac{1}{\lambda}$</td><td>$\frac{1}{\lambda^2}$</td></tr><tr><td>$X\sim N(\mu,\sigma^2)$</td><td>$\mu$</td><td>$\sigma^2$</td></tr><tr><td>$X\sim P(\lambda)$</td><td>$\lambda$</td><td>$\lambda$</td></tr><tr><td>$X\sim G(p),P(X&#x3D;k)&#x3D;p(1-p)^{k-1}$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>$X\sim \chi^2(n)$</td><td>$n$</td><td>$2n$</td></tr></tbody></table><h1 id="8-切比雪夫不等式和中心极限定理"><a href="#8-切比雪夫不等式和中心极限定理" class="headerlink" title="8.切比雪夫不等式和中心极限定理"></a>8.切比雪夫不等式和中心极限定理</h1><h2 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h2><p>$$<br>P(|X-E(X)|\geq\varepsilon)\leq\frac{D(X)}{\varepsilon^2}<br>$$</p><h2 id="林德伯格-莱维中心极限定理"><a href="#林德伯格-莱维中心极限定理" class="headerlink" title="林德伯格-莱维中心极限定理"></a>林德伯格-莱维中心极限定理</h2><p>如果随机变量序列$X_1,X_2,\cdots,X_n,\cdots$<strong>独立同分布</strong>，并且具有<strong>有限的期望、方差</strong>，分别记为$\mu,\sigma^2(&gt;0)$，则对于$\forall x\in \mathbf{R}$有：<br>$$<br>\lim_{n\to\infty}P(\frac{1}{\sqrt{n}\sigma}(\sum_{i&#x3D;1}^nX_i-n\mu)\leq x)&#x3D;\int_{-\infty}^x\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}\rm{d}t&#x3D;\varPhi(x)\sim N(0,1)<br>$$</p><h2 id="棣莫佛-拉普拉斯定理"><a href="#棣莫佛-拉普拉斯定理" class="headerlink" title="棣莫佛-拉普拉斯定理"></a>棣莫佛-拉普拉斯定理</h2><p>设在$n$重伯努利试验中，成功的次数为$Y_n$，而在每次试验中成功的概率为$p,q&#x3D;1-p$，则对于$\forall x\in \mathbf{R}$有：<br>$$<br>\lim_{n\to\infty}P(\frac{Y_n-np}{\sqrt{npq}}\leq x)&#x3D;\int_{-\infty}^x\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}\rm{d}t&#x3D;\varPhi(x)\sim N(0,1)<br>$$</p><h1 id="9-矩估计和最大似然估计"><a href="#9-矩估计和最大似然估计" class="headerlink" title="9.矩估计和最大似然估计"></a>9.矩估计和最大似然估计</h1><p>矩估计的原理是用n阶样本矩来估计总体矩。因为在样本充分大的时候，样本矩和总体矩相等。解题步骤：</p><ol><li>若有$k$个参数要估计，则列出前$k$阶样本中心矩的算式。</li><li>求解参数。</li></ol><p>最大似然估计的原理是根据发生的概率公式，求出令该公式最大的参数。解题步骤：</p><ol><li><p>列出概率公式，若有$n$个样本，概率公式就是：<br>$$<br>L&#x3D;\prod_{i&#x3D;1}^n f(x_i;\theta_1,\theta_2,\cdots)<br>$$</p></li><li><p>求出让$L$最大的参数$\theta_1,\theta_2,\cdots$。可以通过求$lnL$-求导求解，也可以直接根据原理求解。</p></li></ol><h1 id="10-区间估计的枢轴变量法"><a href="#10-区间估计的枢轴变量法" class="headerlink" title="10.区间估计的枢轴变量法"></a>10.区间估计的枢轴变量法</h1><p>对于正态总体$X\sim N(\mu,\sigma^2)$，取出$n$个样本，样本均值为$\bar{X}$，方差为$S^2$，那么可靠性为$\beta$的$\mu,\sigma^2$置信区间为：<br>$$<br>\mu\in(\bar{X}-t_{(1-\beta)&#x2F;2}(n-1)\frac{S}{\sqrt{n}},\bar{X}+t_{(1-\beta)&#x2F;2}(n-1)\frac{S}{\sqrt{n}})\<br>\sigma^2\in(\frac{(n-1)S^2}{\chi^2_{1-\beta&#x2F;2}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-(1-\beta)&#x2F;2}(n-1)})<br>$$</p><h1 id="11-数理统计部分备忘"><a href="#11-数理统计部分备忘" class="headerlink" title="11.数理统计部分备忘"></a>11.数理统计部分备忘</h1><ol><li><p>如果$X,Y$彼此独立，$X\sim N(0,1),Y\sim\chi^2(n)$，那么$T&#x3D;\frac{X}{\sqrt{Y&#x2F;n}}$。</p></li><li><p>如果$X,Y$彼此独立，$X\sim\chi^2(n_1),Y\sim\chi^2(n_2)$，那么$F&#x3D;\frac{n_2}{n_1}\frac{X}{Y}$。</p></li><li><p>如果$X\sim t(n)$，那么$X^2\sim F(1,n)$。</p></li><li><p>若样本总体$X$满足$X\sim N(\mu,\sigma^2)$，若$n$为样本容量，样本方差为$S^2$，样本均值为$\bar{X}$，则满足：<br>$$<br>\bar{X}\sim N(\mu,\frac{\sigma^2}{n})\<br>\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)\<br>\frac{\sqrt{n}(\bar{X}-\mu)}{S}\sim t(n-1)\<br>\frac{\sqrt{n}(\bar{X}-\mu)}{\sigma}\sim N(0,1)\<br>$$</p></li></ol><h2 id="单个正态总体的参数区间估计"><a href="#单个正态总体的参数区间估计" class="headerlink" title="单个正态总体的参数区间估计"></a>单个正态总体的参数区间估计</h2><ol><li><p>$\sigma$已知，求$\mu$置信区间：<br>$$<br>(\bar{X}-u_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}},\bar{X}+u_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}})\to1-\alpha<br>$$</p></li><li><p>$\sigma$未知，求$\mu$置信区间：<br>$$<br>(\bar{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}},\bar{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}})\to1-\alpha<br>$$</p></li><li><p>$\mu$已知，求$\sigma^2$置信区间：<br>$$<br>Q^2&#x3D;\sum_{i&#x3D;1}^n(X_i-\bar{X})^2\<br>(\frac{Q^2}{\chi^2_{\frac{\alpha}{2}}(n-1)},\frac{Q^2}{\chi^2_{1-\frac{\alpha}{2}}(n-1)})\to1-\alpha<br>$$</p></li><li><p>$\mu$未知，求$\sigma^2$置信区间：<br>$$<br>Q^2&#x3D;\sum_{i&#x3D;1}^n(X_i-\mu)^2\<br>(\frac{Q^2}{\chi^2_{\frac{\alpha}{2}}(n-1)},\frac{Q^2}{\chi^2_{1-\frac{\alpha}{2}}(n-1)})\to1-\alpha<br>$$</p></li></ol><p>上面的方法也可以利用于假设检验中去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【意识流】“啤酒-炸鸡-愤世嫉俗”情感障碍</title>
      <link href="/2022/10/13/yi-shi-liu-pi-jiu-zha-ji-fen-shi-ji-su-qing-gan-zhang-ai/"/>
      <url>/2022/10/13/yi-shi-liu-pi-jiu-zha-ji-fen-shi-ji-su-qing-gan-zhang-ai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>炸鸡是被子，啤酒是枕头，愤世嫉俗是梦。——我自己说的，对，我自己说的。<br>愤世嫉俗好像用得不太好，我想不出替代词了（欸嘿！<br>你欸嘿个头哇！</p></blockquote><p>越来越觉得自己的脑子就是一个垃圾场，里面什么都有，又什么都没有。我觉得我以后难以适应这个世界的节奏。</p><p>我的脑子里是：白日梦、荷尔蒙过剩衍生出的欲望、残缺不全的哲学家们的理论、压根没学明白的那些专业知识……这些东西就像没下载完的文件一样，除了占空间之外什么用也没有。唉，罢了罢了！</p><p>孤独感从我内心深处涌上来，如同呕吐物一样（虽然我并没呕吐，也没喝醉），让我打了个寒战。有的时候，那种茕然一身的感觉会突然给我一记重拳，但是当我回过神来，想要对付它时，它又消失在我的大脑深处了。唉，真搞不懂呀！这就是所谓的“自由意志”吗？意志自由地来，又自顾自地走掉了。</p><p>我的耳机里放着歌：</p><blockquote><p>无始无终的 灯火通明的，<br>特别大声吼出一句别人的歌词，<br>却也很难唱出自己写的歌词，<br>这所获得的一切，<br>都是购买力驱使下 一场场春梦。<br>它们 它们 它们，<br>从未变成过佛祖眼中的万重山，<br>万重山 万重山 万重山 万重山！</p></blockquote><p>啊呀呀！啊呀呀！没什么用。不做春梦，干什么呢？我现在觉得理想已经没什么意思了。我的内心还保有着理想的火苗，但我知道它没办法点亮这个世界。它是我的所有物——“人类为更高的事业效劳吗？否，人类只看到自己，人类只想使人类发展：人类自身即是它的事业”——哈哈，他们只想使他们发展，他们自身即是他们自己的事业！而他们有万千拥趸。恢弘的现实讽刺剧——21世纪-1812！闭嘴！你可别说话了。</p><blockquote><p>他们是疯子我也是疯子我同它们没什么两样或许现在疯狂才是正常或许疯狂不过是保护机制罢了。</p></blockquote><p>Ich bin eine Maus, eine klein Maus!我是一只老鼠，一只小小的老鼠。老鼠是动物，脑许是庸俗者的呓语。消费主义戕害着人们，话都这么讲，人们一听到消费主义就觉得那是坏的，要打倒……可转眼间，又沉迷于消费主义编造出来的幻境中去了。我沉迷在里面，您大概也一样吧。</p><p>坏了，误触到C-w键了，得重写了。</p><p>我没什么社交能力，又不会做项目。哎呀！我同别人沟通都有点困难。以后要怎么在社会上工作呢？（其实到时候就有办法了）我没什么大志向，平平淡淡过完一辈子就好了。我在很多方面都要比同龄人幼稚，而我也无力改变这点。我一直比别人慢几步，而我，也懒得去追赶他们了。前面有人，我还知道该往哪里走，如果前面一个人都没有，我可就要迷茫起来啦！我不愿意为自己戚戚然……</p><p>听说梅子酒和牛奶调到一起喝，会有优酸乳的味道。梅子酒倒没买过，但是啤酒和牛奶一起喝肯定不好喝。不过和可乐混到一起倒不错，有种巧克力&#x2F;Old fashion的味道。而且喝啤酒的时候，不要吃太甜的东西，会把啤酒的本味盖住，幻尝试几次，发现咸食配啤酒不错。不得不说，盐还是很厉害的，提鲜，增加甜味……用处多得很啊。（2022&#x2F;10&#x2F;16：捏麻麻滴！梅子酒（我买的是梅见）和牛奶混在一起难喝得要死，和汽水一起做highball很好喝，做highball的话，梅子的酸味会被浸提出来，梅子本身的味道也会更突出一些，直饮梅子酒会有点冲。若有缘，我可以调给诸君喝。）</p><p>未来，哎呀，未来！我崇拜那些有着深刻理想的人，他们坚定地走在道路上。也许经年之后地某个夜里，我会突然怪罪起年轻时的自己来。到时候一切都晚了。我是母亲的痛苦，是父亲的冷漠，是……是……，……。徒有夜风从荒芜的大地上吹过。</p><p>我喜欢日本和韩国的作家，读了这么多书，到头来还是喜欢日本的作家。伊坂幸太郎的摇滚与昂扬，太宰治的讽刺和忧郁，韩江的想象力与张力……他们的作品总会给我情感上的影响。其实要是细细追究起来，翻译者们也很厉害，给我的情感上的影响，一半是作者给的，另一半就是翻译者给的。</p><blockquote><p>其二，二次元少女是一连串（successive chain）的理想造物（idealization-production）分泌的恶液（pus）滴落在资本主义的皮肤（capitalist hide）上的结果，也是虚拟恶液的预定采集物（inevitable harvesting）。换言之，祂们是理想的印象的影像（images of images of images），是一个从“少”和“女”上的理想夸张而来的超影像，被扭曲为实在人类的理解范围的远距外，并如同一种原始器官（raw organ）植入社会的身体那样植入了资本主义。</p></blockquote><p>怎么说呢？二次元的少男少女通过“逃逸线-解域-再结域”摆脱了自身的性别建构，以传统的男女性别建构而言，少男的阴柔性、少女的活跃性都是“不合时宜的”。二次元的少男少女身份同Gen Z的性别身份靠近：男性开始追求女性气质，女性也开始寻求男性气质。这是好的，有利于“生成”的。而同样，二次元少男、少女也是媚俗的，满足了男性和女性的性欲投射，他们是公用的卵巢和睾丸。我也是个媚俗之人。互联网将现实中的压抑转变为恶性，加倍放大。资本主义给予我们压抑，又构造出了相应的发泄渠道。（2022&#x2F;10&#x2F;17：？你在说什么啊？）</p><p>“人和人彼此相连”。</p><p>我写的这篇文章，您从哪里开始读都没问题哦。您大可以把这些自然段打乱，再随意地拼起来，照样也是一篇博文。这篇博文和我的思想一样，断断续续，破破碎碎。我用了很奇怪的行文方法。这个文章可以无穷尽地被写下去。但是就到这里吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【意识流】我们终将死亡</title>
      <link href="/2022/10/01/yi-shi-liu-wo-men-zhong-jiang-si-wang/"/>
      <url>/2022/10/01/yi-shi-liu-wo-men-zhong-jiang-si-wang/</url>
      
        <content type="html"><![CDATA[<p>我坐在火车上，窗户被封死了，什么也看不见。车厢里的灯忽明忽暗，灯罩内侧有虫子的尸体。桌子是白色的，磨砂桌面，上面杂乱摆放着几张信封。我拿起一个信封，从口袋里拿出小裁刀，将信封拆开来，发现里面什么也没有。</p><p>我有些迷惑。</p><p>我看了看收件人，的确是我，寄件人的信息却被涂掉了。邮票也没粘。</p><p>我放下了信件，坐着。任凭自己的肉身和火车同步震动。</p><p>我要去哪里？</p><p>火车停了下来，震动也消失了。</p><p>我听见有人在尖叫，有人在大笑，有枪声响起。</p><p>一切又回归寂静，火车又启动了。</p><p>奇怪得很。</p><p>车厢的门打开，一个蓬头垢面的人上了车，抓住我的肩膀，说出了一大堆我听不懂的话，像是疯癫之人的癔语：</p><p>“你应该逃出这里，这里什么都没有，什么都没有！哈哈！你应该思考，是这样嘛，是这样嘛？这一切都荒唐地可笑。”</p><p>他瞟见了我的信封：</p><p>“我是神，是神！这些信是我写给你的，而我又不是神！你个傻子，居然对着空空的信封若有所思，哈哈哈哈哈哈哈哈哈哈……不要思考，只管体会这样的世界！欸……你应该思考，你不应该……”</p><p>他沉默了一会，说了句：</p><p>“你知道这一切都是怎么回事。人们叫你坐在车上，去一个你根本不认识的地方。这有意义吗？”</p><p>又有两个大汉上了车，穿着警察制服，将这个疯男人拉走，“对不起，先生，祝您旅程愉快”。</p><p>车厢门彭的一声关上了。</p><p>我听见有人在尖叫，有人在大笑，有枪声响起。</p><p>一切又回归寂静，火车又启动了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【意识流】虚无的凭依</title>
      <link href="/2022/10/01/yi-shi-liu-xu-wu-de-ping-yi/"/>
      <url>/2022/10/01/yi-shi-liu-xu-wu-de-ping-yi/</url>
      
        <content type="html"><![CDATA[<p>钢铁列车飞速向前，前面是一堵厚重的水泥墙，封闭着黄色的氯化铀酰和三硝基甲苯。列车上的人们嚎叫着庆祝着大笑着时代的巅峰，偶有哀叹的声音在刹那的死寂中回响，而又淹没在下一刻的呼喊声中。</p><p>人们团结起来，成为家庭，成为社团，成为民族，成为国家，自以为是宇宙中的最强者。他们病态地歌唱，用反智主义的歌声撕破时代的寂静。</p><p>金钱、纵欲、知识焦虑、外貌焦虑和内卷正摧毁我们，摧毁我们的时代，摧毁我们的思想和意志。我们用酒精、电子产品甚至甲基苯丙胺来逃避这一切。</p><p>列车上的人们大笑着，滥交的少男少女、将死的老妪、满口谎话的名流，都大笑着，庆幸自己成为公式末尾的余项。驾驶舱里没有司机，没有刹车，没有窗户，没有灯光，没有速度表，没有无线电，什么也没有。</p><p>他们在飞舞的啤酒沫里做爱，谈论政治，脱光了衣服跳舞，撕毁几百年前的油画，烧毁书籍唱片电影胶卷，清醒地沉睡着，吵闹地沉默着。他们将粪便、腐肉、烧焦的电线、空酒瓶投向车外。</p><p>他们辱骂者梦想家、求学者以及向往自由的人，想要将他们变成疯狂的奴隶，这些奴隶了无思考能力。</p><p>他们将双重思想发挥到极致，自由而保守，严肃而疯狂，愚蠢而聪明。他们是这个时代的栋梁。蒲鲁东、亚当斯密、列宁都没有他们强大！Kamisama！Kamisama！Servate me！</p><p>他们在白天睡去，在夜晚追求光明；在沙漠里崇尚太阳，在冰原里崇拜林德；在生命中崇尚死亡，在临终时渴望生存……矛盾？同一！</p><p>安那其、反社会、冲锋枪……时代的病症消解了意义，他们自由了，却又逃避自由，自由是虚无，又不该是虚无……他们终将用极端的方式解决这一切……</p><p>他们是谁？任何人？一部分人？哦……又或许不是任何人，不是任何物，只是一种意志，一种精神，一种难以言说的痛苦，一种早已消亡的真正精神？荣格先生你好。</p><p>他们用碾核、出轨、暴力漫画、挥金如土、自残、自杀、赌博、色情、脏话、自我标榜、长岛冰茶、尼格罗尼、电子游戏、梅毒、艾滋病、棒球棒来脱离现实，沉浸在幻觉里。但是这幻觉终究要消亡，成为后来者的笑话。但是这笑话也暗示着后来者的命运。</p><p>太快了，太快了，太快了，太快了。</p><p>列车装上水泥墙，爆炸，人们的血肉同钢铁混杂在一起，偶有低沉的、快乐的、神经质的呻吟声在废墟中响起。这个时候不再有国界，不再有利益之争，不再有工业，不再有文学，不再有思考，不再有虚无，这世界在列车毁灭之际迎来了自己的安宁！迎来了一切意义的消亡！这世界返回了它的本真！</p><p>经年之后又会有新一批的大脑不健全的猿猴进化为人类，创建文明，研究科学，撰写书籍，发射火箭，他们会带着各式各样的行李走上火车，希望前往一个更好的明天。他们将大笑，他们将欢呼，他们将尖叫，他们将继续滥交，他们将自诩为文明人继续生活在世界上！然后火车会装上另一堵墙——爆炸——血肉混杂！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【诗】雨</title>
      <link href="/2022/10/01/shi-yu/"/>
      <url>/2022/10/01/shi-yu/</url>
      
        <content type="html"><![CDATA[<p>我看见雨点击打铁皮屋顶，<br>像是时间之锤砸在命运的鼓上，<br>震动生者的心灵，<br>令他们在此刻向远古眺望——<br>那里空无一物，只有雨。</p><p>人们反抗一切，痛恨一切，<br>而雨冲尽了一切鲜血。<br>这一切都是循环，<br>一切秩序都将在雨中腐朽紊乱。</p><p>捂起耳朵，朋友，<br>雷声将在四周响起，<br>闭好眼睛，朋友，<br>闪电将把世界穿击。</p><p>在这场雨中，一切都将被隐匿，<br>没有爱，没有梦，没有世界的呼吸，<br>只有雨声，永远淋漓着的雨，<br>浇灭了智慧生物残存的思绪。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【意识流】先知</title>
      <link href="/2022/10/01/yi-shi-liu-xian-zhi/"/>
      <url>/2022/10/01/yi-shi-liu-xian-zhi/</url>
      
        <content type="html"><![CDATA[<p>酗酒的男人在隔壁打鼾，孤独的老者在楼上叹息，也许是楼下，或者这些声音只存在于我的脑海里——我不知道，各种声音将我拖入灰暗。床对着的墙上有一大块水渍，墙皮开裂，地板上散落着一些白灰。窗子开着，灰色的帘子被风吹动，一股汽车尾气的味道。轮胎碾过水泥地面，哗啦哗啦。</p><p>我房间里的灯没有开，它没有必要是开着的。我打开手机，左肩有些痛，凌晨三点。</p><p>盯着空白的天花板，我开始思考——人活在这个世界上不就是为了思考的吗。我看着自己的思想流动在房间里——那是白色的一道光，它照亮了整个房间，就像烛火在熄灭前一瞬的跳闪。我为什么而活？我最后会成为什么样的人？我一直弄不懂这些问题。</p><p>我站起身，走到窗前。对面的大楼一片黑暗，我恍惚间看见了无数人站在楼顶，拄着栏杆，向远方眺望。不，那里什么也没有。说真的，我为什么要站起来，明明闭上眼睛就可以沉睡在梦里，挨到早晨的。或许我害怕梦……我其实看不见远方，太黑了，嘿嘿。</p><p>我想尖叫，我想冲着微薄的噪音大吼，我想用喊声驱赶这令人不安的寂静。不，我臣服于这死寂，我同这死寂无异，都是虚无……酒精，我羡慕起那个打鼾的男人了，我也许找点酒来喝。或许又不该……算了，我就在这站一会吧。</p><p>我的屋子亮如白昼。所有人都是幸福的。我知道，等到天亮之后，我将失去悲观的权利，人们期待着一个美好的世界，而不会关心这个世界是否是真实的。深夜的冷风吹不醒那些关紧窗子的人，而那些大开窗户的人，根本睡不着觉。</p><p>狂热的火吞没了一切，而人们的内心却是寒冷的，倒也不能说寒冷，只能说是他们自以为内心是炽热的，其实那里空无一物。所谓信仰，不过是人们撒的谎罢了，他们没有学识，所以需要用绳子把自己捆在这个世界上。而这个世界又有些什么东西呢？他们会把自己吊死的。</p><p>天黑魆魆的，我什么也看不见。距离日出还有很久，我却了无睡意。似乎男人翻了个身，似乎老人也陷入了短暂的平静里。这个世界上，我们都是孤独得不能再孤独的个体，而我们也不再有机会回到过去。话说，过去是什么时候？是童年，是远古，还是……我不知道。</p><blockquote><p>我是矛盾的笑话，我是懦弱的革命家，我是阴暗小巷里的呕吐物，我是工地上飘扬的尘沙。<br>我是燃尽的烟头，我是沉没的孤舟，我是流动的尿液，我是残破不堪的矮楼。<br>我是被人追杀的噩梦，我是冬季深夜的寒冷，我是泔水桶里的霉菌，我是烟花绽放后带着火药味的风。</p></blockquote><p>官僚主义的光芒在大地上闪烁，人们在这光芒中崇敬着自己的神。他们自诩拥有神力，屠杀那些所谓的“异教徒”。话说回来，神和人又有什么分别呢？或许，天堂也同人间无异，有些神甚至奉人类为神明。我不信神，我不信任何事物。失去信心的人只有两条路可以走：走向神秘主义或者走向享乐主义。神秘主义？悲伤会让人的注意力完全封锁在内部，而悲伤的人若无法从他的内在获得解决方法，他将不得不向所谓更高级的存在索取援助之手。享乐主义？你知道的，在有预料的死亡之前，很多人会选择挥霍掉拥有的一切，生不带来，死不带去。哦，不对，我说的是官僚主义。我究竟在思考什么，没有主题！</p><p>有人在远方吹了声口哨。有人在吃吃地笑着。那些嬉皮士——精神小伙？现在人是这样称呼他们的吧——是快乐的。</p><p>权力的集中必然导致官僚主义，不论是集中在某个人手里，还是某个小团体手里，这都是很危险的事情。没有人去监督它们——或者说监督了，但是没有力量去改变它。所以说，我痛恨威权主义者们，而他们被称作社会的顶梁柱、当下的最优解。我对着窗外吐了口唾沫。民族、国家发展到这样的程度，自由的社会是不可能被创造出来的，理想主义者在文明刚刚起步的时候就死透了。</p><p>我真的觉得，一死百了，实在是有意思。在这世界上苟且偷生，我不太稀罕。但是啊，话是这么说，总有什么东西在阻拦着我……本能？大概吧。我其实没有下定决心呢！话说啊，死是睡的兄弟，如果睡着的时候人是幸福的，那么死亡之后也是一样吧。</p><p>所以，我在等待什么，未来不也是这样——在凌晨醒来，不切合实际的思考，吃饭睡觉，毫无意义。人们始终在告诉我该做什么，应该怎样做，但是，这些真的是毫无用处。他们，包括我，从来没有审视过这些观点。我们被塑造成了“人”。</p><p>我们已经走到了尽头。</p><p>我听见有一个声音在我脑中响起：先生，这些都是毫无意义的。你的思考，浅薄且幼稚……是的，如果思考会化作文字落在纸上，我想我会划去前文，甚至将纸撕得粉碎。但是，思考是无形的，只能被忘记。我想在这里止步，各种意义上的，我对自己没有信心，对未来也是失望至极。我想去坦然面对未来，享受人生，但是我没有这个胆量，我也没有这个实力，只能一天一天地熬日子。</p><p>话说，有几个人会像我这样颓废呢？他们都有梦想，哪怕他们会在夜里黯然神伤，白天仍然是努力着的，他们在奋斗的路上坚定地前行。而我，我的人生已经陷入了一个死循环。</p><p>我想不通。我期待着小说的结局。我听见有人在呼唤着我。或许那个人是昨天的我，也可能是未来的自己。</p><p>我想睡觉了，晚安。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 意识流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂谈】政治正确、狂热和异教徒</title>
      <link href="/2022/10/01/za-tan-zheng-zhi-zheng-que-kuang-re-he-yi-jiao-tu/"/>
      <url>/2022/10/01/za-tan-zheng-zhi-zheng-que-kuang-re-he-yi-jiao-tu/</url>
      
        <content type="html"><![CDATA[<p>人们的思想逐渐变得狂热而浅薄。</p><p>政治正确的风潮正在席卷整个世界，这很有意思。伏尔泰有一句话这样讲，“我不同意你的说法，但我誓死捍卫你说话的权利！”，这是启蒙运动的一个缩影，而启蒙运动令人类世界进入了一个光辉的时代。而现在，人们在逐渐剥夺他人存在异见的权利，也就是说，主流的、权威的、固化的思想再一次地占据了高地。人们不再去尝试理解别人，不再去理性看待别人的观点——虽然，大多数人根本不具有理性思考的能力。思想在逐渐趋同，逐渐固化。我们回到了过去，回到了十八世纪之前。</p><p>对于国家和民族的认同，正在驱使人们去“仇恨未曾相识的人们”。这很讽刺，自信演变成了自负。人们逐渐变得狂热，他们觉得任何符合本民族利益的事物都是正确的，他们会感动自己，认为自己担负着无比重要的使命，他们会将充满仇恨的目光撒向遥远的地方……狂热，是大部分祸患的开始。</p><p>人是时代的镜像，我一直这么想。我没有办法不去考虑这个时代，似乎我对于这个时代的思考要远多于对于我自身的思考。我亲眼所见，人们之间的关系变得越来越功利，越来越复杂。我不能理解这些事情，或者说：我在一定程度上理解这些事情，但我无法改变这一切。我对这世界失望，也对我自己失望；我几乎同等地仇视他人，正如我仇视我自己一样。我似乎只靠本能存活在这个世界上，如何去对外界刺激作出反应，似乎并不受我的理性控制。我是具有智慧的行尸走肉。</p><p>我希望毫无意识地、毫无痛苦地离开这个世界，那一天来得越早越好。但是，我又对未来抱有一点好奇心，我想看看这世界的荒诞，将会发展成什么样子。</p><p>我不忧虑未来，因为我知道未来会是更加荒诞的。理想主义者们会死去，他们的遗体，他们的书籍，他们的一切存在痕迹都将被抹杀。人们会像掰断一根粉笔一样折断他们的脊骨。这个世界没有给理想主义者的安身之所。为什么呢？因为他们的思想将与大众的思想相背离。而人们，向来对异己者有一种自然而然的仇恨。</p><p>在狂热的声浪里，他们将会被视作异教徒，被无情地撕碎，被污名化。如果运气够好，他们就能实现理想了吗？理想是敌不过利益的，他们的事业将会被别有用心者窃取。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【诗】幻想</title>
      <link href="/2022/10/01/shi-huan-xiang/"/>
      <url>/2022/10/01/shi-huan-xiang/</url>
      
        <content type="html"><![CDATA[<p>这个世界只有她完美无瑕，<br>我的爱人，我的爱人，她——<br>在海边向远方眺望，<br>暖风轻抚她绯红的面颊。</p><p>飞鸟掠过天际线，<br>帆船的暗影在她的眼中荡漾，<br>我的爱人在大海的彼方，<br>伫立，直到冷风吹来黑暗的夜晚。</p><p>水晶从洁白的月光里坠落，<br>繁星在环形的死海里闪烁，<br>我的爱人，我的爱人，她——<br>在遥不可及的彼岸等着我……</p><p>可是我将一切都失掉了，<br>如同路西法从天堂坠落，<br>孑然一身徘徊在地狱中，<br>仰望人间庶民们的欢乐。</p><p>我的身体被世间的烈火焚烧，<br>我的精神被时代的阳具强暴。<br>我不相信一切，正如一切不相信我一样——<br>当初，人们自说自话将这个世界创造。</p><p>我将在黎明时分登上帆船，<br>在午夜回到经年未归的彼岸。<br>我的爱人，我的爱人——<br>若你我再次相见，<br>你还会认出我吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学】那些有趣的证明（持续更新）</title>
      <link href="/2022/09/25/shu-xue-na-xie-qi-qi-guai-guai-de-zheng-ming/"/>
      <url>/2022/09/25/shu-xue-na-xie-qi-qi-guai-guai-de-zheng-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="1-证明-sqrt-2-不是有理数"><a href="#1-证明-sqrt-2-不是有理数" class="headerlink" title="1.证明$\sqrt{2}$不是有理数"></a>1.证明$\sqrt{2}$不是有理数</h1><p>假设$\sqrt{2}$是有理数，根据有理数的定义，它可以被写成$\frac{p}{q}$的形式，将之平方，有：</p><p>$$</p><p>2 &#x3D; \frac{p^2}{q^2} \to p^2&#x3D;2q^2</p><p>$$</p><p>推出$p$为偶数，根据偶数的定义，$p&#x3D;2k$，那么代入上式，$q^2&#x3D;2k^2$，q也是偶数。这就是说：如果$\sqrt{2}$是偶数的话，$p$，$q$必须全是偶数，但是，如果对$\frac{p}{q}$约分的话，必定出来至少一个奇数，矛盾了。得证。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【诗】乱码</title>
      <link href="/2022/09/21/shi-luan-ma/"/>
      <url>/2022/09/21/shi-luan-ma/</url>
      
        <content type="html"><![CDATA[<p>精神病人的呓语被奉为真理，<br>自由的光消失在黑暗山洞的深处。<br>酒精、叹息、自杀，成为我们最后的回应，<br>我们正挖掘着自己的坟墓。</p><p>太阳早就下山了，朋友！<br>月亮被乌云遮住，漏不出一点光芒，<br>当血味夜风吹拂的时候，<br>就会有人迎来自己的死亡。<br>这不是预言——<br>这是真理。</p><p>虚假的报文，裹着有毒的糖衣；<br>真实的未来，生着苦涩的面目。<br>生死无主，<br>黄色的脑浆盖住画满花朵的墙壁。</p><p>时代的利刃，斫出致命的伤口；<br>自由的眼泪，却唤不醒任何人。<br>沾满鲜血的手——<br>他人的妻儿在无形的刀下骨肉齑粉。</p><p>我们该携手吗？<br>我们该携手吗？<br>追求自由者的尸体在臭水沟里漂浮，<br>手持束棒者的声音在屠宰厂里放大。</p><p>我们在时代交界处奔跑，<br>我们在漆黑的夜里燃烧，<br>我们在将死之日寻求母亲的味道，<br>我们在皮开肉绽之时放声大笑。</p><p>你我终将在春风里相见——<br>至少我希望如此。<br>我们要同现实苦苦地鏖战，<br>不能让信念徒然地死。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂谈】如何申请Github Education Pack和相关产品</title>
      <link href="/2022/09/17/github-education-pack/"/>
      <url>/2022/09/17/github-education-pack/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="为什么要申请？"><a href="#为什么要申请？" class="headerlink" title="为什么要申请？"></a>为什么要申请？</h1><p>白嫖不香吗？而且，pack里提供了许多实用的工具和学习平台。</p><p>Pack里面包括什么，可以参考下面的文章：</p><p><a href="https://education.github.com/pack?utm_source=github+jetbrains">GitHub Student Developer Pack</a></p><p>中文翻译：</p><p><a href="https://zhuanlan.zhihu.com/p/422881276">Github学生开发包都有什么？（开发和设计工具篇1）</a></p><p><a href="https://zhuanlan.zhihu.com/p/423195382">Github学生开发包都有什么？（开发与设计工具篇2）</a></p><p><a href="https://zhuanlan.zhihu.com/p/422851915">Github学生开发包都有什么？（云服务商和域名篇）</a></p><p><a href="https://zhuanlan.zhihu.com/p/398954757">Github 学生开发包都有什么？（在线学习篇）</a></p><h1 id="申请Github-Education-Pack"><a href="#申请Github-Education-Pack" class="headerlink" title="申请Github Education Pack"></a>申请Github Education Pack</h1><p>首先，确保github能够访问你的位置信息，而且在申请的过程中，尽量不要打开VPN（否则有的界面会报502错误）。</p><p>在<a href="https://education.github.com/pack">这里</a>可以进行申请，在如下界面中：</p><p><img src="/2022/09/17/github-education-pack/1663395078668.png"></p><p>点击“Sign up for Student Developer”选项，跳转到如下界面：</p><p><img src="/2022/09/17/github-education-pack/1663395128178.png"></p><p>点击“Get student benefits”选项。</p><p>在如下的表单里，填写信息即可：</p><p><img src="/2022/09/17/github-education-pack/1663395307241.png"></p><p>如果您没有.edu结尾的邮箱的话，所提供的邮件地址可以是你的个人邮件地址。另外，在“How do you plan to use GitHub?”一栏中，用<font color="red">英语<a href="%E6%88%91%E5%90%8C%E5%AD%A6%E5%B0%9D%E8%AF%95%E7%94%A8%E4%B8%AD%E6%96%87%E7%94%B3%E8%AF%B7%EF%BC%8C%E7%BB%93%E6%9E%9C%E6%B2%A1%E9%80%9A%E8%BF%87%E3%80%82">^1</a></font>写上你使用github的理由，不必很具体。填写完之后点击“Continue”。</p><p>在这之后，你会被要求上传学生证之类文件的照片。这里注意，请在你的学生证&#x2F;卡的照片上标注好英文翻译，像下面这样：</p><p><img src="/2022/09/17/github-education-pack/1663395724302.png"></p><p>这里有几点需要注意：</p><ol><li>照片上要有学校名称。</li><li>照片上标注好翻译。特别的，对于“姓名”的翻译来说，要标注好自己的英文名，而且要把你的github profile里的名称改成和这个名字一样。</li></ol><p>最后申请，很快就会通过，通过时间从1分钟-5天左右不等，到时候github会给你的邮箱发一封邮件。</p><h1 id="申请JetBrains产品"><a href="#申请JetBrains产品" class="headerlink" title="申请JetBrains产品"></a>申请JetBrains产品</h1><p>JetBrains出品了许多IDE，例如PyCharm、CLion、Intellij IDEA等。</p><p>在<a href="https://www.jetbrains.com/community/education/#students">这里</a>可以进行申请。</p><p><img src="/2022/09/17/github-education-pack/1663396291123.png"></p><p>点击“Apply Now”，在跳出的页面中选中GitHub选项，</p><p><img src="/2022/09/17/github-education-pack/1663396343744.png"></p><p>最后根据所给提示和它们发的邮件按步骤操作就可以了。</p><p>注意，只要你是学生就可以一直免费使用JetBrains产品，但是每年都需要认证一次。</p><h1 id="申请其它产品"><a href="#申请其它产品" class="headerlink" title="申请其它产品"></a>申请其它产品</h1><p>注意，一些产品只提供有限的使用时限。</p><p>在<a href="https://education.github.com/pack/offers">这里</a>，你可以看到每一个工具的简单介绍。一旦申请成功，便可以简单的通过点击超链接获取，比如：</p><p><img src="/2022/09/17/github-education-pack/1663398010434.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂谈】生成、块茎和政治性宏大叙事</title>
      <link href="/2022/09/15/Rhizome-and-politics/"/>
      <url>/2022/09/15/Rhizome-and-politics/</url>
      
        <content type="html"><![CDATA[<blockquote><p>哲学，唯有哲学。——吉尔·德勒兹</p></blockquote><h1 id="生成和块茎"><a href="#生成和块茎" class="headerlink" title="生成和块茎"></a>生成和块茎</h1><p>生成，是德勒兹的一个概念。德勒兹认为，一个事物的本质，不在于它是什么，而在于它能成为、创造什么。如果想定义人，就不能从“人是什么”这个问题入手，而要从“人能创造什么”入手。人类已经创造的东西，和将来要创造的东西，组成了人类的定义。生成这个概念也可以用来形容一个系统，“填鸭式教育”就是“反生成的”，因为它的目的在于知识的“拷贝-粘贴”，而不是“利用-创造”。</p><p>块茎，是德勒兹的另一个概念。德勒兹认为，一个系统有两种组成形式——“主根-须根”式和“块茎”式。德勒兹对于前一种形式持批判态度。他认为，对于“主根-须根”结构来说，一旦主根死亡了，以之为生的须根亦会萎缩、消亡，这个系统的抗逆性很低；而“块茎”结构——您可以把它想做一堆点，每个点都彼此相连——则非常稳定，一个点死了，不影响整个系统的营养传输，这是一个健壮（Robust）的系统。德勒兹还认为，我们的社会已经变成块茎式的控制论社会了，即我们的社会由不同的系统组成。举个例子，义务教育便是一个系统，包含着小学和初中两个系统，这些系统又包含着一些诸如一年级、二年级的小系统，输入是人，输出也是人。</p><h1 id="政治性的宏大叙事"><a href="#政治性的宏大叙事" class="headerlink" title="政治性的宏大叙事"></a>政治性的宏大叙事</h1><p>知乎上有这样一个问题，“为什么越沉迷宏大叙事的年轻人，越成不了事？”。我们先解释一下何为“宏大叙事”：所谓宏大叙事，是一个舶来词，是指对社会、文化、历史的总体性、根本性解释，以及由此而推导的为构建理想社会所应进行的行为<a href="%E5%BC%95%E8%87%AA%E8%87%AD%E5%90%8D%E6%98%AD%E8%91%97%E7%9A%84%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91">^1</a>。很难理解，对不对？我们简化一下，所谓“宏大叙事”，就是从“长远角度”、“国家战略层面”的角度来思考某类问题。我只讨论政治性的宏大叙事。</p><h1 id="生成、块茎和政治性宏大叙事"><a href="#生成、块茎和政治性宏大叙事" class="headerlink" title="生成、块茎和政治性宏大叙事"></a>生成、块茎和政治性宏大叙事</h1><p>我们不妨用“块茎|主根-须根”的理论来分析一下，宏大叙事的思考方式本质上是一种“主根-须根”式的思考方式：国家是主根，被统治的人们是须根。它会将国家视作主体，对外，这样的思考方式则用国家代表人民；对内，它要求人民依附于国家，甚至将国家与人民对立起来，因为主根和须根是有身份上的天然差异的。不难看出，这样的思考方式，不论是思考国际还是国内事务，都让国家占据了主导地位。</p><p>国家不是这样组织起来的。人们聚集起来，逐渐形成了聚落，渐渐形成了国家。国家和人民不是“主根-须根”结构，也不是“块茎”结构——国家不和人们相连——而是：如果把人民看成不同的原子，国家就是这些原子组成的化合物，人民的“块茎”结构形成了一个稳固（或者不稳固）的“层”。</p><p>拥有“政治性的宏大叙事思维方式”的人，忽略了每一个人的彼此各异的基本利益，转而去追求由人民组织起来的“国家”的利益，这多少有一点讽刺了。</p><p>我并不是说，政治性的宏大叙事是绝对错误的，它是一种思考方式，一种考虑问题的框架。沉迷于这种框架，甚至把它视为绝对真理，就会不经意间忽视国家的一个个小单元——人的利益。框架，永远都是“反生成”的，包括我所用的德勒兹的框架，只是，它的框架却有着“生成”的力量。</p><p>沉迷于政治性宏大叙事的年轻人，大概率还是自己没有“生活的锚点”或者信念，需要一个事物来标定自己的意义，没有什么比“国家利益”之类的事物更合适了。成不了事，不是因为“沉迷宏大叙事”，而是这背后内心的软弱或迷茫。</p><h1 id="意义的谎言"><a href="#意义的谎言" class="headerlink" title="意义的谎言"></a>意义的谎言</h1><p>迷茫。是的，迷茫。“上帝已死”，没有什么普适性的意义了。</p><p>我直到现在也这样认为：这个世界实在是没有什么意义，干干瘪瘪，行将腐化。但是，正如你我所见，它还在相对稳定的运转着。为什么呢？和政治性宏大叙事一个道理，人们创造了各式各样的意义，这些意义足够迷惑很多人，让他们以之为“生命的锚点”，并为之努力，奔波，忙碌。</p><p>“没有意义”何尝不能成为锚点？“没有意义”不正是自由的象征吗？正如德勒兹所言，一件事物的意义不在于“是什么”，而在于能“生成”什么。尽管去创造吧。像游牧民族（德勒兹的另一个重要概念）那样，居无定所（不受框架束缚），随心所欲。如果我们还不能像“游牧民族”那样，那么便创造一个游牧民族的社会出来吧。</p><p>我相信未来是美好的。不要被现实击败，尽管去创造吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】点亮STM32F103ZE的LED</title>
      <link href="/2022/08/05/STM32_LED/"/>
      <url>/2022/08/05/STM32_LED/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关键词：GPIO、单片机、C语言</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文是自己的单片机学习记录。我会从硬件开始，一步步研究，点亮STM32F103ZE的LED小灯，并使之闪烁。如果能给您一点启发，再好不过。我选择的是正点原子的STM32F103ZET6精英开发板。</p><p>要完成这个任务，你需要：</p><ul><li>Keil uVision5</li><li>FlyMcu（或者其他烧录工具）</li><li>开发板原理图</li><li>STM32参考手册</li><li>一点数字电路和模拟电路的知识</li><li>C语言的基础知识</li></ul><h1 id="一、硬件连接"><a href="#一、硬件连接" class="headerlink" title="一、硬件连接"></a>一、硬件连接</h1><p><img src="/2022/08/05/STM32_LED/1659701072743.png"></p><p>LED0和PB5引脚相连，LED1和PE5相连，那么我们就要操纵这两个GPIO引脚的电平，给高电平还是低电平呢？</p><p><img src="/2022/08/05/STM32_LED/1659701344954.png"></p><p>LED和VCC<a href="%E7%94%B5%E8%B7%AF%E4%BE%9B%E7%94%B5%E7%94%B5%E5%8E%8B">^1</a>3.3V相连，所以我们要在引脚处给予低电平，才能使LED小灯亮起，要让它们闪烁，交替给予高低电平就可以了。</p><h1 id="二、GPIO"><a href="#二、GPIO" class="headerlink" title="二、GPIO"></a>二、GPIO</h1><p>GPIO[^2]口的基本结构如下：</p><p><img src="/2022/08/05/STM32_LED/1659701896357.png"></p><p>几个小元件&#x2F;称谓：</p><ul><li>TTL肖特基触发器：即由TTL元件构成的施密特触发器&#x2F;滞回比较器，可以将模拟信号转化为数字信号。</li><li>上拉&#x2F;下拉电阻：同图中VDD[^3]相连为上拉电阻，VSS[^4]相连为下拉电阻。</li></ul><p>GPIO口的几种输入模式：</p><ul><li>浮空输入</li><li>上拉输入</li><li>下拉输入</li><li>模拟输入</li></ul><p>输出模式：</p><ul><li>开漏输出</li><li>开漏复用</li><li>推挽输出</li><li>推挽复用</li></ul><h2 id="浮空输入"><a href="#浮空输入" class="headerlink" title="浮空输入"></a>浮空输入</h2><p>上下拉电阻的开关都不闭合，信号直接通过“IO-触发器-输入数据寄存器”。I&#x2F;O口悬空的时候，输入端电平高低无法确定。</p><h2 id="上拉输入"><a href="#上拉输入" class="headerlink" title="上拉输入"></a>上拉输入</h2><p>在浮空输入基础上，如果上拉电阻的开关闭合，就成了上拉输入模式。I&#x2F;O口悬空时，输入端上拉为高电平。输入低电平时，输出也能为低电平。<font color="red">这里不要错以为输入低电平时，输出由于上拉电阻的影响为高电平！</font></p><h2 id="下拉输入"><a href="#下拉输入" class="headerlink" title="下拉输入"></a>下拉输入</h2><p>在浮空输入的基础上，把下拉电阻的开关闭合，就成了下拉输入模式。I&#x2F;O口悬空时，输入端下拉为低电平。</p><h2 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h2><p>上下拉电阻的开关都不闭合，信号直接通过“IO-模拟输入”至片上外设模块。如果通过触发器，模拟信号会变成数字信号。</p><h2 id="开漏（Open-Drain）和推挽（Push-Pull）"><a href="#开漏（Open-Drain）和推挽（Push-Pull）" class="headerlink" title="开漏（Open-Drain）和推挽（Push-Pull）"></a>开漏（Open-Drain）和推挽（Push-Pull）</h2><p>开漏指输出信号只与NMOS管，而与PMOS管无关。输出为低电平，低电平到达NMOS管栅极，NMOS导通，输出拉至GND[^5]低电平。当高电平到达NMOS管时，不导通，输出悬空。</p><blockquote><p>开漏输出的这一特性一个明显的优势就是可以很方便的调节输出的电平，因为输出电平完全由上拉电阻连接的电源电平决定。所以在需要进行电平转换的地方，非常适合使用开漏输出。<br>开漏输出的这一特性另一个好处在于可以实现”线与”功能，所谓的”线与”指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平。而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件。</p></blockquote><p>推挽指输出信号与PMOS、NMOS管都有关系，低电平令NMOS导通，输出拉低至GND，高电平令PMOS导通，输出拉高至VDD。其电平转换快，但是功耗也高。</p><h2 id="复用输出"><a href="#复用输出" class="headerlink" title="复用输出"></a>复用输出</h2><p>其与另外两种输出的区别就是输出信号的来源不同而已，如图所示。</p><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><p>如何在Keil中创建项目就不再赘述了，具体步骤大概为：创建.c文件-创建项目-引入头文件-把.c文件引入项目中。</p><h2 id="Step-1-LED的初始化函数"><a href="#Step-1-LED的初始化函数" class="headerlink" title="Step 1 LED的初始化函数"></a>Step 1 LED的初始化函数</h2><p>GPIOB,GPIOE分布在APB2总线上，所以使能应该调用APB2的相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE); </span><br></pre></td></tr></table></figure><p>之后，初始化PB5、PE5引脚，设置输入模式、反转速度等等，通过看相关函数的定义，这几句不难写出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Output-Push&amp;Pull</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED0-&gt;PB.5</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Output-Push&amp;Pull</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED1-&gt;PE.5</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOE,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><p>这里将PB5、PE5设置成50MHz的推挽输出。</p><p>然后，我们要设置灯的初态，亮或是灭：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br></pre></td></tr></table></figure><p>这里，我们将PB5、PE5初始状态设为高电平，也就是让LED小灯先灭掉。</p><h2 id="Step2-主函数"><a href="#Step2-主函数" class="headerlink" title="Step2 主函数"></a>Step2 主函数</h2><p>对于单片机来讲，主函数一般是这样的结构——“初始化-死循环”。</p><p>主函数没什么可讲的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED_Init();<span class="comment">//初始化LED</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PB5、PE5变成高电平，LED熄灭</span></span><br><span class="line">        GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">        GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line"></span><br><span class="line">        delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms便于观察情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//PB5、PE5变成低电平，LED亮起</span></span><br><span class="line">        GPIO_ResetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">        GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>喂喂喂，等等！延时函数怎么写哇！正点原子官方给提供了，我会在下一篇文章中研究一下时钟系统。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单纯调库函数属实没多大意思，那些底层的东西，往往才是最有价值的。我写作水平不是很高，诸位凑活着看吧！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/210910238">你彻底弄清GPIO内部结构和各种模式了吗？</a></p><p>[^2]:General Purpose Input Output，通用输入输出<br>[^3]:设备工作电压<br>[^4]:地&#x2F;电源负极，我当作接地来理解<br>[^5]:GrouND，接地<br>[^6]:High Speed Internal<br>[^7]:High Speed External<br>[^8]:Low Speed Internal<br>[^9]:Low Speed External<br>[^10]:Phase Locked Loop，锁相环</p>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新来过</title>
      <link href="/2022/07/28/Restart/"/>
      <url>/2022/07/28/Restart/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说到底，还是因为我不会写文章嘛！</p></blockquote><p>以前自己写的东西大多是在自说自话，毫无意义。现在我要重新经营博客，主要写一些技术上的文章，偶尔会有一些杂谈、书摘、评论。</p><p>我希望在填充自己的知识库的同时，也能给别人一些知识、启示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
